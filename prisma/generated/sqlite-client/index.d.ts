
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Organization
 * 
 */
export type Organization = $Result.DefaultSelection<Prisma.$OrganizationPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model TaskRun
 * 
 */
export type TaskRun = $Result.DefaultSelection<Prisma.$TaskRunPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model Requisition
 * 
 */
export type Requisition = $Result.DefaultSelection<Prisma.$RequisitionPayload>
/**
 * Model WorkflowStep
 * 
 */
export type WorkflowStep = $Result.DefaultSelection<Prisma.$WorkflowStepPayload>
/**
 * Model Meeting
 * 
 */
export type Meeting = $Result.DefaultSelection<Prisma.$MeetingPayload>
/**
 * Model EmailAccount
 * 
 */
export type EmailAccount = $Result.DefaultSelection<Prisma.$EmailAccountPayload>
/**
 * Model EmailActiveSelection
 * 
 */
export type EmailActiveSelection = $Result.DefaultSelection<Prisma.$EmailActiveSelectionPayload>
/**
 * Model Need
 * 
 */
export type Need = $Result.DefaultSelection<Prisma.$NeedPayload>
/**
 * Model NeedWorkflowStep
 * 
 */
export type NeedWorkflowStep = $Result.DefaultSelection<Prisma.$NeedWorkflowStepPayload>
/**
 * Model NeedAttachment
 * 
 */
export type NeedAttachment = $Result.DefaultSelection<Prisma.$NeedAttachmentPayload>
/**
 * Model InvoiceClient
 * 
 */
export type InvoiceClient = $Result.DefaultSelection<Prisma.$InvoiceClientPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceLine
 * 
 */
export type InvoiceLine = $Result.DefaultSelection<Prisma.$InvoiceLinePayload>
/**
 * Model InvoiceSection
 * 
 */
export type InvoiceSection = $Result.DefaultSelection<Prisma.$InvoiceSectionPayload>
/**
 * Model InvoiceSectionLine
 * 
 */
export type InvoiceSectionLine = $Result.DefaultSelection<Prisma.$InvoiceSectionLinePayload>
/**
 * Model InvoicePayment
 * 
 */
export type InvoicePayment = $Result.DefaultSelection<Prisma.$InvoicePaymentPayload>
/**
 * Model ExpenseCategory
 * 
 */
export type ExpenseCategory = $Result.DefaultSelection<Prisma.$ExpenseCategoryPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>
/**
 * Model TreasuryMonth
 * 
 */
export type TreasuryMonth = $Result.DefaultSelection<Prisma.$TreasuryMonthPayload>
/**
 * Model SyncQueue
 * 
 */
export type SyncQueue = $Result.DefaultSelection<Prisma.$SyncQueuePayload>
/**
 * Model SyncStatus
 * 
 */
export type SyncStatus = $Result.DefaultSelection<Prisma.$SyncStatusPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Organizations
 * const organizations = await prisma.organization.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Organizations
   * const organizations = await prisma.organization.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.organization`: Exposes CRUD operations for the **Organization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organizations
    * const organizations = await prisma.organization.findMany()
    * ```
    */
  get organization(): Prisma.OrganizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taskRun`: Exposes CRUD operations for the **TaskRun** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskRuns
    * const taskRuns = await prisma.taskRun.findMany()
    * ```
    */
  get taskRun(): Prisma.TaskRunDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.requisition`: Exposes CRUD operations for the **Requisition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Requisitions
    * const requisitions = await prisma.requisition.findMany()
    * ```
    */
  get requisition(): Prisma.RequisitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflowStep`: Exposes CRUD operations for the **WorkflowStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkflowSteps
    * const workflowSteps = await prisma.workflowStep.findMany()
    * ```
    */
  get workflowStep(): Prisma.WorkflowStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meeting`: Exposes CRUD operations for the **Meeting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Meetings
    * const meetings = await prisma.meeting.findMany()
    * ```
    */
  get meeting(): Prisma.MeetingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailAccount`: Exposes CRUD operations for the **EmailAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAccounts
    * const emailAccounts = await prisma.emailAccount.findMany()
    * ```
    */
  get emailAccount(): Prisma.EmailAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailActiveSelection`: Exposes CRUD operations for the **EmailActiveSelection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailActiveSelections
    * const emailActiveSelections = await prisma.emailActiveSelection.findMany()
    * ```
    */
  get emailActiveSelection(): Prisma.EmailActiveSelectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.need`: Exposes CRUD operations for the **Need** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Needs
    * const needs = await prisma.need.findMany()
    * ```
    */
  get need(): Prisma.NeedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.needWorkflowStep`: Exposes CRUD operations for the **NeedWorkflowStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NeedWorkflowSteps
    * const needWorkflowSteps = await prisma.needWorkflowStep.findMany()
    * ```
    */
  get needWorkflowStep(): Prisma.NeedWorkflowStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.needAttachment`: Exposes CRUD operations for the **NeedAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NeedAttachments
    * const needAttachments = await prisma.needAttachment.findMany()
    * ```
    */
  get needAttachment(): Prisma.NeedAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceClient`: Exposes CRUD operations for the **InvoiceClient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceClients
    * const invoiceClients = await prisma.invoiceClient.findMany()
    * ```
    */
  get invoiceClient(): Prisma.InvoiceClientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceLine`: Exposes CRUD operations for the **InvoiceLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLines
    * const invoiceLines = await prisma.invoiceLine.findMany()
    * ```
    */
  get invoiceLine(): Prisma.InvoiceLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceSection`: Exposes CRUD operations for the **InvoiceSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceSections
    * const invoiceSections = await prisma.invoiceSection.findMany()
    * ```
    */
  get invoiceSection(): Prisma.InvoiceSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoiceSectionLine`: Exposes CRUD operations for the **InvoiceSectionLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceSectionLines
    * const invoiceSectionLines = await prisma.invoiceSectionLine.findMany()
    * ```
    */
  get invoiceSectionLine(): Prisma.InvoiceSectionLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoicePayment`: Exposes CRUD operations for the **InvoicePayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoicePayments
    * const invoicePayments = await prisma.invoicePayment.findMany()
    * ```
    */
  get invoicePayment(): Prisma.InvoicePaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expenseCategory`: Exposes CRUD operations for the **ExpenseCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExpenseCategories
    * const expenseCategories = await prisma.expenseCategory.findMany()
    * ```
    */
  get expenseCategory(): Prisma.ExpenseCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.treasuryMonth`: Exposes CRUD operations for the **TreasuryMonth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TreasuryMonths
    * const treasuryMonths = await prisma.treasuryMonth.findMany()
    * ```
    */
  get treasuryMonth(): Prisma.TreasuryMonthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncQueue`: Exposes CRUD operations for the **SyncQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncQueues
    * const syncQueues = await prisma.syncQueue.findMany()
    * ```
    */
  get syncQueue(): Prisma.SyncQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.syncStatus`: Exposes CRUD operations for the **SyncStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncStatuses
    * const syncStatuses = await prisma.syncStatus.findMany()
    * ```
    */
  get syncStatus(): Prisma.SyncStatusDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Organization: 'Organization',
    User: 'User',
    Message: 'Message',
    Task: 'Task',
    TaskRun: 'TaskRun',
    ActivityLog: 'ActivityLog',
    Requisition: 'Requisition',
    WorkflowStep: 'WorkflowStep',
    Meeting: 'Meeting',
    EmailAccount: 'EmailAccount',
    EmailActiveSelection: 'EmailActiveSelection',
    Need: 'Need',
    NeedWorkflowStep: 'NeedWorkflowStep',
    NeedAttachment: 'NeedAttachment',
    InvoiceClient: 'InvoiceClient',
    Invoice: 'Invoice',
    InvoiceLine: 'InvoiceLine',
    InvoiceSection: 'InvoiceSection',
    InvoiceSectionLine: 'InvoiceSectionLine',
    InvoicePayment: 'InvoicePayment',
    ExpenseCategory: 'ExpenseCategory',
    Expense: 'Expense',
    TreasuryMonth: 'TreasuryMonth',
    SyncQueue: 'SyncQueue',
    SyncStatus: 'SyncStatus'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "organization" | "user" | "message" | "task" | "taskRun" | "activityLog" | "requisition" | "workflowStep" | "meeting" | "emailAccount" | "emailActiveSelection" | "need" | "needWorkflowStep" | "needAttachment" | "invoiceClient" | "invoice" | "invoiceLine" | "invoiceSection" | "invoiceSectionLine" | "invoicePayment" | "expenseCategory" | "expense" | "treasuryMonth" | "syncQueue" | "syncStatus"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Organization: {
        payload: Prisma.$OrganizationPayload<ExtArgs>
        fields: Prisma.OrganizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findFirst: {
            args: Prisma.OrganizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          findMany: {
            args: Prisma.OrganizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          create: {
            args: Prisma.OrganizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          createMany: {
            args: Prisma.OrganizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrganizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          delete: {
            args: Prisma.OrganizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          update: {
            args: Prisma.OrganizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          deleteMany: {
            args: Prisma.OrganizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrganizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>[]
          }
          upsert: {
            args: Prisma.OrganizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganizationPayload>
          }
          aggregate: {
            args: Prisma.OrganizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganization>
          }
          groupBy: {
            args: Prisma.OrganizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganizationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganizationCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      TaskRun: {
        payload: Prisma.$TaskRunPayload<ExtArgs>
        fields: Prisma.TaskRunFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskRunFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskRunFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload>
          }
          findFirst: {
            args: Prisma.TaskRunFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskRunFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload>
          }
          findMany: {
            args: Prisma.TaskRunFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload>[]
          }
          create: {
            args: Prisma.TaskRunCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload>
          }
          createMany: {
            args: Prisma.TaskRunCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskRunCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload>[]
          }
          delete: {
            args: Prisma.TaskRunDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload>
          }
          update: {
            args: Prisma.TaskRunUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload>
          }
          deleteMany: {
            args: Prisma.TaskRunDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskRunUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskRunUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload>[]
          }
          upsert: {
            args: Prisma.TaskRunUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskRunPayload>
          }
          aggregate: {
            args: Prisma.TaskRunAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaskRun>
          }
          groupBy: {
            args: Prisma.TaskRunGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskRunGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskRunCountArgs<ExtArgs>
            result: $Utils.Optional<TaskRunCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ActivityLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      Requisition: {
        payload: Prisma.$RequisitionPayload<ExtArgs>
        fields: Prisma.RequisitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RequisitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RequisitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload>
          }
          findFirst: {
            args: Prisma.RequisitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RequisitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload>
          }
          findMany: {
            args: Prisma.RequisitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload>[]
          }
          create: {
            args: Prisma.RequisitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload>
          }
          createMany: {
            args: Prisma.RequisitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RequisitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload>[]
          }
          delete: {
            args: Prisma.RequisitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload>
          }
          update: {
            args: Prisma.RequisitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload>
          }
          deleteMany: {
            args: Prisma.RequisitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RequisitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RequisitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload>[]
          }
          upsert: {
            args: Prisma.RequisitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RequisitionPayload>
          }
          aggregate: {
            args: Prisma.RequisitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRequisition>
          }
          groupBy: {
            args: Prisma.RequisitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<RequisitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.RequisitionCountArgs<ExtArgs>
            result: $Utils.Optional<RequisitionCountAggregateOutputType> | number
          }
        }
      }
      WorkflowStep: {
        payload: Prisma.$WorkflowStepPayload<ExtArgs>
        fields: Prisma.WorkflowStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          findFirst: {
            args: Prisma.WorkflowStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          findMany: {
            args: Prisma.WorkflowStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>[]
          }
          create: {
            args: Prisma.WorkflowStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          createMany: {
            args: Prisma.WorkflowStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>[]
          }
          delete: {
            args: Prisma.WorkflowStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          update: {
            args: Prisma.WorkflowStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkflowStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>[]
          }
          upsert: {
            args: Prisma.WorkflowStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowStepPayload>
          }
          aggregate: {
            args: Prisma.WorkflowStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflowStep>
          }
          groupBy: {
            args: Prisma.WorkflowStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowStepCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowStepCountAggregateOutputType> | number
          }
        }
      }
      Meeting: {
        payload: Prisma.$MeetingPayload<ExtArgs>
        fields: Prisma.MeetingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findFirst: {
            args: Prisma.MeetingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          findMany: {
            args: Prisma.MeetingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          create: {
            args: Prisma.MeetingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          createMany: {
            args: Prisma.MeetingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          delete: {
            args: Prisma.MeetingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          update: {
            args: Prisma.MeetingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          deleteMany: {
            args: Prisma.MeetingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MeetingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>[]
          }
          upsert: {
            args: Prisma.MeetingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingPayload>
          }
          aggregate: {
            args: Prisma.MeetingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeeting>
          }
          groupBy: {
            args: Prisma.MeetingGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingCountAggregateOutputType> | number
          }
        }
      }
      EmailAccount: {
        payload: Prisma.$EmailAccountPayload<ExtArgs>
        fields: Prisma.EmailAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          findFirst: {
            args: Prisma.EmailAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          findMany: {
            args: Prisma.EmailAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>[]
          }
          create: {
            args: Prisma.EmailAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          createMany: {
            args: Prisma.EmailAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>[]
          }
          delete: {
            args: Prisma.EmailAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          update: {
            args: Prisma.EmailAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          deleteMany: {
            args: Prisma.EmailAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>[]
          }
          upsert: {
            args: Prisma.EmailAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAccountPayload>
          }
          aggregate: {
            args: Prisma.EmailAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAccount>
          }
          groupBy: {
            args: Prisma.EmailAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAccountCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAccountCountAggregateOutputType> | number
          }
        }
      }
      EmailActiveSelection: {
        payload: Prisma.$EmailActiveSelectionPayload<ExtArgs>
        fields: Prisma.EmailActiveSelectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailActiveSelectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailActiveSelectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload>
          }
          findFirst: {
            args: Prisma.EmailActiveSelectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailActiveSelectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload>
          }
          findMany: {
            args: Prisma.EmailActiveSelectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload>[]
          }
          create: {
            args: Prisma.EmailActiveSelectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload>
          }
          createMany: {
            args: Prisma.EmailActiveSelectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailActiveSelectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload>[]
          }
          delete: {
            args: Prisma.EmailActiveSelectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload>
          }
          update: {
            args: Prisma.EmailActiveSelectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload>
          }
          deleteMany: {
            args: Prisma.EmailActiveSelectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailActiveSelectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailActiveSelectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload>[]
          }
          upsert: {
            args: Prisma.EmailActiveSelectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailActiveSelectionPayload>
          }
          aggregate: {
            args: Prisma.EmailActiveSelectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailActiveSelection>
          }
          groupBy: {
            args: Prisma.EmailActiveSelectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailActiveSelectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailActiveSelectionCountArgs<ExtArgs>
            result: $Utils.Optional<EmailActiveSelectionCountAggregateOutputType> | number
          }
        }
      }
      Need: {
        payload: Prisma.$NeedPayload<ExtArgs>
        fields: Prisma.NeedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NeedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NeedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload>
          }
          findFirst: {
            args: Prisma.NeedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NeedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload>
          }
          findMany: {
            args: Prisma.NeedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload>[]
          }
          create: {
            args: Prisma.NeedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload>
          }
          createMany: {
            args: Prisma.NeedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NeedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload>[]
          }
          delete: {
            args: Prisma.NeedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload>
          }
          update: {
            args: Prisma.NeedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload>
          }
          deleteMany: {
            args: Prisma.NeedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NeedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NeedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload>[]
          }
          upsert: {
            args: Prisma.NeedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedPayload>
          }
          aggregate: {
            args: Prisma.NeedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNeed>
          }
          groupBy: {
            args: Prisma.NeedGroupByArgs<ExtArgs>
            result: $Utils.Optional<NeedGroupByOutputType>[]
          }
          count: {
            args: Prisma.NeedCountArgs<ExtArgs>
            result: $Utils.Optional<NeedCountAggregateOutputType> | number
          }
        }
      }
      NeedWorkflowStep: {
        payload: Prisma.$NeedWorkflowStepPayload<ExtArgs>
        fields: Prisma.NeedWorkflowStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NeedWorkflowStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NeedWorkflowStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload>
          }
          findFirst: {
            args: Prisma.NeedWorkflowStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NeedWorkflowStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload>
          }
          findMany: {
            args: Prisma.NeedWorkflowStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload>[]
          }
          create: {
            args: Prisma.NeedWorkflowStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload>
          }
          createMany: {
            args: Prisma.NeedWorkflowStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NeedWorkflowStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload>[]
          }
          delete: {
            args: Prisma.NeedWorkflowStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload>
          }
          update: {
            args: Prisma.NeedWorkflowStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload>
          }
          deleteMany: {
            args: Prisma.NeedWorkflowStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NeedWorkflowStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NeedWorkflowStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload>[]
          }
          upsert: {
            args: Prisma.NeedWorkflowStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedWorkflowStepPayload>
          }
          aggregate: {
            args: Prisma.NeedWorkflowStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNeedWorkflowStep>
          }
          groupBy: {
            args: Prisma.NeedWorkflowStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<NeedWorkflowStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.NeedWorkflowStepCountArgs<ExtArgs>
            result: $Utils.Optional<NeedWorkflowStepCountAggregateOutputType> | number
          }
        }
      }
      NeedAttachment: {
        payload: Prisma.$NeedAttachmentPayload<ExtArgs>
        fields: Prisma.NeedAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NeedAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NeedAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload>
          }
          findFirst: {
            args: Prisma.NeedAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NeedAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload>
          }
          findMany: {
            args: Prisma.NeedAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload>[]
          }
          create: {
            args: Prisma.NeedAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload>
          }
          createMany: {
            args: Prisma.NeedAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NeedAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload>[]
          }
          delete: {
            args: Prisma.NeedAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload>
          }
          update: {
            args: Prisma.NeedAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.NeedAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NeedAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NeedAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.NeedAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NeedAttachmentPayload>
          }
          aggregate: {
            args: Prisma.NeedAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNeedAttachment>
          }
          groupBy: {
            args: Prisma.NeedAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<NeedAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.NeedAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<NeedAttachmentCountAggregateOutputType> | number
          }
        }
      }
      InvoiceClient: {
        payload: Prisma.$InvoiceClientPayload<ExtArgs>
        fields: Prisma.InvoiceClientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceClientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceClientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload>
          }
          findFirst: {
            args: Prisma.InvoiceClientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceClientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload>
          }
          findMany: {
            args: Prisma.InvoiceClientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload>[]
          }
          create: {
            args: Prisma.InvoiceClientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload>
          }
          createMany: {
            args: Prisma.InvoiceClientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceClientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload>[]
          }
          delete: {
            args: Prisma.InvoiceClientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload>
          }
          update: {
            args: Prisma.InvoiceClientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceClientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceClientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceClientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceClientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceClientPayload>
          }
          aggregate: {
            args: Prisma.InvoiceClientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceClient>
          }
          groupBy: {
            args: Prisma.InvoiceClientGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceClientGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceClientCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceClientCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLine: {
        payload: Prisma.$InvoiceLinePayload<ExtArgs>
        fields: Prisma.InvoiceLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findFirst: {
            args: Prisma.InvoiceLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findMany: {
            args: Prisma.InvoiceLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          create: {
            args: Prisma.InvoiceLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          createMany: {
            args: Prisma.InvoiceLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          delete: {
            args: Prisma.InvoiceLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          update: {
            args: Prisma.InvoiceLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          aggregate: {
            args: Prisma.InvoiceLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceLine>
          }
          groupBy: {
            args: Prisma.InvoiceLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLineCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineCountAggregateOutputType> | number
          }
        }
      }
      InvoiceSection: {
        payload: Prisma.$InvoiceSectionPayload<ExtArgs>
        fields: Prisma.InvoiceSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload>
          }
          findFirst: {
            args: Prisma.InvoiceSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload>
          }
          findMany: {
            args: Prisma.InvoiceSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload>[]
          }
          create: {
            args: Prisma.InvoiceSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload>
          }
          createMany: {
            args: Prisma.InvoiceSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload>[]
          }
          delete: {
            args: Prisma.InvoiceSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload>
          }
          update: {
            args: Prisma.InvoiceSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload>[]
          }
          upsert: {
            args: Prisma.InvoiceSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionPayload>
          }
          aggregate: {
            args: Prisma.InvoiceSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceSection>
          }
          groupBy: {
            args: Prisma.InvoiceSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceSectionCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceSectionCountAggregateOutputType> | number
          }
        }
      }
      InvoiceSectionLine: {
        payload: Prisma.$InvoiceSectionLinePayload<ExtArgs>
        fields: Prisma.InvoiceSectionLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceSectionLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceSectionLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload>
          }
          findFirst: {
            args: Prisma.InvoiceSectionLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceSectionLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload>
          }
          findMany: {
            args: Prisma.InvoiceSectionLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload>[]
          }
          create: {
            args: Prisma.InvoiceSectionLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload>
          }
          createMany: {
            args: Prisma.InvoiceSectionLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceSectionLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload>[]
          }
          delete: {
            args: Prisma.InvoiceSectionLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload>
          }
          update: {
            args: Prisma.InvoiceSectionLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceSectionLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceSectionLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceSectionLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceSectionLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceSectionLinePayload>
          }
          aggregate: {
            args: Prisma.InvoiceSectionLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceSectionLine>
          }
          groupBy: {
            args: Prisma.InvoiceSectionLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceSectionLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceSectionLineCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceSectionLineCountAggregateOutputType> | number
          }
        }
      }
      InvoicePayment: {
        payload: Prisma.$InvoicePaymentPayload<ExtArgs>
        fields: Prisma.InvoicePaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoicePaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoicePaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          findFirst: {
            args: Prisma.InvoicePaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoicePaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          findMany: {
            args: Prisma.InvoicePaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
          }
          create: {
            args: Prisma.InvoicePaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          createMany: {
            args: Prisma.InvoicePaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoicePaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
          }
          delete: {
            args: Prisma.InvoicePaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          update: {
            args: Prisma.InvoicePaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          deleteMany: {
            args: Prisma.InvoicePaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoicePaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoicePaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>[]
          }
          upsert: {
            args: Prisma.InvoicePaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePaymentPayload>
          }
          aggregate: {
            args: Prisma.InvoicePaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoicePayment>
          }
          groupBy: {
            args: Prisma.InvoicePaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoicePaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoicePaymentCountArgs<ExtArgs>
            result: $Utils.Optional<InvoicePaymentCountAggregateOutputType> | number
          }
        }
      }
      ExpenseCategory: {
        payload: Prisma.$ExpenseCategoryPayload<ExtArgs>
        fields: Prisma.ExpenseCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findFirst: {
            args: Prisma.ExpenseCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          findMany: {
            args: Prisma.ExpenseCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          create: {
            args: Prisma.ExpenseCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          createMany: {
            args: Prisma.ExpenseCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          delete: {
            args: Prisma.ExpenseCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          update: {
            args: Prisma.ExpenseCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          deleteMany: {
            args: Prisma.ExpenseCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>[]
          }
          upsert: {
            args: Prisma.ExpenseCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpenseCategoryPayload>
          }
          aggregate: {
            args: Prisma.ExpenseCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpenseCategory>
          }
          groupBy: {
            args: Prisma.ExpenseCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCategoryCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
      TreasuryMonth: {
        payload: Prisma.$TreasuryMonthPayload<ExtArgs>
        fields: Prisma.TreasuryMonthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TreasuryMonthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TreasuryMonthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload>
          }
          findFirst: {
            args: Prisma.TreasuryMonthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TreasuryMonthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload>
          }
          findMany: {
            args: Prisma.TreasuryMonthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload>[]
          }
          create: {
            args: Prisma.TreasuryMonthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload>
          }
          createMany: {
            args: Prisma.TreasuryMonthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TreasuryMonthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload>[]
          }
          delete: {
            args: Prisma.TreasuryMonthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload>
          }
          update: {
            args: Prisma.TreasuryMonthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload>
          }
          deleteMany: {
            args: Prisma.TreasuryMonthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TreasuryMonthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TreasuryMonthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload>[]
          }
          upsert: {
            args: Prisma.TreasuryMonthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TreasuryMonthPayload>
          }
          aggregate: {
            args: Prisma.TreasuryMonthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTreasuryMonth>
          }
          groupBy: {
            args: Prisma.TreasuryMonthGroupByArgs<ExtArgs>
            result: $Utils.Optional<TreasuryMonthGroupByOutputType>[]
          }
          count: {
            args: Prisma.TreasuryMonthCountArgs<ExtArgs>
            result: $Utils.Optional<TreasuryMonthCountAggregateOutputType> | number
          }
        }
      }
      SyncQueue: {
        payload: Prisma.$SyncQueuePayload<ExtArgs>
        fields: Prisma.SyncQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          findFirst: {
            args: Prisma.SyncQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          findMany: {
            args: Prisma.SyncQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>[]
          }
          create: {
            args: Prisma.SyncQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          createMany: {
            args: Prisma.SyncQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>[]
          }
          delete: {
            args: Prisma.SyncQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          update: {
            args: Prisma.SyncQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          deleteMany: {
            args: Prisma.SyncQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>[]
          }
          upsert: {
            args: Prisma.SyncQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncQueuePayload>
          }
          aggregate: {
            args: Prisma.SyncQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncQueue>
          }
          groupBy: {
            args: Prisma.SyncQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncQueueCountArgs<ExtArgs>
            result: $Utils.Optional<SyncQueueCountAggregateOutputType> | number
          }
        }
      }
      SyncStatus: {
        payload: Prisma.$SyncStatusPayload<ExtArgs>
        fields: Prisma.SyncStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SyncStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SyncStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          findFirst: {
            args: Prisma.SyncStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SyncStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          findMany: {
            args: Prisma.SyncStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>[]
          }
          create: {
            args: Prisma.SyncStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          createMany: {
            args: Prisma.SyncStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SyncStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>[]
          }
          delete: {
            args: Prisma.SyncStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          update: {
            args: Prisma.SyncStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          deleteMany: {
            args: Prisma.SyncStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SyncStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SyncStatusUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>[]
          }
          upsert: {
            args: Prisma.SyncStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SyncStatusPayload>
          }
          aggregate: {
            args: Prisma.SyncStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSyncStatus>
          }
          groupBy: {
            args: Prisma.SyncStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<SyncStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.SyncStatusCountArgs<ExtArgs>
            result: $Utils.Optional<SyncStatusCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    organization?: OrganizationOmit
    user?: UserOmit
    message?: MessageOmit
    task?: TaskOmit
    taskRun?: TaskRunOmit
    activityLog?: ActivityLogOmit
    requisition?: RequisitionOmit
    workflowStep?: WorkflowStepOmit
    meeting?: MeetingOmit
    emailAccount?: EmailAccountOmit
    emailActiveSelection?: EmailActiveSelectionOmit
    need?: NeedOmit
    needWorkflowStep?: NeedWorkflowStepOmit
    needAttachment?: NeedAttachmentOmit
    invoiceClient?: InvoiceClientOmit
    invoice?: InvoiceOmit
    invoiceLine?: InvoiceLineOmit
    invoiceSection?: InvoiceSectionOmit
    invoiceSectionLine?: InvoiceSectionLineOmit
    invoicePayment?: InvoicePaymentOmit
    expenseCategory?: ExpenseCategoryOmit
    expense?: ExpenseOmit
    treasuryMonth?: TreasuryMonthOmit
    syncQueue?: SyncQueueOmit
    syncStatus?: SyncStatusOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type OrganizationCountOutputType
   */

  export type OrganizationCountOutputType = {
    users: number
    messages: number
    tasks: number
    activityLogs: number
    requisitions: number
    needs: number
    meetings: number
    emailAccounts: number
    emailSelections: number
  }

  export type OrganizationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | OrganizationCountOutputTypeCountUsersArgs
    messages?: boolean | OrganizationCountOutputTypeCountMessagesArgs
    tasks?: boolean | OrganizationCountOutputTypeCountTasksArgs
    activityLogs?: boolean | OrganizationCountOutputTypeCountActivityLogsArgs
    requisitions?: boolean | OrganizationCountOutputTypeCountRequisitionsArgs
    needs?: boolean | OrganizationCountOutputTypeCountNeedsArgs
    meetings?: boolean | OrganizationCountOutputTypeCountMeetingsArgs
    emailAccounts?: boolean | OrganizationCountOutputTypeCountEmailAccountsArgs
    emailSelections?: boolean | OrganizationCountOutputTypeCountEmailSelectionsArgs
  }

  // Custom InputTypes
  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganizationCountOutputType
     */
    select?: OrganizationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountRequisitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequisitionWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountNeedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NeedWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountMeetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountEmailAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAccountWhereInput
  }

  /**
   * OrganizationCountOutputType without action
   */
  export type OrganizationCountOutputTypeCountEmailSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailActiveSelectionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    messages: number
    tasks: number
    activityLogs: number
    requisitionsRequested: number
    workflowStepsReviewed: number
    needsRequested: number
    needWorkflowStepsReviewed: number
    meetingsCreated: number
    emailAccounts: number
    emailSelections: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
    requisitionsRequested?: boolean | UserCountOutputTypeCountRequisitionsRequestedArgs
    workflowStepsReviewed?: boolean | UserCountOutputTypeCountWorkflowStepsReviewedArgs
    needsRequested?: boolean | UserCountOutputTypeCountNeedsRequestedArgs
    needWorkflowStepsReviewed?: boolean | UserCountOutputTypeCountNeedWorkflowStepsReviewedArgs
    meetingsCreated?: boolean | UserCountOutputTypeCountMeetingsCreatedArgs
    emailAccounts?: boolean | UserCountOutputTypeCountEmailAccountsArgs
    emailSelections?: boolean | UserCountOutputTypeCountEmailSelectionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRequisitionsRequestedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequisitionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkflowStepsReviewedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNeedsRequestedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NeedWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNeedWorkflowStepsReviewedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NeedWorkflowStepWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMeetingsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailActiveSelectionWhereInput
  }


  /**
   * Count Type TaskCountOutputType
   */

  export type TaskCountOutputType = {
    runs: number
  }

  export type TaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    runs?: boolean | TaskCountOutputTypeCountRunsArgs
  }

  // Custom InputTypes
  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskCountOutputType
     */
    select?: TaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TaskCountOutputType without action
   */
  export type TaskCountOutputTypeCountRunsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskRunWhereInput
  }


  /**
   * Count Type RequisitionCountOutputType
   */

  export type RequisitionCountOutputType = {
    workflow: number
  }

  export type RequisitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | RequisitionCountOutputTypeCountWorkflowArgs
  }

  // Custom InputTypes
  /**
   * RequisitionCountOutputType without action
   */
  export type RequisitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RequisitionCountOutputType
     */
    select?: RequisitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RequisitionCountOutputType without action
   */
  export type RequisitionCountOutputTypeCountWorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepWhereInput
  }


  /**
   * Count Type EmailAccountCountOutputType
   */

  export type EmailAccountCountOutputType = {
    selections: number
  }

  export type EmailAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    selections?: boolean | EmailAccountCountOutputTypeCountSelectionsArgs
  }

  // Custom InputTypes
  /**
   * EmailAccountCountOutputType without action
   */
  export type EmailAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccountCountOutputType
     */
    select?: EmailAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmailAccountCountOutputType without action
   */
  export type EmailAccountCountOutputTypeCountSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailActiveSelectionWhereInput
  }


  /**
   * Count Type NeedCountOutputType
   */

  export type NeedCountOutputType = {
    workflow: number
    attachments: number
  }

  export type NeedCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workflow?: boolean | NeedCountOutputTypeCountWorkflowArgs
    attachments?: boolean | NeedCountOutputTypeCountAttachmentsArgs
  }

  // Custom InputTypes
  /**
   * NeedCountOutputType without action
   */
  export type NeedCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedCountOutputType
     */
    select?: NeedCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NeedCountOutputType without action
   */
  export type NeedCountOutputTypeCountWorkflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NeedWorkflowStepWhereInput
  }

  /**
   * NeedCountOutputType without action
   */
  export type NeedCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NeedAttachmentWhereInput
  }


  /**
   * Count Type InvoiceClientCountOutputType
   */

  export type InvoiceClientCountOutputType = {
    invoices: number
  }

  export type InvoiceClientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | InvoiceClientCountOutputTypeCountInvoicesArgs
  }

  // Custom InputTypes
  /**
   * InvoiceClientCountOutputType without action
   */
  export type InvoiceClientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClientCountOutputType
     */
    select?: InvoiceClientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceClientCountOutputType without action
   */
  export type InvoiceClientCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    lines: number
    sections: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | InvoiceCountOutputTypeCountLinesArgs
    sections?: boolean | InvoiceCountOutputTypeCountSectionsArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceSectionWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicePaymentWhereInput
  }


  /**
   * Count Type InvoiceSectionCountOutputType
   */

  export type InvoiceSectionCountOutputType = {
    lines: number
  }

  export type InvoiceSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | InvoiceSectionCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * InvoiceSectionCountOutputType without action
   */
  export type InvoiceSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionCountOutputType
     */
    select?: InvoiceSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceSectionCountOutputType without action
   */
  export type InvoiceSectionCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceSectionLineWhereInput
  }


  /**
   * Count Type ExpenseCategoryCountOutputType
   */

  export type ExpenseCategoryCountOutputType = {
    expenses: number
  }

  export type ExpenseCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | ExpenseCategoryCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategoryCountOutputType
     */
    select?: ExpenseCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ExpenseCategoryCountOutputType without action
   */
  export type ExpenseCategoryCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Organization
   */

  export type AggregateOrganization = {
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  export type OrganizationAvgAggregateOutputType = {
    id: number | null
  }

  export type OrganizationSumAggregateOutputType = {
    id: number | null
  }

  export type OrganizationMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
  }

  export type OrganizationMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
  }

  export type OrganizationCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    _all: number
  }


  export type OrganizationAvgAggregateInputType = {
    id?: true
  }

  export type OrganizationSumAggregateInputType = {
    id?: true
  }

  export type OrganizationMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
  }

  export type OrganizationMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
  }

  export type OrganizationCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    _all?: true
  }

  export type OrganizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organization to aggregate.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organizations
    **/
    _count?: true | OrganizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganizationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganizationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganizationMaxAggregateInputType
  }

  export type GetOrganizationAggregateType<T extends OrganizationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganization[P]>
      : GetScalarType<T[P], AggregateOrganization[P]>
  }




  export type OrganizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganizationWhereInput
    orderBy?: OrganizationOrderByWithAggregationInput | OrganizationOrderByWithAggregationInput[]
    by: OrganizationScalarFieldEnum[] | OrganizationScalarFieldEnum
    having?: OrganizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganizationCountAggregateInputType | true
    _avg?: OrganizationAvgAggregateInputType
    _sum?: OrganizationSumAggregateInputType
    _min?: OrganizationMinAggregateInputType
    _max?: OrganizationMaxAggregateInputType
  }

  export type OrganizationGroupByOutputType = {
    id: number
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    _count: OrganizationCountAggregateOutputType | null
    _avg: OrganizationAvgAggregateOutputType | null
    _sum: OrganizationSumAggregateOutputType | null
    _min: OrganizationMinAggregateOutputType | null
    _max: OrganizationMaxAggregateOutputType | null
  }

  type GetOrganizationGroupByPayload<T extends OrganizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganizationGroupByOutputType[P]>
        }
      >
    >


  export type OrganizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    users?: boolean | Organization$usersArgs<ExtArgs>
    messages?: boolean | Organization$messagesArgs<ExtArgs>
    tasks?: boolean | Organization$tasksArgs<ExtArgs>
    activityLogs?: boolean | Organization$activityLogsArgs<ExtArgs>
    requisitions?: boolean | Organization$requisitionsArgs<ExtArgs>
    needs?: boolean | Organization$needsArgs<ExtArgs>
    meetings?: boolean | Organization$meetingsArgs<ExtArgs>
    emailAccounts?: boolean | Organization$emailAccountsArgs<ExtArgs>
    emailSelections?: boolean | Organization$emailSelectionsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
  }, ExtArgs["result"]["organization"]>

  export type OrganizationSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
  }

  export type OrganizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt" | "syncId" | "lastSynced", ExtArgs["result"]["organization"]>
  export type OrganizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Organization$usersArgs<ExtArgs>
    messages?: boolean | Organization$messagesArgs<ExtArgs>
    tasks?: boolean | Organization$tasksArgs<ExtArgs>
    activityLogs?: boolean | Organization$activityLogsArgs<ExtArgs>
    requisitions?: boolean | Organization$requisitionsArgs<ExtArgs>
    needs?: boolean | Organization$needsArgs<ExtArgs>
    meetings?: boolean | Organization$meetingsArgs<ExtArgs>
    emailAccounts?: boolean | Organization$emailAccountsArgs<ExtArgs>
    emailSelections?: boolean | Organization$emailSelectionsArgs<ExtArgs>
    _count?: boolean | OrganizationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrganizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type OrganizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $OrganizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organization"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      requisitions: Prisma.$RequisitionPayload<ExtArgs>[]
      needs: Prisma.$NeedPayload<ExtArgs>[]
      meetings: Prisma.$MeetingPayload<ExtArgs>[]
      emailAccounts: Prisma.$EmailAccountPayload<ExtArgs>[]
      emailSelections: Prisma.$EmailActiveSelectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
    }, ExtArgs["result"]["organization"]>
    composites: {}
  }

  type OrganizationGetPayload<S extends boolean | null | undefined | OrganizationDefaultArgs> = $Result.GetResult<Prisma.$OrganizationPayload, S>

  type OrganizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrganizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrganizationCountAggregateInputType | true
    }

  export interface OrganizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organization'], meta: { name: 'Organization' } }
    /**
     * Find zero or one Organization that matches the filter.
     * @param {OrganizationFindUniqueArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganizationFindUniqueArgs>(args: SelectSubset<T, OrganizationFindUniqueArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Organization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrganizationFindUniqueOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganizationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganizationFindFirstArgs>(args?: SelectSubset<T, OrganizationFindFirstArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Organization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindFirstOrThrowArgs} args - Arguments to find a Organization
     * @example
     * // Get one Organization
     * const organization = await prisma.organization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganizationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Organizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organizations
     * const organizations = await prisma.organization.findMany()
     * 
     * // Get first 10 Organizations
     * const organizations = await prisma.organization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organizationWithIdOnly = await prisma.organization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganizationFindManyArgs>(args?: SelectSubset<T, OrganizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Organization.
     * @param {OrganizationCreateArgs} args - Arguments to create a Organization.
     * @example
     * // Create one Organization
     * const Organization = await prisma.organization.create({
     *   data: {
     *     // ... data to create a Organization
     *   }
     * })
     * 
     */
    create<T extends OrganizationCreateArgs>(args: SelectSubset<T, OrganizationCreateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Organizations.
     * @param {OrganizationCreateManyArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganizationCreateManyArgs>(args?: SelectSubset<T, OrganizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Organizations and returns the data saved in the database.
     * @param {OrganizationCreateManyAndReturnArgs} args - Arguments to create many Organizations.
     * @example
     * // Create many Organizations
     * const organization = await prisma.organization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrganizationCreateManyAndReturnArgs>(args?: SelectSubset<T, OrganizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Organization.
     * @param {OrganizationDeleteArgs} args - Arguments to delete one Organization.
     * @example
     * // Delete one Organization
     * const Organization = await prisma.organization.delete({
     *   where: {
     *     // ... filter to delete one Organization
     *   }
     * })
     * 
     */
    delete<T extends OrganizationDeleteArgs>(args: SelectSubset<T, OrganizationDeleteArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Organization.
     * @param {OrganizationUpdateArgs} args - Arguments to update one Organization.
     * @example
     * // Update one Organization
     * const organization = await prisma.organization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganizationUpdateArgs>(args: SelectSubset<T, OrganizationUpdateArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Organizations.
     * @param {OrganizationDeleteManyArgs} args - Arguments to filter Organizations to delete.
     * @example
     * // Delete a few Organizations
     * const { count } = await prisma.organization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganizationDeleteManyArgs>(args?: SelectSubset<T, OrganizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganizationUpdateManyArgs>(args: SelectSubset<T, OrganizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organizations and returns the data updated in the database.
     * @param {OrganizationUpdateManyAndReturnArgs} args - Arguments to update many Organizations.
     * @example
     * // Update many Organizations
     * const organization = await prisma.organization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Organizations and only return the `id`
     * const organizationWithIdOnly = await prisma.organization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrganizationUpdateManyAndReturnArgs>(args: SelectSubset<T, OrganizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Organization.
     * @param {OrganizationUpsertArgs} args - Arguments to update or create a Organization.
     * @example
     * // Update or create a Organization
     * const organization = await prisma.organization.upsert({
     *   create: {
     *     // ... data to create a Organization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organization we want to update
     *   }
     * })
     */
    upsert<T extends OrganizationUpsertArgs>(args: SelectSubset<T, OrganizationUpsertArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Organizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationCountArgs} args - Arguments to filter Organizations to count.
     * @example
     * // Count the number of Organizations
     * const count = await prisma.organization.count({
     *   where: {
     *     // ... the filter for the Organizations we want to count
     *   }
     * })
    **/
    count<T extends OrganizationCountArgs>(
      args?: Subset<T, OrganizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganizationAggregateArgs>(args: Subset<T, OrganizationAggregateArgs>): Prisma.PrismaPromise<GetOrganizationAggregateType<T>>

    /**
     * Group by Organization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganizationGroupByArgs['orderBy'] }
        : { orderBy?: OrganizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organization model
   */
  readonly fields: OrganizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Organization$usersArgs<ExtArgs> = {}>(args?: Subset<T, Organization$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Organization$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Organization$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends Organization$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Organization$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends Organization$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requisitions<T extends Organization$requisitionsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$requisitionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    needs<T extends Organization$needsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$needsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meetings<T extends Organization$meetingsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$meetingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailAccounts<T extends Organization$emailAccountsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$emailAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailSelections<T extends Organization$emailSelectionsArgs<ExtArgs> = {}>(args?: Subset<T, Organization$emailSelectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organization model
   */
  interface OrganizationFieldRefs {
    readonly id: FieldRef<"Organization", 'Int'>
    readonly name: FieldRef<"Organization", 'String'>
    readonly slug: FieldRef<"Organization", 'String'>
    readonly createdAt: FieldRef<"Organization", 'DateTime'>
    readonly updatedAt: FieldRef<"Organization", 'DateTime'>
    readonly syncId: FieldRef<"Organization", 'String'>
    readonly lastSynced: FieldRef<"Organization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Organization findUnique
   */
  export type OrganizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findUniqueOrThrow
   */
  export type OrganizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization findFirst
   */
  export type OrganizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findFirstOrThrow
   */
  export type OrganizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organization to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organizations.
     */
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization findMany
   */
  export type OrganizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter, which Organizations to fetch.
     */
    where?: OrganizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organizations to fetch.
     */
    orderBy?: OrganizationOrderByWithRelationInput | OrganizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organizations.
     */
    cursor?: OrganizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organizations.
     */
    skip?: number
    distinct?: OrganizationScalarFieldEnum | OrganizationScalarFieldEnum[]
  }

  /**
   * Organization create
   */
  export type OrganizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organization.
     */
    data: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
  }

  /**
   * Organization createMany
   */
  export type OrganizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
  }

  /**
   * Organization createManyAndReturn
   */
  export type OrganizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to create many Organizations.
     */
    data: OrganizationCreateManyInput | OrganizationCreateManyInput[]
  }

  /**
   * Organization update
   */
  export type OrganizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organization.
     */
    data: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
    /**
     * Choose, which Organization to update.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization updateMany
   */
  export type OrganizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization updateManyAndReturn
   */
  export type OrganizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * The data used to update Organizations.
     */
    data: XOR<OrganizationUpdateManyMutationInput, OrganizationUncheckedUpdateManyInput>
    /**
     * Filter which Organizations to update
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to update.
     */
    limit?: number
  }

  /**
   * Organization upsert
   */
  export type OrganizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organization to update in case it exists.
     */
    where: OrganizationWhereUniqueInput
    /**
     * In case the Organization found by the `where` argument doesn't exist, create a new Organization with this data.
     */
    create: XOR<OrganizationCreateInput, OrganizationUncheckedCreateInput>
    /**
     * In case the Organization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganizationUpdateInput, OrganizationUncheckedUpdateInput>
  }

  /**
   * Organization delete
   */
  export type OrganizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
    /**
     * Filter which Organization to delete.
     */
    where: OrganizationWhereUniqueInput
  }

  /**
   * Organization deleteMany
   */
  export type OrganizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organizations to delete
     */
    where?: OrganizationWhereInput
    /**
     * Limit how many Organizations to delete.
     */
    limit?: number
  }

  /**
   * Organization.users
   */
  export type Organization$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Organization.messages
   */
  export type Organization$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Organization.tasks
   */
  export type Organization$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Organization.activityLogs
   */
  export type Organization$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Organization.requisitions
   */
  export type Organization$requisitionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    where?: RequisitionWhereInput
    orderBy?: RequisitionOrderByWithRelationInput | RequisitionOrderByWithRelationInput[]
    cursor?: RequisitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequisitionScalarFieldEnum | RequisitionScalarFieldEnum[]
  }

  /**
   * Organization.needs
   */
  export type Organization$needsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    where?: NeedWhereInput
    orderBy?: NeedOrderByWithRelationInput | NeedOrderByWithRelationInput[]
    cursor?: NeedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NeedScalarFieldEnum | NeedScalarFieldEnum[]
  }

  /**
   * Organization.meetings
   */
  export type Organization$meetingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Organization.emailAccounts
   */
  export type Organization$emailAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    where?: EmailAccountWhereInput
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    cursor?: EmailAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * Organization.emailSelections
   */
  export type Organization$emailSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    where?: EmailActiveSelectionWhereInput
    orderBy?: EmailActiveSelectionOrderByWithRelationInput | EmailActiveSelectionOrderByWithRelationInput[]
    cursor?: EmailActiveSelectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailActiveSelectionScalarFieldEnum | EmailActiveSelectionScalarFieldEnum[]
  }

  /**
   * Organization without action
   */
  export type OrganizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organization
     */
    select?: OrganizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Organization
     */
    omit?: OrganizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganizationInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    organizationId: number | null
    externalId: string | null
    email: string | null
    displayName: string | null
    name: string | null
    pinHash: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    organizationId: number | null
    externalId: string | null
    email: string | null
    displayName: string | null
    name: string | null
    pinHash: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    organizationId: number
    externalId: number
    email: number
    displayName: number
    name: number
    pinHash: number
    role: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
    organizationId?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    organizationId?: true
    externalId?: true
    email?: true
    displayName?: true
    name?: true
    pinHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    organizationId?: true
    externalId?: true
    email?: true
    displayName?: true
    name?: true
    pinHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    organizationId?: true
    externalId?: true
    email?: true
    displayName?: true
    name?: true
    pinHash?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    organizationId: number
    externalId: string | null
    email: string | null
    displayName: string | null
    name: string | null
    pinHash: string | null
    role: string
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    externalId?: boolean
    email?: boolean
    displayName?: boolean
    name?: boolean
    pinHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    requisitionsRequested?: boolean | User$requisitionsRequestedArgs<ExtArgs>
    workflowStepsReviewed?: boolean | User$workflowStepsReviewedArgs<ExtArgs>
    needsRequested?: boolean | User$needsRequestedArgs<ExtArgs>
    needWorkflowStepsReviewed?: boolean | User$needWorkflowStepsReviewedArgs<ExtArgs>
    meetingsCreated?: boolean | User$meetingsCreatedArgs<ExtArgs>
    emailAccounts?: boolean | User$emailAccountsArgs<ExtArgs>
    emailSelections?: boolean | User$emailSelectionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    externalId?: boolean
    email?: boolean
    displayName?: boolean
    name?: boolean
    pinHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    externalId?: boolean
    email?: boolean
    displayName?: boolean
    name?: boolean
    pinHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    organizationId?: boolean
    externalId?: boolean
    email?: boolean
    displayName?: boolean
    name?: boolean
    pinHash?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "externalId" | "email" | "displayName" | "name" | "pinHash" | "role" | "createdAt" | "updatedAt" | "syncId" | "lastSynced", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    requisitionsRequested?: boolean | User$requisitionsRequestedArgs<ExtArgs>
    workflowStepsReviewed?: boolean | User$workflowStepsReviewedArgs<ExtArgs>
    needsRequested?: boolean | User$needsRequestedArgs<ExtArgs>
    needWorkflowStepsReviewed?: boolean | User$needWorkflowStepsReviewedArgs<ExtArgs>
    meetingsCreated?: boolean | User$meetingsCreatedArgs<ExtArgs>
    emailAccounts?: boolean | User$emailAccountsArgs<ExtArgs>
    emailSelections?: boolean | User$emailSelectionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
      requisitionsRequested: Prisma.$RequisitionPayload<ExtArgs>[]
      workflowStepsReviewed: Prisma.$WorkflowStepPayload<ExtArgs>[]
      needsRequested: Prisma.$NeedPayload<ExtArgs>[]
      needWorkflowStepsReviewed: Prisma.$NeedWorkflowStepPayload<ExtArgs>[]
      meetingsCreated: Prisma.$MeetingPayload<ExtArgs>[]
      emailAccounts: Prisma.$EmailAccountPayload<ExtArgs>[]
      emailSelections: Prisma.$EmailActiveSelectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organizationId: number
      externalId: string | null
      email: string | null
      displayName: string | null
      name: string | null
      pinHash: string | null
      role: string
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    requisitionsRequested<T extends User$requisitionsRequestedArgs<ExtArgs> = {}>(args?: Subset<T, User$requisitionsRequestedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workflowStepsReviewed<T extends User$workflowStepsReviewedArgs<ExtArgs> = {}>(args?: Subset<T, User$workflowStepsReviewedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    needsRequested<T extends User$needsRequestedArgs<ExtArgs> = {}>(args?: Subset<T, User$needsRequestedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    needWorkflowStepsReviewed<T extends User$needWorkflowStepsReviewedArgs<ExtArgs> = {}>(args?: Subset<T, User$needWorkflowStepsReviewedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meetingsCreated<T extends User$meetingsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$meetingsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailAccounts<T extends User$emailAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailSelections<T extends User$emailSelectionsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailSelectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly organizationId: FieldRef<"User", 'Int'>
    readonly externalId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly pinHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly syncId: FieldRef<"User", 'String'>
    readonly lastSynced: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User.requisitionsRequested
   */
  export type User$requisitionsRequestedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    where?: RequisitionWhereInput
    orderBy?: RequisitionOrderByWithRelationInput | RequisitionOrderByWithRelationInput[]
    cursor?: RequisitionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RequisitionScalarFieldEnum | RequisitionScalarFieldEnum[]
  }

  /**
   * User.workflowStepsReviewed
   */
  export type User$workflowStepsReviewedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    where?: WorkflowStepWhereInput
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    cursor?: WorkflowStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * User.needsRequested
   */
  export type User$needsRequestedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    where?: NeedWhereInput
    orderBy?: NeedOrderByWithRelationInput | NeedOrderByWithRelationInput[]
    cursor?: NeedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NeedScalarFieldEnum | NeedScalarFieldEnum[]
  }

  /**
   * User.needWorkflowStepsReviewed
   */
  export type User$needWorkflowStepsReviewedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    where?: NeedWorkflowStepWhereInput
    orderBy?: NeedWorkflowStepOrderByWithRelationInput | NeedWorkflowStepOrderByWithRelationInput[]
    cursor?: NeedWorkflowStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NeedWorkflowStepScalarFieldEnum | NeedWorkflowStepScalarFieldEnum[]
  }

  /**
   * User.meetingsCreated
   */
  export type User$meetingsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    cursor?: MeetingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * User.emailAccounts
   */
  export type User$emailAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    where?: EmailAccountWhereInput
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    cursor?: EmailAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * User.emailSelections
   */
  export type User$emailSelectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    where?: EmailActiveSelectionWhereInput
    orderBy?: EmailActiveSelectionOrderByWithRelationInput | EmailActiveSelectionOrderByWithRelationInput[]
    cursor?: EmailActiveSelectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailActiveSelectionScalarFieldEnum | EmailActiveSelectionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
  }

  export type MessageSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
  }

  export type MessageMinAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
    kind: string | null
    channel: string | null
    content: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type MessageMaxAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
    kind: string | null
    channel: string | null
    content: string | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    kind: number
    channel: number
    content: number
    metadata: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    needsSync: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
  }

  export type MessageSumAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
  }

  export type MessageMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    kind?: true
    channel?: true
    content?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    kind?: true
    channel?: true
    content?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    kind?: true
    channel?: true
    content?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: number
    organizationId: number
    userId: number | null
    kind: string
    channel: string | null
    content: string
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    kind?: boolean
    channel?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    kind?: boolean
    channel?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    kind?: boolean
    channel?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    kind?: boolean
    channel?: boolean
    content?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "kind" | "channel" | "content" | "metadata" | "createdAt" | "updatedAt" | "syncId" | "lastSynced" | "needsSync", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Message$userArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organizationId: number
      userId: number | null
      kind: string
      channel: string | null
      content: string
      metadata: string | null
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
      needsSync: boolean
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Message$userArgs<ExtArgs> = {}>(args?: Subset<T, Message$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'Int'>
    readonly organizationId: FieldRef<"Message", 'Int'>
    readonly userId: FieldRef<"Message", 'Int'>
    readonly kind: FieldRef<"Message", 'String'>
    readonly channel: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly metadata: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly syncId: FieldRef<"Message", 'String'>
    readonly lastSynced: FieldRef<"Message", 'DateTime'>
    readonly needsSync: FieldRef<"Message", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.user
   */
  export type Message$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
  }

  export type TaskSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
  }

  export type TaskMinAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
    title: string | null
    description: string | null
    status: string | null
    dueAt: Date | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type TaskMaxAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
    title: string | null
    description: string | null
    status: string | null
    dueAt: Date | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    title: number
    description: number
    status: number
    dueAt: number
    metadata: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    needsSync: number
    _all: number
  }


  export type TaskAvgAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
  }

  export type TaskSumAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
  }

  export type TaskMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    title?: true
    description?: true
    status?: true
    dueAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    title?: true
    description?: true
    status?: true
    dueAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    title?: true
    description?: true
    status?: true
    dueAt?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _avg?: TaskAvgAggregateInputType
    _sum?: TaskSumAggregateInputType
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: number
    organizationId: number
    userId: number | null
    title: string
    description: string | null
    status: string
    dueAt: Date | null
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean
    _count: TaskCountAggregateOutputType | null
    _avg: TaskAvgAggregateOutputType | null
    _sum: TaskSumAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Task$userArgs<ExtArgs>
    runs?: boolean | Task$runsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Task$userArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Task$userArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    dueAt?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "title" | "description" | "status" | "dueAt" | "metadata" | "createdAt" | "updatedAt" | "syncId" | "lastSynced" | "needsSync", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Task$userArgs<ExtArgs>
    runs?: boolean | Task$runsArgs<ExtArgs>
    _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Task$userArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | Task$userArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      runs: Prisma.$TaskRunPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organizationId: number
      userId: number | null
      title: string
      description: string | null
      status: string
      dueAt: Date | null
      metadata: string | null
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
      needsSync: boolean
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends Task$userArgs<ExtArgs> = {}>(args?: Subset<T, Task$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    runs<T extends Task$runsArgs<ExtArgs> = {}>(args?: Subset<T, Task$runsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'Int'>
    readonly organizationId: FieldRef<"Task", 'Int'>
    readonly userId: FieldRef<"Task", 'Int'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'String'>
    readonly dueAt: FieldRef<"Task", 'DateTime'>
    readonly metadata: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
    readonly syncId: FieldRef<"Task", 'String'>
    readonly lastSynced: FieldRef<"Task", 'DateTime'>
    readonly needsSync: FieldRef<"Task", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.user
   */
  export type Task$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Task.runs
   */
  export type Task$runsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
    where?: TaskRunWhereInput
    orderBy?: TaskRunOrderByWithRelationInput | TaskRunOrderByWithRelationInput[]
    cursor?: TaskRunWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskRunScalarFieldEnum | TaskRunScalarFieldEnum[]
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model TaskRun
   */

  export type AggregateTaskRun = {
    _count: TaskRunCountAggregateOutputType | null
    _avg: TaskRunAvgAggregateOutputType | null
    _sum: TaskRunSumAggregateOutputType | null
    _min: TaskRunMinAggregateOutputType | null
    _max: TaskRunMaxAggregateOutputType | null
  }

  export type TaskRunAvgAggregateOutputType = {
    id: number | null
    taskId: number | null
  }

  export type TaskRunSumAggregateOutputType = {
    id: number | null
    taskId: number | null
  }

  export type TaskRunMinAggregateOutputType = {
    id: number | null
    taskId: number | null
    runType: string | null
    result: string | null
    message: string | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type TaskRunMaxAggregateOutputType = {
    id: number | null
    taskId: number | null
    runType: string | null
    result: string | null
    message: string | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type TaskRunCountAggregateOutputType = {
    id: number
    taskId: number
    runType: number
    result: number
    message: number
    createdAt: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type TaskRunAvgAggregateInputType = {
    id?: true
    taskId?: true
  }

  export type TaskRunSumAggregateInputType = {
    id?: true
    taskId?: true
  }

  export type TaskRunMinAggregateInputType = {
    id?: true
    taskId?: true
    runType?: true
    result?: true
    message?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type TaskRunMaxAggregateInputType = {
    id?: true
    taskId?: true
    runType?: true
    result?: true
    message?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type TaskRunCountAggregateInputType = {
    id?: true
    taskId?: true
    runType?: true
    result?: true
    message?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type TaskRunAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskRun to aggregate.
     */
    where?: TaskRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskRuns to fetch.
     */
    orderBy?: TaskRunOrderByWithRelationInput | TaskRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaskRuns
    **/
    _count?: true | TaskRunCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaskRunAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaskRunSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskRunMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskRunMaxAggregateInputType
  }

  export type GetTaskRunAggregateType<T extends TaskRunAggregateArgs> = {
        [P in keyof T & keyof AggregateTaskRun]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaskRun[P]>
      : GetScalarType<T[P], AggregateTaskRun[P]>
  }




  export type TaskRunGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskRunWhereInput
    orderBy?: TaskRunOrderByWithAggregationInput | TaskRunOrderByWithAggregationInput[]
    by: TaskRunScalarFieldEnum[] | TaskRunScalarFieldEnum
    having?: TaskRunScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskRunCountAggregateInputType | true
    _avg?: TaskRunAvgAggregateInputType
    _sum?: TaskRunSumAggregateInputType
    _min?: TaskRunMinAggregateInputType
    _max?: TaskRunMaxAggregateInputType
  }

  export type TaskRunGroupByOutputType = {
    id: number
    taskId: number
    runType: string
    result: string
    message: string | null
    createdAt: Date
    syncId: string | null
    needsSync: boolean
    _count: TaskRunCountAggregateOutputType | null
    _avg: TaskRunAvgAggregateOutputType | null
    _sum: TaskRunSumAggregateOutputType | null
    _min: TaskRunMinAggregateOutputType | null
    _max: TaskRunMaxAggregateOutputType | null
  }

  type GetTaskRunGroupByPayload<T extends TaskRunGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskRunGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskRunGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskRunGroupByOutputType[P]>
            : GetScalarType<T[P], TaskRunGroupByOutputType[P]>
        }
      >
    >


  export type TaskRunSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    runType?: boolean
    result?: boolean
    message?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskRun"]>

  export type TaskRunSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    runType?: boolean
    result?: boolean
    message?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskRun"]>

  export type TaskRunSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskId?: boolean
    runType?: boolean
    result?: boolean
    message?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taskRun"]>

  export type TaskRunSelectScalar = {
    id?: boolean
    taskId?: boolean
    runType?: boolean
    result?: boolean
    message?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type TaskRunOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskId" | "runType" | "result" | "message" | "createdAt" | "syncId" | "needsSync", ExtArgs["result"]["taskRun"]>
  export type TaskRunInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskRunIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }
  export type TaskRunIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    task?: boolean | TaskDefaultArgs<ExtArgs>
  }

  export type $TaskRunPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaskRun"
    objects: {
      task: Prisma.$TaskPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      taskId: number
      runType: string
      result: string
      message: string | null
      createdAt: Date
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["taskRun"]>
    composites: {}
  }

  type TaskRunGetPayload<S extends boolean | null | undefined | TaskRunDefaultArgs> = $Result.GetResult<Prisma.$TaskRunPayload, S>

  type TaskRunCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskRunFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskRunCountAggregateInputType | true
    }

  export interface TaskRunDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaskRun'], meta: { name: 'TaskRun' } }
    /**
     * Find zero or one TaskRun that matches the filter.
     * @param {TaskRunFindUniqueArgs} args - Arguments to find a TaskRun
     * @example
     * // Get one TaskRun
     * const taskRun = await prisma.taskRun.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskRunFindUniqueArgs>(args: SelectSubset<T, TaskRunFindUniqueArgs<ExtArgs>>): Prisma__TaskRunClient<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaskRun that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskRunFindUniqueOrThrowArgs} args - Arguments to find a TaskRun
     * @example
     * // Get one TaskRun
     * const taskRun = await prisma.taskRun.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskRunFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskRunFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskRunClient<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskRun that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskRunFindFirstArgs} args - Arguments to find a TaskRun
     * @example
     * // Get one TaskRun
     * const taskRun = await prisma.taskRun.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskRunFindFirstArgs>(args?: SelectSubset<T, TaskRunFindFirstArgs<ExtArgs>>): Prisma__TaskRunClient<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaskRun that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskRunFindFirstOrThrowArgs} args - Arguments to find a TaskRun
     * @example
     * // Get one TaskRun
     * const taskRun = await prisma.taskRun.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskRunFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskRunFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskRunClient<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaskRuns that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskRunFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaskRuns
     * const taskRuns = await prisma.taskRun.findMany()
     * 
     * // Get first 10 TaskRuns
     * const taskRuns = await prisma.taskRun.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskRunWithIdOnly = await prisma.taskRun.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskRunFindManyArgs>(args?: SelectSubset<T, TaskRunFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaskRun.
     * @param {TaskRunCreateArgs} args - Arguments to create a TaskRun.
     * @example
     * // Create one TaskRun
     * const TaskRun = await prisma.taskRun.create({
     *   data: {
     *     // ... data to create a TaskRun
     *   }
     * })
     * 
     */
    create<T extends TaskRunCreateArgs>(args: SelectSubset<T, TaskRunCreateArgs<ExtArgs>>): Prisma__TaskRunClient<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaskRuns.
     * @param {TaskRunCreateManyArgs} args - Arguments to create many TaskRuns.
     * @example
     * // Create many TaskRuns
     * const taskRun = await prisma.taskRun.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskRunCreateManyArgs>(args?: SelectSubset<T, TaskRunCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaskRuns and returns the data saved in the database.
     * @param {TaskRunCreateManyAndReturnArgs} args - Arguments to create many TaskRuns.
     * @example
     * // Create many TaskRuns
     * const taskRun = await prisma.taskRun.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaskRuns and only return the `id`
     * const taskRunWithIdOnly = await prisma.taskRun.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskRunCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskRunCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaskRun.
     * @param {TaskRunDeleteArgs} args - Arguments to delete one TaskRun.
     * @example
     * // Delete one TaskRun
     * const TaskRun = await prisma.taskRun.delete({
     *   where: {
     *     // ... filter to delete one TaskRun
     *   }
     * })
     * 
     */
    delete<T extends TaskRunDeleteArgs>(args: SelectSubset<T, TaskRunDeleteArgs<ExtArgs>>): Prisma__TaskRunClient<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaskRun.
     * @param {TaskRunUpdateArgs} args - Arguments to update one TaskRun.
     * @example
     * // Update one TaskRun
     * const taskRun = await prisma.taskRun.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskRunUpdateArgs>(args: SelectSubset<T, TaskRunUpdateArgs<ExtArgs>>): Prisma__TaskRunClient<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaskRuns.
     * @param {TaskRunDeleteManyArgs} args - Arguments to filter TaskRuns to delete.
     * @example
     * // Delete a few TaskRuns
     * const { count } = await prisma.taskRun.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskRunDeleteManyArgs>(args?: SelectSubset<T, TaskRunDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskRunUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaskRuns
     * const taskRun = await prisma.taskRun.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskRunUpdateManyArgs>(args: SelectSubset<T, TaskRunUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaskRuns and returns the data updated in the database.
     * @param {TaskRunUpdateManyAndReturnArgs} args - Arguments to update many TaskRuns.
     * @example
     * // Update many TaskRuns
     * const taskRun = await prisma.taskRun.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaskRuns and only return the `id`
     * const taskRunWithIdOnly = await prisma.taskRun.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskRunUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskRunUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaskRun.
     * @param {TaskRunUpsertArgs} args - Arguments to update or create a TaskRun.
     * @example
     * // Update or create a TaskRun
     * const taskRun = await prisma.taskRun.upsert({
     *   create: {
     *     // ... data to create a TaskRun
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaskRun we want to update
     *   }
     * })
     */
    upsert<T extends TaskRunUpsertArgs>(args: SelectSubset<T, TaskRunUpsertArgs<ExtArgs>>): Prisma__TaskRunClient<$Result.GetResult<Prisma.$TaskRunPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaskRuns.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskRunCountArgs} args - Arguments to filter TaskRuns to count.
     * @example
     * // Count the number of TaskRuns
     * const count = await prisma.taskRun.count({
     *   where: {
     *     // ... the filter for the TaskRuns we want to count
     *   }
     * })
    **/
    count<T extends TaskRunCountArgs>(
      args?: Subset<T, TaskRunCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskRunCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaskRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskRunAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskRunAggregateArgs>(args: Subset<T, TaskRunAggregateArgs>): Prisma.PrismaPromise<GetTaskRunAggregateType<T>>

    /**
     * Group by TaskRun.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskRunGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskRunGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskRunGroupByArgs['orderBy'] }
        : { orderBy?: TaskRunGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskRunGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskRunGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaskRun model
   */
  readonly fields: TaskRunFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaskRun.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskRunClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    task<T extends TaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TaskDefaultArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaskRun model
   */
  interface TaskRunFieldRefs {
    readonly id: FieldRef<"TaskRun", 'Int'>
    readonly taskId: FieldRef<"TaskRun", 'Int'>
    readonly runType: FieldRef<"TaskRun", 'String'>
    readonly result: FieldRef<"TaskRun", 'String'>
    readonly message: FieldRef<"TaskRun", 'String'>
    readonly createdAt: FieldRef<"TaskRun", 'DateTime'>
    readonly syncId: FieldRef<"TaskRun", 'String'>
    readonly needsSync: FieldRef<"TaskRun", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TaskRun findUnique
   */
  export type TaskRunFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
    /**
     * Filter, which TaskRun to fetch.
     */
    where: TaskRunWhereUniqueInput
  }

  /**
   * TaskRun findUniqueOrThrow
   */
  export type TaskRunFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
    /**
     * Filter, which TaskRun to fetch.
     */
    where: TaskRunWhereUniqueInput
  }

  /**
   * TaskRun findFirst
   */
  export type TaskRunFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
    /**
     * Filter, which TaskRun to fetch.
     */
    where?: TaskRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskRuns to fetch.
     */
    orderBy?: TaskRunOrderByWithRelationInput | TaskRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskRuns.
     */
    cursor?: TaskRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskRuns.
     */
    distinct?: TaskRunScalarFieldEnum | TaskRunScalarFieldEnum[]
  }

  /**
   * TaskRun findFirstOrThrow
   */
  export type TaskRunFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
    /**
     * Filter, which TaskRun to fetch.
     */
    where?: TaskRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskRuns to fetch.
     */
    orderBy?: TaskRunOrderByWithRelationInput | TaskRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaskRuns.
     */
    cursor?: TaskRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskRuns.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaskRuns.
     */
    distinct?: TaskRunScalarFieldEnum | TaskRunScalarFieldEnum[]
  }

  /**
   * TaskRun findMany
   */
  export type TaskRunFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
    /**
     * Filter, which TaskRuns to fetch.
     */
    where?: TaskRunWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaskRuns to fetch.
     */
    orderBy?: TaskRunOrderByWithRelationInput | TaskRunOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaskRuns.
     */
    cursor?: TaskRunWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaskRuns from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaskRuns.
     */
    skip?: number
    distinct?: TaskRunScalarFieldEnum | TaskRunScalarFieldEnum[]
  }

  /**
   * TaskRun create
   */
  export type TaskRunCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
    /**
     * The data needed to create a TaskRun.
     */
    data: XOR<TaskRunCreateInput, TaskRunUncheckedCreateInput>
  }

  /**
   * TaskRun createMany
   */
  export type TaskRunCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaskRuns.
     */
    data: TaskRunCreateManyInput | TaskRunCreateManyInput[]
  }

  /**
   * TaskRun createManyAndReturn
   */
  export type TaskRunCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * The data used to create many TaskRuns.
     */
    data: TaskRunCreateManyInput | TaskRunCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskRun update
   */
  export type TaskRunUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
    /**
     * The data needed to update a TaskRun.
     */
    data: XOR<TaskRunUpdateInput, TaskRunUncheckedUpdateInput>
    /**
     * Choose, which TaskRun to update.
     */
    where: TaskRunWhereUniqueInput
  }

  /**
   * TaskRun updateMany
   */
  export type TaskRunUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaskRuns.
     */
    data: XOR<TaskRunUpdateManyMutationInput, TaskRunUncheckedUpdateManyInput>
    /**
     * Filter which TaskRuns to update
     */
    where?: TaskRunWhereInput
    /**
     * Limit how many TaskRuns to update.
     */
    limit?: number
  }

  /**
   * TaskRun updateManyAndReturn
   */
  export type TaskRunUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * The data used to update TaskRuns.
     */
    data: XOR<TaskRunUpdateManyMutationInput, TaskRunUncheckedUpdateManyInput>
    /**
     * Filter which TaskRuns to update
     */
    where?: TaskRunWhereInput
    /**
     * Limit how many TaskRuns to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaskRun upsert
   */
  export type TaskRunUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
    /**
     * The filter to search for the TaskRun to update in case it exists.
     */
    where: TaskRunWhereUniqueInput
    /**
     * In case the TaskRun found by the `where` argument doesn't exist, create a new TaskRun with this data.
     */
    create: XOR<TaskRunCreateInput, TaskRunUncheckedCreateInput>
    /**
     * In case the TaskRun was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskRunUpdateInput, TaskRunUncheckedUpdateInput>
  }

  /**
   * TaskRun delete
   */
  export type TaskRunDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
    /**
     * Filter which TaskRun to delete.
     */
    where: TaskRunWhereUniqueInput
  }

  /**
   * TaskRun deleteMany
   */
  export type TaskRunDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaskRuns to delete
     */
    where?: TaskRunWhereInput
    /**
     * Limit how many TaskRuns to delete.
     */
    limit?: number
  }

  /**
   * TaskRun without action
   */
  export type TaskRunDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaskRun
     */
    select?: TaskRunSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaskRun
     */
    omit?: TaskRunOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskRunInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
    subjectId: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
    subjectId: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
    subjectType: string | null
    subjectId: number | null
    action: string | null
    detail: string | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
    subjectType: string | null
    subjectId: number | null
    action: string | null
    detail: string | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    subjectType: number
    subjectId: number
    action: number
    detail: number
    createdAt: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    subjectId?: true
  }

  export type ActivityLogSumAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    subjectId?: true
  }

  export type ActivityLogMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    subjectType?: true
    subjectId?: true
    action?: true
    detail?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    subjectType?: true
    subjectId?: true
    action?: true
    detail?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    subjectType?: true
    subjectId?: true
    action?: true
    detail?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: number
    organizationId: number
    userId: number | null
    subjectType: string
    subjectId: number | null
    action: string
    detail: string | null
    createdAt: Date
    syncId: string | null
    needsSync: boolean
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    subjectType?: boolean
    subjectId?: boolean
    action?: boolean
    detail?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    subjectType?: boolean
    subjectId?: boolean
    action?: boolean
    detail?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    subjectType?: boolean
    subjectId?: boolean
    action?: boolean
    detail?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    subjectType?: boolean
    subjectId?: boolean
    action?: boolean
    detail?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "subjectType" | "subjectId" | "action" | "detail" | "createdAt" | "syncId" | "needsSync", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }
  export type ActivityLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | ActivityLog$userArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organizationId: number
      userId: number | null
      subjectType: string
      subjectId: number | null
      action: string
      detail: string | null
      createdAt: Date
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs and returns the data updated in the database.
     * @param {ActivityLogUpdateManyAndReturnArgs} args - Arguments to update many ActivityLogs.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ActivityLogUpdateManyAndReturnArgs>(args: SelectSubset<T, ActivityLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends ActivityLog$userArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'Int'>
    readonly organizationId: FieldRef<"ActivityLog", 'Int'>
    readonly userId: FieldRef<"ActivityLog", 'Int'>
    readonly subjectType: FieldRef<"ActivityLog", 'String'>
    readonly subjectId: FieldRef<"ActivityLog", 'Int'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly detail: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
    readonly syncId: FieldRef<"ActivityLog", 'String'>
    readonly needsSync: FieldRef<"ActivityLog", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog updateManyAndReturn
   */
  export type ActivityLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog.user
   */
  export type ActivityLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model Requisition
   */

  export type AggregateRequisition = {
    _count: RequisitionCountAggregateOutputType | null
    _avg: RequisitionAvgAggregateOutputType | null
    _sum: RequisitionSumAggregateOutputType | null
    _min: RequisitionMinAggregateOutputType | null
    _max: RequisitionMaxAggregateOutputType | null
  }

  export type RequisitionAvgAggregateOutputType = {
    budget: number | null
    requesterId: number | null
    organizationId: number | null
  }

  export type RequisitionSumAggregateOutputType = {
    budget: number | null
    requesterId: number | null
    organizationId: number | null
  }

  export type RequisitionMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    priority: string | null
    budget: number | null
    justification: string | null
    status: string | null
    requesterId: number | null
    organizationId: number | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type RequisitionMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    priority: string | null
    budget: number | null
    justification: string | null
    status: string | null
    requesterId: number | null
    organizationId: number | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type RequisitionCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    priority: number
    budget: number
    justification: number
    status: number
    requesterId: number
    organizationId: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    needsSync: number
    _all: number
  }


  export type RequisitionAvgAggregateInputType = {
    budget?: true
    requesterId?: true
    organizationId?: true
  }

  export type RequisitionSumAggregateInputType = {
    budget?: true
    requesterId?: true
    organizationId?: true
  }

  export type RequisitionMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    budget?: true
    justification?: true
    status?: true
    requesterId?: true
    organizationId?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type RequisitionMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    budget?: true
    justification?: true
    status?: true
    requesterId?: true
    organizationId?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type RequisitionCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    budget?: true
    justification?: true
    status?: true
    requesterId?: true
    organizationId?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
    _all?: true
  }

  export type RequisitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requisition to aggregate.
     */
    where?: RequisitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requisitions to fetch.
     */
    orderBy?: RequisitionOrderByWithRelationInput | RequisitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RequisitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requisitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requisitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Requisitions
    **/
    _count?: true | RequisitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RequisitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RequisitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RequisitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RequisitionMaxAggregateInputType
  }

  export type GetRequisitionAggregateType<T extends RequisitionAggregateArgs> = {
        [P in keyof T & keyof AggregateRequisition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRequisition[P]>
      : GetScalarType<T[P], AggregateRequisition[P]>
  }




  export type RequisitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RequisitionWhereInput
    orderBy?: RequisitionOrderByWithAggregationInput | RequisitionOrderByWithAggregationInput[]
    by: RequisitionScalarFieldEnum[] | RequisitionScalarFieldEnum
    having?: RequisitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RequisitionCountAggregateInputType | true
    _avg?: RequisitionAvgAggregateInputType
    _sum?: RequisitionSumAggregateInputType
    _min?: RequisitionMinAggregateInputType
    _max?: RequisitionMaxAggregateInputType
  }

  export type RequisitionGroupByOutputType = {
    id: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status: string
    requesterId: number | null
    organizationId: number
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean
    _count: RequisitionCountAggregateOutputType | null
    _avg: RequisitionAvgAggregateOutputType | null
    _sum: RequisitionSumAggregateOutputType | null
    _min: RequisitionMinAggregateOutputType | null
    _max: RequisitionMaxAggregateOutputType | null
  }

  type GetRequisitionGroupByPayload<T extends RequisitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RequisitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RequisitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RequisitionGroupByOutputType[P]>
            : GetScalarType<T[P], RequisitionGroupByOutputType[P]>
        }
      >
    >


  export type RequisitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    budget?: boolean
    justification?: boolean
    status?: boolean
    requesterId?: boolean
    organizationId?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    requester?: boolean | Requisition$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    workflow?: boolean | Requisition$workflowArgs<ExtArgs>
    _count?: boolean | RequisitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisition"]>

  export type RequisitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    budget?: boolean
    justification?: boolean
    status?: boolean
    requesterId?: boolean
    organizationId?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    requester?: boolean | Requisition$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisition"]>

  export type RequisitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    budget?: boolean
    justification?: boolean
    status?: boolean
    requesterId?: boolean
    organizationId?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    requester?: boolean | Requisition$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["requisition"]>

  export type RequisitionSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    budget?: boolean
    justification?: boolean
    status?: boolean
    requesterId?: boolean
    organizationId?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }

  export type RequisitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "priority" | "budget" | "justification" | "status" | "requesterId" | "organizationId" | "approvedAt" | "createdAt" | "updatedAt" | "syncId" | "lastSynced" | "needsSync", ExtArgs["result"]["requisition"]>
  export type RequisitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | Requisition$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    workflow?: boolean | Requisition$workflowArgs<ExtArgs>
    _count?: boolean | RequisitionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RequisitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | Requisition$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type RequisitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | Requisition$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $RequisitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Requisition"
    objects: {
      requester: Prisma.$UserPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs>
      workflow: Prisma.$WorkflowStepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      category: string
      priority: string
      budget: number
      justification: string
      status: string
      requesterId: number | null
      organizationId: number
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
      needsSync: boolean
    }, ExtArgs["result"]["requisition"]>
    composites: {}
  }

  type RequisitionGetPayload<S extends boolean | null | undefined | RequisitionDefaultArgs> = $Result.GetResult<Prisma.$RequisitionPayload, S>

  type RequisitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RequisitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RequisitionCountAggregateInputType | true
    }

  export interface RequisitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Requisition'], meta: { name: 'Requisition' } }
    /**
     * Find zero or one Requisition that matches the filter.
     * @param {RequisitionFindUniqueArgs} args - Arguments to find a Requisition
     * @example
     * // Get one Requisition
     * const requisition = await prisma.requisition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RequisitionFindUniqueArgs>(args: SelectSubset<T, RequisitionFindUniqueArgs<ExtArgs>>): Prisma__RequisitionClient<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Requisition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RequisitionFindUniqueOrThrowArgs} args - Arguments to find a Requisition
     * @example
     * // Get one Requisition
     * const requisition = await prisma.requisition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RequisitionFindUniqueOrThrowArgs>(args: SelectSubset<T, RequisitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RequisitionClient<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requisition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitionFindFirstArgs} args - Arguments to find a Requisition
     * @example
     * // Get one Requisition
     * const requisition = await prisma.requisition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RequisitionFindFirstArgs>(args?: SelectSubset<T, RequisitionFindFirstArgs<ExtArgs>>): Prisma__RequisitionClient<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Requisition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitionFindFirstOrThrowArgs} args - Arguments to find a Requisition
     * @example
     * // Get one Requisition
     * const requisition = await prisma.requisition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RequisitionFindFirstOrThrowArgs>(args?: SelectSubset<T, RequisitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__RequisitionClient<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Requisitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Requisitions
     * const requisitions = await prisma.requisition.findMany()
     * 
     * // Get first 10 Requisitions
     * const requisitions = await prisma.requisition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const requisitionWithIdOnly = await prisma.requisition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RequisitionFindManyArgs>(args?: SelectSubset<T, RequisitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Requisition.
     * @param {RequisitionCreateArgs} args - Arguments to create a Requisition.
     * @example
     * // Create one Requisition
     * const Requisition = await prisma.requisition.create({
     *   data: {
     *     // ... data to create a Requisition
     *   }
     * })
     * 
     */
    create<T extends RequisitionCreateArgs>(args: SelectSubset<T, RequisitionCreateArgs<ExtArgs>>): Prisma__RequisitionClient<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Requisitions.
     * @param {RequisitionCreateManyArgs} args - Arguments to create many Requisitions.
     * @example
     * // Create many Requisitions
     * const requisition = await prisma.requisition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RequisitionCreateManyArgs>(args?: SelectSubset<T, RequisitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Requisitions and returns the data saved in the database.
     * @param {RequisitionCreateManyAndReturnArgs} args - Arguments to create many Requisitions.
     * @example
     * // Create many Requisitions
     * const requisition = await prisma.requisition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Requisitions and only return the `id`
     * const requisitionWithIdOnly = await prisma.requisition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RequisitionCreateManyAndReturnArgs>(args?: SelectSubset<T, RequisitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Requisition.
     * @param {RequisitionDeleteArgs} args - Arguments to delete one Requisition.
     * @example
     * // Delete one Requisition
     * const Requisition = await prisma.requisition.delete({
     *   where: {
     *     // ... filter to delete one Requisition
     *   }
     * })
     * 
     */
    delete<T extends RequisitionDeleteArgs>(args: SelectSubset<T, RequisitionDeleteArgs<ExtArgs>>): Prisma__RequisitionClient<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Requisition.
     * @param {RequisitionUpdateArgs} args - Arguments to update one Requisition.
     * @example
     * // Update one Requisition
     * const requisition = await prisma.requisition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RequisitionUpdateArgs>(args: SelectSubset<T, RequisitionUpdateArgs<ExtArgs>>): Prisma__RequisitionClient<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Requisitions.
     * @param {RequisitionDeleteManyArgs} args - Arguments to filter Requisitions to delete.
     * @example
     * // Delete a few Requisitions
     * const { count } = await prisma.requisition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RequisitionDeleteManyArgs>(args?: SelectSubset<T, RequisitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requisitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Requisitions
     * const requisition = await prisma.requisition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RequisitionUpdateManyArgs>(args: SelectSubset<T, RequisitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Requisitions and returns the data updated in the database.
     * @param {RequisitionUpdateManyAndReturnArgs} args - Arguments to update many Requisitions.
     * @example
     * // Update many Requisitions
     * const requisition = await prisma.requisition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Requisitions and only return the `id`
     * const requisitionWithIdOnly = await prisma.requisition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RequisitionUpdateManyAndReturnArgs>(args: SelectSubset<T, RequisitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Requisition.
     * @param {RequisitionUpsertArgs} args - Arguments to update or create a Requisition.
     * @example
     * // Update or create a Requisition
     * const requisition = await prisma.requisition.upsert({
     *   create: {
     *     // ... data to create a Requisition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Requisition we want to update
     *   }
     * })
     */
    upsert<T extends RequisitionUpsertArgs>(args: SelectSubset<T, RequisitionUpsertArgs<ExtArgs>>): Prisma__RequisitionClient<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Requisitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitionCountArgs} args - Arguments to filter Requisitions to count.
     * @example
     * // Count the number of Requisitions
     * const count = await prisma.requisition.count({
     *   where: {
     *     // ... the filter for the Requisitions we want to count
     *   }
     * })
    **/
    count<T extends RequisitionCountArgs>(
      args?: Subset<T, RequisitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RequisitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Requisition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RequisitionAggregateArgs>(args: Subset<T, RequisitionAggregateArgs>): Prisma.PrismaPromise<GetRequisitionAggregateType<T>>

    /**
     * Group by Requisition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RequisitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RequisitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RequisitionGroupByArgs['orderBy'] }
        : { orderBy?: RequisitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RequisitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRequisitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Requisition model
   */
  readonly fields: RequisitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Requisition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RequisitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requester<T extends Requisition$requesterArgs<ExtArgs> = {}>(args?: Subset<T, Requisition$requesterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workflow<T extends Requisition$workflowArgs<ExtArgs> = {}>(args?: Subset<T, Requisition$workflowArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Requisition model
   */
  interface RequisitionFieldRefs {
    readonly id: FieldRef<"Requisition", 'String'>
    readonly title: FieldRef<"Requisition", 'String'>
    readonly description: FieldRef<"Requisition", 'String'>
    readonly category: FieldRef<"Requisition", 'String'>
    readonly priority: FieldRef<"Requisition", 'String'>
    readonly budget: FieldRef<"Requisition", 'Float'>
    readonly justification: FieldRef<"Requisition", 'String'>
    readonly status: FieldRef<"Requisition", 'String'>
    readonly requesterId: FieldRef<"Requisition", 'Int'>
    readonly organizationId: FieldRef<"Requisition", 'Int'>
    readonly approvedAt: FieldRef<"Requisition", 'DateTime'>
    readonly createdAt: FieldRef<"Requisition", 'DateTime'>
    readonly updatedAt: FieldRef<"Requisition", 'DateTime'>
    readonly syncId: FieldRef<"Requisition", 'String'>
    readonly lastSynced: FieldRef<"Requisition", 'DateTime'>
    readonly needsSync: FieldRef<"Requisition", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Requisition findUnique
   */
  export type RequisitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    /**
     * Filter, which Requisition to fetch.
     */
    where: RequisitionWhereUniqueInput
  }

  /**
   * Requisition findUniqueOrThrow
   */
  export type RequisitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    /**
     * Filter, which Requisition to fetch.
     */
    where: RequisitionWhereUniqueInput
  }

  /**
   * Requisition findFirst
   */
  export type RequisitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    /**
     * Filter, which Requisition to fetch.
     */
    where?: RequisitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requisitions to fetch.
     */
    orderBy?: RequisitionOrderByWithRelationInput | RequisitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requisitions.
     */
    cursor?: RequisitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requisitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requisitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requisitions.
     */
    distinct?: RequisitionScalarFieldEnum | RequisitionScalarFieldEnum[]
  }

  /**
   * Requisition findFirstOrThrow
   */
  export type RequisitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    /**
     * Filter, which Requisition to fetch.
     */
    where?: RequisitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requisitions to fetch.
     */
    orderBy?: RequisitionOrderByWithRelationInput | RequisitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Requisitions.
     */
    cursor?: RequisitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requisitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requisitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Requisitions.
     */
    distinct?: RequisitionScalarFieldEnum | RequisitionScalarFieldEnum[]
  }

  /**
   * Requisition findMany
   */
  export type RequisitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    /**
     * Filter, which Requisitions to fetch.
     */
    where?: RequisitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Requisitions to fetch.
     */
    orderBy?: RequisitionOrderByWithRelationInput | RequisitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Requisitions.
     */
    cursor?: RequisitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Requisitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Requisitions.
     */
    skip?: number
    distinct?: RequisitionScalarFieldEnum | RequisitionScalarFieldEnum[]
  }

  /**
   * Requisition create
   */
  export type RequisitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    /**
     * The data needed to create a Requisition.
     */
    data: XOR<RequisitionCreateInput, RequisitionUncheckedCreateInput>
  }

  /**
   * Requisition createMany
   */
  export type RequisitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Requisitions.
     */
    data: RequisitionCreateManyInput | RequisitionCreateManyInput[]
  }

  /**
   * Requisition createManyAndReturn
   */
  export type RequisitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * The data used to create many Requisitions.
     */
    data: RequisitionCreateManyInput | RequisitionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requisition update
   */
  export type RequisitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    /**
     * The data needed to update a Requisition.
     */
    data: XOR<RequisitionUpdateInput, RequisitionUncheckedUpdateInput>
    /**
     * Choose, which Requisition to update.
     */
    where: RequisitionWhereUniqueInput
  }

  /**
   * Requisition updateMany
   */
  export type RequisitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Requisitions.
     */
    data: XOR<RequisitionUpdateManyMutationInput, RequisitionUncheckedUpdateManyInput>
    /**
     * Filter which Requisitions to update
     */
    where?: RequisitionWhereInput
    /**
     * Limit how many Requisitions to update.
     */
    limit?: number
  }

  /**
   * Requisition updateManyAndReturn
   */
  export type RequisitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * The data used to update Requisitions.
     */
    data: XOR<RequisitionUpdateManyMutationInput, RequisitionUncheckedUpdateManyInput>
    /**
     * Filter which Requisitions to update
     */
    where?: RequisitionWhereInput
    /**
     * Limit how many Requisitions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Requisition upsert
   */
  export type RequisitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    /**
     * The filter to search for the Requisition to update in case it exists.
     */
    where: RequisitionWhereUniqueInput
    /**
     * In case the Requisition found by the `where` argument doesn't exist, create a new Requisition with this data.
     */
    create: XOR<RequisitionCreateInput, RequisitionUncheckedCreateInput>
    /**
     * In case the Requisition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RequisitionUpdateInput, RequisitionUncheckedUpdateInput>
  }

  /**
   * Requisition delete
   */
  export type RequisitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
    /**
     * Filter which Requisition to delete.
     */
    where: RequisitionWhereUniqueInput
  }

  /**
   * Requisition deleteMany
   */
  export type RequisitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Requisitions to delete
     */
    where?: RequisitionWhereInput
    /**
     * Limit how many Requisitions to delete.
     */
    limit?: number
  }

  /**
   * Requisition.requester
   */
  export type Requisition$requesterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Requisition.workflow
   */
  export type Requisition$workflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    where?: WorkflowStepWhereInput
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    cursor?: WorkflowStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * Requisition without action
   */
  export type RequisitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Requisition
     */
    select?: RequisitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Requisition
     */
    omit?: RequisitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RequisitionInclude<ExtArgs> | null
  }


  /**
   * Model WorkflowStep
   */

  export type AggregateWorkflowStep = {
    _count: WorkflowStepCountAggregateOutputType | null
    _avg: WorkflowStepAvgAggregateOutputType | null
    _sum: WorkflowStepSumAggregateOutputType | null
    _min: WorkflowStepMinAggregateOutputType | null
    _max: WorkflowStepMaxAggregateOutputType | null
  }

  export type WorkflowStepAvgAggregateOutputType = {
    reviewerId: number | null
    reviewerLevel: number | null
  }

  export type WorkflowStepSumAggregateOutputType = {
    reviewerId: number | null
    reviewerLevel: number | null
  }

  export type WorkflowStepMinAggregateOutputType = {
    id: string | null
    requisitionId: string | null
    reviewerId: number | null
    reviewerName: string | null
    reviewerLevel: number | null
    action: string | null
    isRequired: boolean | null
    isCompleted: boolean | null
    comment: string | null
    createdAt: Date | null
    completedAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type WorkflowStepMaxAggregateOutputType = {
    id: string | null
    requisitionId: string | null
    reviewerId: number | null
    reviewerName: string | null
    reviewerLevel: number | null
    action: string | null
    isRequired: boolean | null
    isCompleted: boolean | null
    comment: string | null
    createdAt: Date | null
    completedAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type WorkflowStepCountAggregateOutputType = {
    id: number
    requisitionId: number
    reviewerId: number
    reviewerName: number
    reviewerLevel: number
    action: number
    isRequired: number
    isCompleted: number
    comment: number
    createdAt: number
    completedAt: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type WorkflowStepAvgAggregateInputType = {
    reviewerId?: true
    reviewerLevel?: true
  }

  export type WorkflowStepSumAggregateInputType = {
    reviewerId?: true
    reviewerLevel?: true
  }

  export type WorkflowStepMinAggregateInputType = {
    id?: true
    requisitionId?: true
    reviewerId?: true
    reviewerName?: true
    reviewerLevel?: true
    action?: true
    isRequired?: true
    isCompleted?: true
    comment?: true
    createdAt?: true
    completedAt?: true
    syncId?: true
    needsSync?: true
  }

  export type WorkflowStepMaxAggregateInputType = {
    id?: true
    requisitionId?: true
    reviewerId?: true
    reviewerName?: true
    reviewerLevel?: true
    action?: true
    isRequired?: true
    isCompleted?: true
    comment?: true
    createdAt?: true
    completedAt?: true
    syncId?: true
    needsSync?: true
  }

  export type WorkflowStepCountAggregateInputType = {
    id?: true
    requisitionId?: true
    reviewerId?: true
    reviewerName?: true
    reviewerLevel?: true
    action?: true
    isRequired?: true
    isCompleted?: true
    comment?: true
    createdAt?: true
    completedAt?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type WorkflowStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowStep to aggregate.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkflowSteps
    **/
    _count?: true | WorkflowStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowStepMaxAggregateInputType
  }

  export type GetWorkflowStepAggregateType<T extends WorkflowStepAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflowStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflowStep[P]>
      : GetScalarType<T[P], AggregateWorkflowStep[P]>
  }




  export type WorkflowStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowStepWhereInput
    orderBy?: WorkflowStepOrderByWithAggregationInput | WorkflowStepOrderByWithAggregationInput[]
    by: WorkflowStepScalarFieldEnum[] | WorkflowStepScalarFieldEnum
    having?: WorkflowStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowStepCountAggregateInputType | true
    _avg?: WorkflowStepAvgAggregateInputType
    _sum?: WorkflowStepSumAggregateInputType
    _min?: WorkflowStepMinAggregateInputType
    _max?: WorkflowStepMaxAggregateInputType
  }

  export type WorkflowStepGroupByOutputType = {
    id: string
    requisitionId: string
    reviewerId: number | null
    reviewerName: string
    reviewerLevel: number
    action: string
    isRequired: boolean
    isCompleted: boolean
    comment: string | null
    createdAt: Date
    completedAt: Date | null
    syncId: string | null
    needsSync: boolean
    _count: WorkflowStepCountAggregateOutputType | null
    _avg: WorkflowStepAvgAggregateOutputType | null
    _sum: WorkflowStepSumAggregateOutputType | null
    _min: WorkflowStepMinAggregateOutputType | null
    _max: WorkflowStepMaxAggregateOutputType | null
  }

  type GetWorkflowStepGroupByPayload<T extends WorkflowStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowStepGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowStepGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requisitionId?: boolean
    reviewerId?: boolean
    reviewerName?: boolean
    reviewerLevel?: boolean
    action?: boolean
    isRequired?: boolean
    isCompleted?: boolean
    comment?: boolean
    createdAt?: boolean
    completedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    requisition?: boolean | RequisitionDefaultArgs<ExtArgs>
    reviewer?: boolean | WorkflowStep$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStep"]>

  export type WorkflowStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requisitionId?: boolean
    reviewerId?: boolean
    reviewerName?: boolean
    reviewerLevel?: boolean
    action?: boolean
    isRequired?: boolean
    isCompleted?: boolean
    comment?: boolean
    createdAt?: boolean
    completedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    requisition?: boolean | RequisitionDefaultArgs<ExtArgs>
    reviewer?: boolean | WorkflowStep$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStep"]>

  export type WorkflowStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    requisitionId?: boolean
    reviewerId?: boolean
    reviewerName?: boolean
    reviewerLevel?: boolean
    action?: boolean
    isRequired?: boolean
    isCompleted?: boolean
    comment?: boolean
    createdAt?: boolean
    completedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    requisition?: boolean | RequisitionDefaultArgs<ExtArgs>
    reviewer?: boolean | WorkflowStep$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["workflowStep"]>

  export type WorkflowStepSelectScalar = {
    id?: boolean
    requisitionId?: boolean
    reviewerId?: boolean
    reviewerName?: boolean
    reviewerLevel?: boolean
    action?: boolean
    isRequired?: boolean
    isCompleted?: boolean
    comment?: boolean
    createdAt?: boolean
    completedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type WorkflowStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "requisitionId" | "reviewerId" | "reviewerName" | "reviewerLevel" | "action" | "isRequired" | "isCompleted" | "comment" | "createdAt" | "completedAt" | "syncId" | "needsSync", ExtArgs["result"]["workflowStep"]>
  export type WorkflowStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requisition?: boolean | RequisitionDefaultArgs<ExtArgs>
    reviewer?: boolean | WorkflowStep$reviewerArgs<ExtArgs>
  }
  export type WorkflowStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requisition?: boolean | RequisitionDefaultArgs<ExtArgs>
    reviewer?: boolean | WorkflowStep$reviewerArgs<ExtArgs>
  }
  export type WorkflowStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requisition?: boolean | RequisitionDefaultArgs<ExtArgs>
    reviewer?: boolean | WorkflowStep$reviewerArgs<ExtArgs>
  }

  export type $WorkflowStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkflowStep"
    objects: {
      requisition: Prisma.$RequisitionPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      requisitionId: string
      reviewerId: number | null
      reviewerName: string
      reviewerLevel: number
      action: string
      isRequired: boolean
      isCompleted: boolean
      comment: string | null
      createdAt: Date
      completedAt: Date | null
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["workflowStep"]>
    composites: {}
  }

  type WorkflowStepGetPayload<S extends boolean | null | undefined | WorkflowStepDefaultArgs> = $Result.GetResult<Prisma.$WorkflowStepPayload, S>

  type WorkflowStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkflowStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkflowStepCountAggregateInputType | true
    }

  export interface WorkflowStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkflowStep'], meta: { name: 'WorkflowStep' } }
    /**
     * Find zero or one WorkflowStep that matches the filter.
     * @param {WorkflowStepFindUniqueArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowStepFindUniqueArgs>(args: SelectSubset<T, WorkflowStepFindUniqueArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WorkflowStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowStepFindUniqueOrThrowArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowStepFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkflowStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindFirstArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowStepFindFirstArgs>(args?: SelectSubset<T, WorkflowStepFindFirstArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WorkflowStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindFirstOrThrowArgs} args - Arguments to find a WorkflowStep
     * @example
     * // Get one WorkflowStep
     * const workflowStep = await prisma.workflowStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowStepFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WorkflowSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkflowSteps
     * const workflowSteps = await prisma.workflowStep.findMany()
     * 
     * // Get first 10 WorkflowSteps
     * const workflowSteps = await prisma.workflowStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowStepWithIdOnly = await prisma.workflowStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowStepFindManyArgs>(args?: SelectSubset<T, WorkflowStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WorkflowStep.
     * @param {WorkflowStepCreateArgs} args - Arguments to create a WorkflowStep.
     * @example
     * // Create one WorkflowStep
     * const WorkflowStep = await prisma.workflowStep.create({
     *   data: {
     *     // ... data to create a WorkflowStep
     *   }
     * })
     * 
     */
    create<T extends WorkflowStepCreateArgs>(args: SelectSubset<T, WorkflowStepCreateArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WorkflowSteps.
     * @param {WorkflowStepCreateManyArgs} args - Arguments to create many WorkflowSteps.
     * @example
     * // Create many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowStepCreateManyArgs>(args?: SelectSubset<T, WorkflowStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WorkflowSteps and returns the data saved in the database.
     * @param {WorkflowStepCreateManyAndReturnArgs} args - Arguments to create many WorkflowSteps.
     * @example
     * // Create many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WorkflowSteps and only return the `id`
     * const workflowStepWithIdOnly = await prisma.workflowStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowStepCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WorkflowStep.
     * @param {WorkflowStepDeleteArgs} args - Arguments to delete one WorkflowStep.
     * @example
     * // Delete one WorkflowStep
     * const WorkflowStep = await prisma.workflowStep.delete({
     *   where: {
     *     // ... filter to delete one WorkflowStep
     *   }
     * })
     * 
     */
    delete<T extends WorkflowStepDeleteArgs>(args: SelectSubset<T, WorkflowStepDeleteArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WorkflowStep.
     * @param {WorkflowStepUpdateArgs} args - Arguments to update one WorkflowStep.
     * @example
     * // Update one WorkflowStep
     * const workflowStep = await prisma.workflowStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowStepUpdateArgs>(args: SelectSubset<T, WorkflowStepUpdateArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WorkflowSteps.
     * @param {WorkflowStepDeleteManyArgs} args - Arguments to filter WorkflowSteps to delete.
     * @example
     * // Delete a few WorkflowSteps
     * const { count } = await prisma.workflowStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowStepDeleteManyArgs>(args?: SelectSubset<T, WorkflowStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowStepUpdateManyArgs>(args: SelectSubset<T, WorkflowStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkflowSteps and returns the data updated in the database.
     * @param {WorkflowStepUpdateManyAndReturnArgs} args - Arguments to update many WorkflowSteps.
     * @example
     * // Update many WorkflowSteps
     * const workflowStep = await prisma.workflowStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WorkflowSteps and only return the `id`
     * const workflowStepWithIdOnly = await prisma.workflowStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkflowStepUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkflowStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WorkflowStep.
     * @param {WorkflowStepUpsertArgs} args - Arguments to update or create a WorkflowStep.
     * @example
     * // Update or create a WorkflowStep
     * const workflowStep = await prisma.workflowStep.upsert({
     *   create: {
     *     // ... data to create a WorkflowStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkflowStep we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowStepUpsertArgs>(args: SelectSubset<T, WorkflowStepUpsertArgs<ExtArgs>>): Prisma__WorkflowStepClient<$Result.GetResult<Prisma.$WorkflowStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepCountArgs} args - Arguments to filter WorkflowSteps to count.
     * @example
     * // Count the number of WorkflowSteps
     * const count = await prisma.workflowStep.count({
     *   where: {
     *     // ... the filter for the WorkflowSteps we want to count
     *   }
     * })
    **/
    count<T extends WorkflowStepCountArgs>(
      args?: Subset<T, WorkflowStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowStepAggregateArgs>(args: Subset<T, WorkflowStepAggregateArgs>): Prisma.PrismaPromise<GetWorkflowStepAggregateType<T>>

    /**
     * Group by WorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowStepGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkflowStep model
   */
  readonly fields: WorkflowStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkflowStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requisition<T extends RequisitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RequisitionDefaultArgs<ExtArgs>>): Prisma__RequisitionClient<$Result.GetResult<Prisma.$RequisitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends WorkflowStep$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowStep$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkflowStep model
   */
  interface WorkflowStepFieldRefs {
    readonly id: FieldRef<"WorkflowStep", 'String'>
    readonly requisitionId: FieldRef<"WorkflowStep", 'String'>
    readonly reviewerId: FieldRef<"WorkflowStep", 'Int'>
    readonly reviewerName: FieldRef<"WorkflowStep", 'String'>
    readonly reviewerLevel: FieldRef<"WorkflowStep", 'Int'>
    readonly action: FieldRef<"WorkflowStep", 'String'>
    readonly isRequired: FieldRef<"WorkflowStep", 'Boolean'>
    readonly isCompleted: FieldRef<"WorkflowStep", 'Boolean'>
    readonly comment: FieldRef<"WorkflowStep", 'String'>
    readonly createdAt: FieldRef<"WorkflowStep", 'DateTime'>
    readonly completedAt: FieldRef<"WorkflowStep", 'DateTime'>
    readonly syncId: FieldRef<"WorkflowStep", 'String'>
    readonly needsSync: FieldRef<"WorkflowStep", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * WorkflowStep findUnique
   */
  export type WorkflowStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep findUniqueOrThrow
   */
  export type WorkflowStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep findFirst
   */
  export type WorkflowStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowSteps.
     */
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep findFirstOrThrow
   */
  export type WorkflowStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowStep to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkflowSteps.
     */
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep findMany
   */
  export type WorkflowStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which WorkflowSteps to fetch.
     */
    where?: WorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkflowSteps to fetch.
     */
    orderBy?: WorkflowStepOrderByWithRelationInput | WorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkflowSteps.
     */
    cursor?: WorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkflowSteps.
     */
    skip?: number
    distinct?: WorkflowStepScalarFieldEnum | WorkflowStepScalarFieldEnum[]
  }

  /**
   * WorkflowStep create
   */
  export type WorkflowStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkflowStep.
     */
    data: XOR<WorkflowStepCreateInput, WorkflowStepUncheckedCreateInput>
  }

  /**
   * WorkflowStep createMany
   */
  export type WorkflowStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkflowSteps.
     */
    data: WorkflowStepCreateManyInput | WorkflowStepCreateManyInput[]
  }

  /**
   * WorkflowStep createManyAndReturn
   */
  export type WorkflowStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * The data used to create many WorkflowSteps.
     */
    data: WorkflowStepCreateManyInput | WorkflowStepCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowStep update
   */
  export type WorkflowStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkflowStep.
     */
    data: XOR<WorkflowStepUpdateInput, WorkflowStepUncheckedUpdateInput>
    /**
     * Choose, which WorkflowStep to update.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep updateMany
   */
  export type WorkflowStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkflowSteps.
     */
    data: XOR<WorkflowStepUpdateManyMutationInput, WorkflowStepUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowSteps to update
     */
    where?: WorkflowStepWhereInput
    /**
     * Limit how many WorkflowSteps to update.
     */
    limit?: number
  }

  /**
   * WorkflowStep updateManyAndReturn
   */
  export type WorkflowStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * The data used to update WorkflowSteps.
     */
    data: XOR<WorkflowStepUpdateManyMutationInput, WorkflowStepUncheckedUpdateManyInput>
    /**
     * Filter which WorkflowSteps to update
     */
    where?: WorkflowStepWhereInput
    /**
     * Limit how many WorkflowSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WorkflowStep upsert
   */
  export type WorkflowStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkflowStep to update in case it exists.
     */
    where: WorkflowStepWhereUniqueInput
    /**
     * In case the WorkflowStep found by the `where` argument doesn't exist, create a new WorkflowStep with this data.
     */
    create: XOR<WorkflowStepCreateInput, WorkflowStepUncheckedCreateInput>
    /**
     * In case the WorkflowStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowStepUpdateInput, WorkflowStepUncheckedUpdateInput>
  }

  /**
   * WorkflowStep delete
   */
  export type WorkflowStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
    /**
     * Filter which WorkflowStep to delete.
     */
    where: WorkflowStepWhereUniqueInput
  }

  /**
   * WorkflowStep deleteMany
   */
  export type WorkflowStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkflowSteps to delete
     */
    where?: WorkflowStepWhereInput
    /**
     * Limit how many WorkflowSteps to delete.
     */
    limit?: number
  }

  /**
   * WorkflowStep.reviewer
   */
  export type WorkflowStep$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * WorkflowStep without action
   */
  export type WorkflowStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkflowStep
     */
    select?: WorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WorkflowStep
     */
    omit?: WorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowStepInclude<ExtArgs> | null
  }


  /**
   * Model Meeting
   */

  export type AggregateMeeting = {
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  export type MeetingAvgAggregateOutputType = {
    organizationId: number | null
    creatorId: number | null
  }

  export type MeetingSumAggregateOutputType = {
    organizationId: number | null
    creatorId: number | null
  }

  export type MeetingMinAggregateOutputType = {
    id: string | null
    organizationId: number | null
    creatorId: number | null
    title: string | null
    notes: string | null
    participants: string | null
    status: string | null
    extractedActions: string | null
    tasksCreated: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type MeetingMaxAggregateOutputType = {
    id: string | null
    organizationId: number | null
    creatorId: number | null
    title: string | null
    notes: string | null
    participants: string | null
    status: string | null
    extractedActions: string | null
    tasksCreated: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type MeetingCountAggregateOutputType = {
    id: number
    organizationId: number
    creatorId: number
    title: number
    notes: number
    participants: number
    status: number
    extractedActions: number
    tasksCreated: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    needsSync: number
    _all: number
  }


  export type MeetingAvgAggregateInputType = {
    organizationId?: true
    creatorId?: true
  }

  export type MeetingSumAggregateInputType = {
    organizationId?: true
    creatorId?: true
  }

  export type MeetingMinAggregateInputType = {
    id?: true
    organizationId?: true
    creatorId?: true
    title?: true
    notes?: true
    participants?: true
    status?: true
    extractedActions?: true
    tasksCreated?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type MeetingMaxAggregateInputType = {
    id?: true
    organizationId?: true
    creatorId?: true
    title?: true
    notes?: true
    participants?: true
    status?: true
    extractedActions?: true
    tasksCreated?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type MeetingCountAggregateInputType = {
    id?: true
    organizationId?: true
    creatorId?: true
    title?: true
    notes?: true
    participants?: true
    status?: true
    extractedActions?: true
    tasksCreated?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
    _all?: true
  }

  export type MeetingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meeting to aggregate.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Meetings
    **/
    _count?: true | MeetingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingMaxAggregateInputType
  }

  export type GetMeetingAggregateType<T extends MeetingAggregateArgs> = {
        [P in keyof T & keyof AggregateMeeting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeeting[P]>
      : GetScalarType<T[P], AggregateMeeting[P]>
  }




  export type MeetingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingWhereInput
    orderBy?: MeetingOrderByWithAggregationInput | MeetingOrderByWithAggregationInput[]
    by: MeetingScalarFieldEnum[] | MeetingScalarFieldEnum
    having?: MeetingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingCountAggregateInputType | true
    _avg?: MeetingAvgAggregateInputType
    _sum?: MeetingSumAggregateInputType
    _min?: MeetingMinAggregateInputType
    _max?: MeetingMaxAggregateInputType
  }

  export type MeetingGroupByOutputType = {
    id: string
    organizationId: number
    creatorId: number | null
    title: string
    notes: string
    participants: string | null
    status: string
    extractedActions: string | null
    tasksCreated: string | null
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean
    _count: MeetingCountAggregateOutputType | null
    _avg: MeetingAvgAggregateOutputType | null
    _sum: MeetingSumAggregateOutputType | null
    _min: MeetingMinAggregateOutputType | null
    _max: MeetingMaxAggregateOutputType | null
  }

  type GetMeetingGroupByPayload<T extends MeetingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingGroupByOutputType[P]>
        }
      >
    >


  export type MeetingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    creatorId?: boolean
    title?: boolean
    notes?: boolean
    participants?: boolean
    status?: boolean
    extractedActions?: boolean
    tasksCreated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    creator?: boolean | Meeting$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    creatorId?: boolean
    title?: boolean
    notes?: boolean
    participants?: boolean
    status?: boolean
    extractedActions?: boolean
    tasksCreated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    creator?: boolean | Meeting$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    creatorId?: boolean
    title?: boolean
    notes?: boolean
    participants?: boolean
    status?: boolean
    extractedActions?: boolean
    tasksCreated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    creator?: boolean | Meeting$creatorArgs<ExtArgs>
  }, ExtArgs["result"]["meeting"]>

  export type MeetingSelectScalar = {
    id?: boolean
    organizationId?: boolean
    creatorId?: boolean
    title?: boolean
    notes?: boolean
    participants?: boolean
    status?: boolean
    extractedActions?: boolean
    tasksCreated?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }

  export type MeetingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "creatorId" | "title" | "notes" | "participants" | "status" | "extractedActions" | "tasksCreated" | "createdAt" | "updatedAt" | "syncId" | "lastSynced" | "needsSync", ExtArgs["result"]["meeting"]>
  export type MeetingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    creator?: boolean | Meeting$creatorArgs<ExtArgs>
  }
  export type MeetingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    creator?: boolean | Meeting$creatorArgs<ExtArgs>
  }
  export type MeetingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    creator?: boolean | Meeting$creatorArgs<ExtArgs>
  }

  export type $MeetingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Meeting"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: number
      creatorId: number | null
      title: string
      notes: string
      participants: string | null
      status: string
      extractedActions: string | null
      tasksCreated: string | null
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
      needsSync: boolean
    }, ExtArgs["result"]["meeting"]>
    composites: {}
  }

  type MeetingGetPayload<S extends boolean | null | undefined | MeetingDefaultArgs> = $Result.GetResult<Prisma.$MeetingPayload, S>

  type MeetingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeetingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeetingCountAggregateInputType | true
    }

  export interface MeetingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Meeting'], meta: { name: 'Meeting' } }
    /**
     * Find zero or one Meeting that matches the filter.
     * @param {MeetingFindUniqueArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingFindUniqueArgs>(args: SelectSubset<T, MeetingFindUniqueArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Meeting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingFindUniqueOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingFindFirstArgs>(args?: SelectSubset<T, MeetingFindFirstArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Meeting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindFirstOrThrowArgs} args - Arguments to find a Meeting
     * @example
     * // Get one Meeting
     * const meeting = await prisma.meeting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Meetings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Meetings
     * const meetings = await prisma.meeting.findMany()
     * 
     * // Get first 10 Meetings
     * const meetings = await prisma.meeting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingWithIdOnly = await prisma.meeting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingFindManyArgs>(args?: SelectSubset<T, MeetingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Meeting.
     * @param {MeetingCreateArgs} args - Arguments to create a Meeting.
     * @example
     * // Create one Meeting
     * const Meeting = await prisma.meeting.create({
     *   data: {
     *     // ... data to create a Meeting
     *   }
     * })
     * 
     */
    create<T extends MeetingCreateArgs>(args: SelectSubset<T, MeetingCreateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Meetings.
     * @param {MeetingCreateManyArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingCreateManyArgs>(args?: SelectSubset<T, MeetingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Meetings and returns the data saved in the database.
     * @param {MeetingCreateManyAndReturnArgs} args - Arguments to create many Meetings.
     * @example
     * // Create many Meetings
     * const meeting = await prisma.meeting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Meeting.
     * @param {MeetingDeleteArgs} args - Arguments to delete one Meeting.
     * @example
     * // Delete one Meeting
     * const Meeting = await prisma.meeting.delete({
     *   where: {
     *     // ... filter to delete one Meeting
     *   }
     * })
     * 
     */
    delete<T extends MeetingDeleteArgs>(args: SelectSubset<T, MeetingDeleteArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Meeting.
     * @param {MeetingUpdateArgs} args - Arguments to update one Meeting.
     * @example
     * // Update one Meeting
     * const meeting = await prisma.meeting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingUpdateArgs>(args: SelectSubset<T, MeetingUpdateArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Meetings.
     * @param {MeetingDeleteManyArgs} args - Arguments to filter Meetings to delete.
     * @example
     * // Delete a few Meetings
     * const { count } = await prisma.meeting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingDeleteManyArgs>(args?: SelectSubset<T, MeetingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingUpdateManyArgs>(args: SelectSubset<T, MeetingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Meetings and returns the data updated in the database.
     * @param {MeetingUpdateManyAndReturnArgs} args - Arguments to update many Meetings.
     * @example
     * // Update many Meetings
     * const meeting = await prisma.meeting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Meetings and only return the `id`
     * const meetingWithIdOnly = await prisma.meeting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MeetingUpdateManyAndReturnArgs>(args: SelectSubset<T, MeetingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Meeting.
     * @param {MeetingUpsertArgs} args - Arguments to update or create a Meeting.
     * @example
     * // Update or create a Meeting
     * const meeting = await prisma.meeting.upsert({
     *   create: {
     *     // ... data to create a Meeting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Meeting we want to update
     *   }
     * })
     */
    upsert<T extends MeetingUpsertArgs>(args: SelectSubset<T, MeetingUpsertArgs<ExtArgs>>): Prisma__MeetingClient<$Result.GetResult<Prisma.$MeetingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Meetings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingCountArgs} args - Arguments to filter Meetings to count.
     * @example
     * // Count the number of Meetings
     * const count = await prisma.meeting.count({
     *   where: {
     *     // ... the filter for the Meetings we want to count
     *   }
     * })
    **/
    count<T extends MeetingCountArgs>(
      args?: Subset<T, MeetingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingAggregateArgs>(args: Subset<T, MeetingAggregateArgs>): Prisma.PrismaPromise<GetMeetingAggregateType<T>>

    /**
     * Group by Meeting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingGroupByArgs['orderBy'] }
        : { orderBy?: MeetingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Meeting model
   */
  readonly fields: MeetingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Meeting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends Meeting$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Meeting$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Meeting model
   */
  interface MeetingFieldRefs {
    readonly id: FieldRef<"Meeting", 'String'>
    readonly organizationId: FieldRef<"Meeting", 'Int'>
    readonly creatorId: FieldRef<"Meeting", 'Int'>
    readonly title: FieldRef<"Meeting", 'String'>
    readonly notes: FieldRef<"Meeting", 'String'>
    readonly participants: FieldRef<"Meeting", 'String'>
    readonly status: FieldRef<"Meeting", 'String'>
    readonly extractedActions: FieldRef<"Meeting", 'String'>
    readonly tasksCreated: FieldRef<"Meeting", 'String'>
    readonly createdAt: FieldRef<"Meeting", 'DateTime'>
    readonly updatedAt: FieldRef<"Meeting", 'DateTime'>
    readonly syncId: FieldRef<"Meeting", 'String'>
    readonly lastSynced: FieldRef<"Meeting", 'DateTime'>
    readonly needsSync: FieldRef<"Meeting", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Meeting findUnique
   */
  export type MeetingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findUniqueOrThrow
   */
  export type MeetingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting findFirst
   */
  export type MeetingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findFirstOrThrow
   */
  export type MeetingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meeting to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Meetings.
     */
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting findMany
   */
  export type MeetingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter, which Meetings to fetch.
     */
    where?: MeetingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Meetings to fetch.
     */
    orderBy?: MeetingOrderByWithRelationInput | MeetingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Meetings.
     */
    cursor?: MeetingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Meetings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Meetings.
     */
    skip?: number
    distinct?: MeetingScalarFieldEnum | MeetingScalarFieldEnum[]
  }

  /**
   * Meeting create
   */
  export type MeetingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to create a Meeting.
     */
    data: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
  }

  /**
   * Meeting createMany
   */
  export type MeetingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
  }

  /**
   * Meeting createManyAndReturn
   */
  export type MeetingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * The data used to create many Meetings.
     */
    data: MeetingCreateManyInput | MeetingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meeting update
   */
  export type MeetingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The data needed to update a Meeting.
     */
    data: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
    /**
     * Choose, which Meeting to update.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting updateMany
   */
  export type MeetingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to update.
     */
    limit?: number
  }

  /**
   * Meeting updateManyAndReturn
   */
  export type MeetingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * The data used to update Meetings.
     */
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyInput>
    /**
     * Filter which Meetings to update
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Meeting upsert
   */
  export type MeetingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * The filter to search for the Meeting to update in case it exists.
     */
    where: MeetingWhereUniqueInput
    /**
     * In case the Meeting found by the `where` argument doesn't exist, create a new Meeting with this data.
     */
    create: XOR<MeetingCreateInput, MeetingUncheckedCreateInput>
    /**
     * In case the Meeting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingUpdateInput, MeetingUncheckedUpdateInput>
  }

  /**
   * Meeting delete
   */
  export type MeetingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
    /**
     * Filter which Meeting to delete.
     */
    where: MeetingWhereUniqueInput
  }

  /**
   * Meeting deleteMany
   */
  export type MeetingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Meetings to delete
     */
    where?: MeetingWhereInput
    /**
     * Limit how many Meetings to delete.
     */
    limit?: number
  }

  /**
   * Meeting.creator
   */
  export type Meeting$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Meeting without action
   */
  export type MeetingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Meeting
     */
    select?: MeetingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Meeting
     */
    omit?: MeetingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingInclude<ExtArgs> | null
  }


  /**
   * Model EmailAccount
   */

  export type AggregateEmailAccount = {
    _count: EmailAccountCountAggregateOutputType | null
    _avg: EmailAccountAvgAggregateOutputType | null
    _sum: EmailAccountSumAggregateOutputType | null
    _min: EmailAccountMinAggregateOutputType | null
    _max: EmailAccountMaxAggregateOutputType | null
  }

  export type EmailAccountAvgAggregateOutputType = {
    organizationId: number | null
    userId: number | null
    unreadCount: number | null
  }

  export type EmailAccountSumAggregateOutputType = {
    organizationId: number | null
    userId: number | null
    unreadCount: number | null
  }

  export type EmailAccountMinAggregateOutputType = {
    id: string | null
    organizationId: number | null
    userId: number | null
    email: string | null
    providerId: string | null
    providerName: string | null
    provider: string | null
    credentials: string | null
    isConnected: boolean | null
    unreadCount: number | null
    connectedAt: Date | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type EmailAccountMaxAggregateOutputType = {
    id: string | null
    organizationId: number | null
    userId: number | null
    email: string | null
    providerId: string | null
    providerName: string | null
    provider: string | null
    credentials: string | null
    isConnected: boolean | null
    unreadCount: number | null
    connectedAt: Date | null
    lastSync: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type EmailAccountCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    email: number
    providerId: number
    providerName: number
    provider: number
    credentials: number
    isConnected: number
    unreadCount: number
    connectedAt: number
    lastSync: number
    createdAt: number
    updatedAt: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type EmailAccountAvgAggregateInputType = {
    organizationId?: true
    userId?: true
    unreadCount?: true
  }

  export type EmailAccountSumAggregateInputType = {
    organizationId?: true
    userId?: true
    unreadCount?: true
  }

  export type EmailAccountMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    email?: true
    providerId?: true
    providerName?: true
    provider?: true
    credentials?: true
    isConnected?: true
    unreadCount?: true
    connectedAt?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    needsSync?: true
  }

  export type EmailAccountMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    email?: true
    providerId?: true
    providerName?: true
    provider?: true
    credentials?: true
    isConnected?: true
    unreadCount?: true
    connectedAt?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    needsSync?: true
  }

  export type EmailAccountCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    email?: true
    providerId?: true
    providerName?: true
    provider?: true
    credentials?: true
    isConnected?: true
    unreadCount?: true
    connectedAt?: true
    lastSync?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type EmailAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAccount to aggregate.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAccounts
    **/
    _count?: true | EmailAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAccountMaxAggregateInputType
  }

  export type GetEmailAccountAggregateType<T extends EmailAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAccount[P]>
      : GetScalarType<T[P], AggregateEmailAccount[P]>
  }




  export type EmailAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAccountWhereInput
    orderBy?: EmailAccountOrderByWithAggregationInput | EmailAccountOrderByWithAggregationInput[]
    by: EmailAccountScalarFieldEnum[] | EmailAccountScalarFieldEnum
    having?: EmailAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAccountCountAggregateInputType | true
    _avg?: EmailAccountAvgAggregateInputType
    _sum?: EmailAccountSumAggregateInputType
    _min?: EmailAccountMinAggregateInputType
    _max?: EmailAccountMaxAggregateInputType
  }

  export type EmailAccountGroupByOutputType = {
    id: string
    organizationId: number
    userId: number | null
    email: string
    providerId: string
    providerName: string | null
    provider: string | null
    credentials: string | null
    isConnected: boolean
    unreadCount: number
    connectedAt: Date | null
    lastSync: Date | null
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    needsSync: boolean
    _count: EmailAccountCountAggregateOutputType | null
    _avg: EmailAccountAvgAggregateOutputType | null
    _sum: EmailAccountSumAggregateOutputType | null
    _min: EmailAccountMinAggregateOutputType | null
    _max: EmailAccountMaxAggregateOutputType | null
  }

  type GetEmailAccountGroupByPayload<T extends EmailAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAccountGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAccountGroupByOutputType[P]>
        }
      >
    >


  export type EmailAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    email?: boolean
    providerId?: boolean
    providerName?: boolean
    provider?: boolean
    credentials?: boolean
    isConnected?: boolean
    unreadCount?: boolean
    connectedAt?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    owner?: boolean | EmailAccount$ownerArgs<ExtArgs>
    selections?: boolean | EmailAccount$selectionsArgs<ExtArgs>
    _count?: boolean | EmailAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAccount"]>

  export type EmailAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    email?: boolean
    providerId?: boolean
    providerName?: boolean
    provider?: boolean
    credentials?: boolean
    isConnected?: boolean
    unreadCount?: boolean
    connectedAt?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    owner?: boolean | EmailAccount$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["emailAccount"]>

  export type EmailAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    email?: boolean
    providerId?: boolean
    providerName?: boolean
    provider?: boolean
    credentials?: boolean
    isConnected?: boolean
    unreadCount?: boolean
    connectedAt?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    owner?: boolean | EmailAccount$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["emailAccount"]>

  export type EmailAccountSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    email?: boolean
    providerId?: boolean
    providerName?: boolean
    provider?: boolean
    credentials?: boolean
    isConnected?: boolean
    unreadCount?: boolean
    connectedAt?: boolean
    lastSync?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type EmailAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "email" | "providerId" | "providerName" | "provider" | "credentials" | "isConnected" | "unreadCount" | "connectedAt" | "lastSync" | "createdAt" | "updatedAt" | "syncId" | "needsSync", ExtArgs["result"]["emailAccount"]>
  export type EmailAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    owner?: boolean | EmailAccount$ownerArgs<ExtArgs>
    selections?: boolean | EmailAccount$selectionsArgs<ExtArgs>
    _count?: boolean | EmailAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmailAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    owner?: boolean | EmailAccount$ownerArgs<ExtArgs>
  }
  export type EmailAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    owner?: boolean | EmailAccount$ownerArgs<ExtArgs>
  }

  export type $EmailAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAccount"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs> | null
      selections: Prisma.$EmailActiveSelectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      organizationId: number
      userId: number | null
      email: string
      providerId: string
      providerName: string | null
      provider: string | null
      credentials: string | null
      isConnected: boolean
      unreadCount: number
      connectedAt: Date | null
      lastSync: Date | null
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["emailAccount"]>
    composites: {}
  }

  type EmailAccountGetPayload<S extends boolean | null | undefined | EmailAccountDefaultArgs> = $Result.GetResult<Prisma.$EmailAccountPayload, S>

  type EmailAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailAccountCountAggregateInputType | true
    }

  export interface EmailAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAccount'], meta: { name: 'EmailAccount' } }
    /**
     * Find zero or one EmailAccount that matches the filter.
     * @param {EmailAccountFindUniqueArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAccountFindUniqueArgs>(args: SelectSubset<T, EmailAccountFindUniqueArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailAccountFindUniqueOrThrowArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountFindFirstArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAccountFindFirstArgs>(args?: SelectSubset<T, EmailAccountFindFirstArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountFindFirstOrThrowArgs} args - Arguments to find a EmailAccount
     * @example
     * // Get one EmailAccount
     * const emailAccount = await prisma.emailAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAccounts
     * const emailAccounts = await prisma.emailAccount.findMany()
     * 
     * // Get first 10 EmailAccounts
     * const emailAccounts = await prisma.emailAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailAccountWithIdOnly = await prisma.emailAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailAccountFindManyArgs>(args?: SelectSubset<T, EmailAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailAccount.
     * @param {EmailAccountCreateArgs} args - Arguments to create a EmailAccount.
     * @example
     * // Create one EmailAccount
     * const EmailAccount = await prisma.emailAccount.create({
     *   data: {
     *     // ... data to create a EmailAccount
     *   }
     * })
     * 
     */
    create<T extends EmailAccountCreateArgs>(args: SelectSubset<T, EmailAccountCreateArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailAccounts.
     * @param {EmailAccountCreateManyArgs} args - Arguments to create many EmailAccounts.
     * @example
     * // Create many EmailAccounts
     * const emailAccount = await prisma.emailAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAccountCreateManyArgs>(args?: SelectSubset<T, EmailAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailAccounts and returns the data saved in the database.
     * @param {EmailAccountCreateManyAndReturnArgs} args - Arguments to create many EmailAccounts.
     * @example
     * // Create many EmailAccounts
     * const emailAccount = await prisma.emailAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailAccounts and only return the `id`
     * const emailAccountWithIdOnly = await prisma.emailAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailAccount.
     * @param {EmailAccountDeleteArgs} args - Arguments to delete one EmailAccount.
     * @example
     * // Delete one EmailAccount
     * const EmailAccount = await prisma.emailAccount.delete({
     *   where: {
     *     // ... filter to delete one EmailAccount
     *   }
     * })
     * 
     */
    delete<T extends EmailAccountDeleteArgs>(args: SelectSubset<T, EmailAccountDeleteArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailAccount.
     * @param {EmailAccountUpdateArgs} args - Arguments to update one EmailAccount.
     * @example
     * // Update one EmailAccount
     * const emailAccount = await prisma.emailAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAccountUpdateArgs>(args: SelectSubset<T, EmailAccountUpdateArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailAccounts.
     * @param {EmailAccountDeleteManyArgs} args - Arguments to filter EmailAccounts to delete.
     * @example
     * // Delete a few EmailAccounts
     * const { count } = await prisma.emailAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAccountDeleteManyArgs>(args?: SelectSubset<T, EmailAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAccounts
     * const emailAccount = await prisma.emailAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAccountUpdateManyArgs>(args: SelectSubset<T, EmailAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAccounts and returns the data updated in the database.
     * @param {EmailAccountUpdateManyAndReturnArgs} args - Arguments to update many EmailAccounts.
     * @example
     * // Update many EmailAccounts
     * const emailAccount = await prisma.emailAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailAccounts and only return the `id`
     * const emailAccountWithIdOnly = await prisma.emailAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailAccount.
     * @param {EmailAccountUpsertArgs} args - Arguments to update or create a EmailAccount.
     * @example
     * // Update or create a EmailAccount
     * const emailAccount = await prisma.emailAccount.upsert({
     *   create: {
     *     // ... data to create a EmailAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAccount we want to update
     *   }
     * })
     */
    upsert<T extends EmailAccountUpsertArgs>(args: SelectSubset<T, EmailAccountUpsertArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountCountArgs} args - Arguments to filter EmailAccounts to count.
     * @example
     * // Count the number of EmailAccounts
     * const count = await prisma.emailAccount.count({
     *   where: {
     *     // ... the filter for the EmailAccounts we want to count
     *   }
     * })
    **/
    count<T extends EmailAccountCountArgs>(
      args?: Subset<T, EmailAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAccountAggregateArgs>(args: Subset<T, EmailAccountAggregateArgs>): Prisma.PrismaPromise<GetEmailAccountAggregateType<T>>

    /**
     * Group by EmailAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAccountGroupByArgs['orderBy'] }
        : { orderBy?: EmailAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAccount model
   */
  readonly fields: EmailAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends EmailAccount$ownerArgs<ExtArgs> = {}>(args?: Subset<T, EmailAccount$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    selections<T extends EmailAccount$selectionsArgs<ExtArgs> = {}>(args?: Subset<T, EmailAccount$selectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAccount model
   */
  interface EmailAccountFieldRefs {
    readonly id: FieldRef<"EmailAccount", 'String'>
    readonly organizationId: FieldRef<"EmailAccount", 'Int'>
    readonly userId: FieldRef<"EmailAccount", 'Int'>
    readonly email: FieldRef<"EmailAccount", 'String'>
    readonly providerId: FieldRef<"EmailAccount", 'String'>
    readonly providerName: FieldRef<"EmailAccount", 'String'>
    readonly provider: FieldRef<"EmailAccount", 'String'>
    readonly credentials: FieldRef<"EmailAccount", 'String'>
    readonly isConnected: FieldRef<"EmailAccount", 'Boolean'>
    readonly unreadCount: FieldRef<"EmailAccount", 'Int'>
    readonly connectedAt: FieldRef<"EmailAccount", 'DateTime'>
    readonly lastSync: FieldRef<"EmailAccount", 'DateTime'>
    readonly createdAt: FieldRef<"EmailAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailAccount", 'DateTime'>
    readonly syncId: FieldRef<"EmailAccount", 'String'>
    readonly needsSync: FieldRef<"EmailAccount", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * EmailAccount findUnique
   */
  export type EmailAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount findUniqueOrThrow
   */
  export type EmailAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount findFirst
   */
  export type EmailAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAccounts.
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAccounts.
     */
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * EmailAccount findFirstOrThrow
   */
  export type EmailAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccount to fetch.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAccounts.
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAccounts.
     */
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * EmailAccount findMany
   */
  export type EmailAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter, which EmailAccounts to fetch.
     */
    where?: EmailAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAccounts to fetch.
     */
    orderBy?: EmailAccountOrderByWithRelationInput | EmailAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAccounts.
     */
    cursor?: EmailAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAccounts.
     */
    skip?: number
    distinct?: EmailAccountScalarFieldEnum | EmailAccountScalarFieldEnum[]
  }

  /**
   * EmailAccount create
   */
  export type EmailAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAccount.
     */
    data: XOR<EmailAccountCreateInput, EmailAccountUncheckedCreateInput>
  }

  /**
   * EmailAccount createMany
   */
  export type EmailAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAccounts.
     */
    data: EmailAccountCreateManyInput | EmailAccountCreateManyInput[]
  }

  /**
   * EmailAccount createManyAndReturn
   */
  export type EmailAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * The data used to create many EmailAccounts.
     */
    data: EmailAccountCreateManyInput | EmailAccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAccount update
   */
  export type EmailAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAccount.
     */
    data: XOR<EmailAccountUpdateInput, EmailAccountUncheckedUpdateInput>
    /**
     * Choose, which EmailAccount to update.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount updateMany
   */
  export type EmailAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAccounts.
     */
    data: XOR<EmailAccountUpdateManyMutationInput, EmailAccountUncheckedUpdateManyInput>
    /**
     * Filter which EmailAccounts to update
     */
    where?: EmailAccountWhereInput
    /**
     * Limit how many EmailAccounts to update.
     */
    limit?: number
  }

  /**
   * EmailAccount updateManyAndReturn
   */
  export type EmailAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * The data used to update EmailAccounts.
     */
    data: XOR<EmailAccountUpdateManyMutationInput, EmailAccountUncheckedUpdateManyInput>
    /**
     * Filter which EmailAccounts to update
     */
    where?: EmailAccountWhereInput
    /**
     * Limit how many EmailAccounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAccount upsert
   */
  export type EmailAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAccount to update in case it exists.
     */
    where: EmailAccountWhereUniqueInput
    /**
     * In case the EmailAccount found by the `where` argument doesn't exist, create a new EmailAccount with this data.
     */
    create: XOR<EmailAccountCreateInput, EmailAccountUncheckedCreateInput>
    /**
     * In case the EmailAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAccountUpdateInput, EmailAccountUncheckedUpdateInput>
  }

  /**
   * EmailAccount delete
   */
  export type EmailAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
    /**
     * Filter which EmailAccount to delete.
     */
    where: EmailAccountWhereUniqueInput
  }

  /**
   * EmailAccount deleteMany
   */
  export type EmailAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAccounts to delete
     */
    where?: EmailAccountWhereInput
    /**
     * Limit how many EmailAccounts to delete.
     */
    limit?: number
  }

  /**
   * EmailAccount.owner
   */
  export type EmailAccount$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EmailAccount.selections
   */
  export type EmailAccount$selectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    where?: EmailActiveSelectionWhereInput
    orderBy?: EmailActiveSelectionOrderByWithRelationInput | EmailActiveSelectionOrderByWithRelationInput[]
    cursor?: EmailActiveSelectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailActiveSelectionScalarFieldEnum | EmailActiveSelectionScalarFieldEnum[]
  }

  /**
   * EmailAccount without action
   */
  export type EmailAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAccount
     */
    select?: EmailAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAccount
     */
    omit?: EmailAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAccountInclude<ExtArgs> | null
  }


  /**
   * Model EmailActiveSelection
   */

  export type AggregateEmailActiveSelection = {
    _count: EmailActiveSelectionCountAggregateOutputType | null
    _avg: EmailActiveSelectionAvgAggregateOutputType | null
    _sum: EmailActiveSelectionSumAggregateOutputType | null
    _min: EmailActiveSelectionMinAggregateOutputType | null
    _max: EmailActiveSelectionMaxAggregateOutputType | null
  }

  export type EmailActiveSelectionAvgAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
  }

  export type EmailActiveSelectionSumAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
  }

  export type EmailActiveSelectionMinAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
    accountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailActiveSelectionMaxAggregateOutputType = {
    id: number | null
    organizationId: number | null
    userId: number | null
    accountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailActiveSelectionCountAggregateOutputType = {
    id: number
    organizationId: number
    userId: number
    accountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailActiveSelectionAvgAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
  }

  export type EmailActiveSelectionSumAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
  }

  export type EmailActiveSelectionMinAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailActiveSelectionMaxAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailActiveSelectionCountAggregateInputType = {
    id?: true
    organizationId?: true
    userId?: true
    accountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailActiveSelectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailActiveSelection to aggregate.
     */
    where?: EmailActiveSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailActiveSelections to fetch.
     */
    orderBy?: EmailActiveSelectionOrderByWithRelationInput | EmailActiveSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailActiveSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailActiveSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailActiveSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailActiveSelections
    **/
    _count?: true | EmailActiveSelectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailActiveSelectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailActiveSelectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailActiveSelectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailActiveSelectionMaxAggregateInputType
  }

  export type GetEmailActiveSelectionAggregateType<T extends EmailActiveSelectionAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailActiveSelection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailActiveSelection[P]>
      : GetScalarType<T[P], AggregateEmailActiveSelection[P]>
  }




  export type EmailActiveSelectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailActiveSelectionWhereInput
    orderBy?: EmailActiveSelectionOrderByWithAggregationInput | EmailActiveSelectionOrderByWithAggregationInput[]
    by: EmailActiveSelectionScalarFieldEnum[] | EmailActiveSelectionScalarFieldEnum
    having?: EmailActiveSelectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailActiveSelectionCountAggregateInputType | true
    _avg?: EmailActiveSelectionAvgAggregateInputType
    _sum?: EmailActiveSelectionSumAggregateInputType
    _min?: EmailActiveSelectionMinAggregateInputType
    _max?: EmailActiveSelectionMaxAggregateInputType
  }

  export type EmailActiveSelectionGroupByOutputType = {
    id: number
    organizationId: number
    userId: number
    accountId: string
    createdAt: Date
    updatedAt: Date
    _count: EmailActiveSelectionCountAggregateOutputType | null
    _avg: EmailActiveSelectionAvgAggregateOutputType | null
    _sum: EmailActiveSelectionSumAggregateOutputType | null
    _min: EmailActiveSelectionMinAggregateOutputType | null
    _max: EmailActiveSelectionMaxAggregateOutputType | null
  }

  type GetEmailActiveSelectionGroupByPayload<T extends EmailActiveSelectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailActiveSelectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailActiveSelectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailActiveSelectionGroupByOutputType[P]>
            : GetScalarType<T[P], EmailActiveSelectionGroupByOutputType[P]>
        }
      >
    >


  export type EmailActiveSelectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | EmailAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailActiveSelection"]>

  export type EmailActiveSelectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | EmailAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailActiveSelection"]>

  export type EmailActiveSelectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | EmailAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailActiveSelection"]>

  export type EmailActiveSelectionSelectScalar = {
    id?: boolean
    organizationId?: boolean
    userId?: boolean
    accountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailActiveSelectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "organizationId" | "userId" | "accountId" | "createdAt" | "updatedAt", ExtArgs["result"]["emailActiveSelection"]>
  export type EmailActiveSelectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | EmailAccountDefaultArgs<ExtArgs>
  }
  export type EmailActiveSelectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | EmailAccountDefaultArgs<ExtArgs>
  }
  export type EmailActiveSelectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    account?: boolean | EmailAccountDefaultArgs<ExtArgs>
  }

  export type $EmailActiveSelectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailActiveSelection"
    objects: {
      organization: Prisma.$OrganizationPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      account: Prisma.$EmailAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      organizationId: number
      userId: number
      accountId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailActiveSelection"]>
    composites: {}
  }

  type EmailActiveSelectionGetPayload<S extends boolean | null | undefined | EmailActiveSelectionDefaultArgs> = $Result.GetResult<Prisma.$EmailActiveSelectionPayload, S>

  type EmailActiveSelectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailActiveSelectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailActiveSelectionCountAggregateInputType | true
    }

  export interface EmailActiveSelectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailActiveSelection'], meta: { name: 'EmailActiveSelection' } }
    /**
     * Find zero or one EmailActiveSelection that matches the filter.
     * @param {EmailActiveSelectionFindUniqueArgs} args - Arguments to find a EmailActiveSelection
     * @example
     * // Get one EmailActiveSelection
     * const emailActiveSelection = await prisma.emailActiveSelection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailActiveSelectionFindUniqueArgs>(args: SelectSubset<T, EmailActiveSelectionFindUniqueArgs<ExtArgs>>): Prisma__EmailActiveSelectionClient<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailActiveSelection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailActiveSelectionFindUniqueOrThrowArgs} args - Arguments to find a EmailActiveSelection
     * @example
     * // Get one EmailActiveSelection
     * const emailActiveSelection = await prisma.emailActiveSelection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailActiveSelectionFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailActiveSelectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailActiveSelectionClient<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailActiveSelection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActiveSelectionFindFirstArgs} args - Arguments to find a EmailActiveSelection
     * @example
     * // Get one EmailActiveSelection
     * const emailActiveSelection = await prisma.emailActiveSelection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailActiveSelectionFindFirstArgs>(args?: SelectSubset<T, EmailActiveSelectionFindFirstArgs<ExtArgs>>): Prisma__EmailActiveSelectionClient<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailActiveSelection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActiveSelectionFindFirstOrThrowArgs} args - Arguments to find a EmailActiveSelection
     * @example
     * // Get one EmailActiveSelection
     * const emailActiveSelection = await prisma.emailActiveSelection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailActiveSelectionFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailActiveSelectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailActiveSelectionClient<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailActiveSelections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActiveSelectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailActiveSelections
     * const emailActiveSelections = await prisma.emailActiveSelection.findMany()
     * 
     * // Get first 10 EmailActiveSelections
     * const emailActiveSelections = await prisma.emailActiveSelection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailActiveSelectionWithIdOnly = await prisma.emailActiveSelection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailActiveSelectionFindManyArgs>(args?: SelectSubset<T, EmailActiveSelectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailActiveSelection.
     * @param {EmailActiveSelectionCreateArgs} args - Arguments to create a EmailActiveSelection.
     * @example
     * // Create one EmailActiveSelection
     * const EmailActiveSelection = await prisma.emailActiveSelection.create({
     *   data: {
     *     // ... data to create a EmailActiveSelection
     *   }
     * })
     * 
     */
    create<T extends EmailActiveSelectionCreateArgs>(args: SelectSubset<T, EmailActiveSelectionCreateArgs<ExtArgs>>): Prisma__EmailActiveSelectionClient<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailActiveSelections.
     * @param {EmailActiveSelectionCreateManyArgs} args - Arguments to create many EmailActiveSelections.
     * @example
     * // Create many EmailActiveSelections
     * const emailActiveSelection = await prisma.emailActiveSelection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailActiveSelectionCreateManyArgs>(args?: SelectSubset<T, EmailActiveSelectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailActiveSelections and returns the data saved in the database.
     * @param {EmailActiveSelectionCreateManyAndReturnArgs} args - Arguments to create many EmailActiveSelections.
     * @example
     * // Create many EmailActiveSelections
     * const emailActiveSelection = await prisma.emailActiveSelection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailActiveSelections and only return the `id`
     * const emailActiveSelectionWithIdOnly = await prisma.emailActiveSelection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailActiveSelectionCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailActiveSelectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailActiveSelection.
     * @param {EmailActiveSelectionDeleteArgs} args - Arguments to delete one EmailActiveSelection.
     * @example
     * // Delete one EmailActiveSelection
     * const EmailActiveSelection = await prisma.emailActiveSelection.delete({
     *   where: {
     *     // ... filter to delete one EmailActiveSelection
     *   }
     * })
     * 
     */
    delete<T extends EmailActiveSelectionDeleteArgs>(args: SelectSubset<T, EmailActiveSelectionDeleteArgs<ExtArgs>>): Prisma__EmailActiveSelectionClient<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailActiveSelection.
     * @param {EmailActiveSelectionUpdateArgs} args - Arguments to update one EmailActiveSelection.
     * @example
     * // Update one EmailActiveSelection
     * const emailActiveSelection = await prisma.emailActiveSelection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailActiveSelectionUpdateArgs>(args: SelectSubset<T, EmailActiveSelectionUpdateArgs<ExtArgs>>): Prisma__EmailActiveSelectionClient<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailActiveSelections.
     * @param {EmailActiveSelectionDeleteManyArgs} args - Arguments to filter EmailActiveSelections to delete.
     * @example
     * // Delete a few EmailActiveSelections
     * const { count } = await prisma.emailActiveSelection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailActiveSelectionDeleteManyArgs>(args?: SelectSubset<T, EmailActiveSelectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailActiveSelections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActiveSelectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailActiveSelections
     * const emailActiveSelection = await prisma.emailActiveSelection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailActiveSelectionUpdateManyArgs>(args: SelectSubset<T, EmailActiveSelectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailActiveSelections and returns the data updated in the database.
     * @param {EmailActiveSelectionUpdateManyAndReturnArgs} args - Arguments to update many EmailActiveSelections.
     * @example
     * // Update many EmailActiveSelections
     * const emailActiveSelection = await prisma.emailActiveSelection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailActiveSelections and only return the `id`
     * const emailActiveSelectionWithIdOnly = await prisma.emailActiveSelection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailActiveSelectionUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailActiveSelectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailActiveSelection.
     * @param {EmailActiveSelectionUpsertArgs} args - Arguments to update or create a EmailActiveSelection.
     * @example
     * // Update or create a EmailActiveSelection
     * const emailActiveSelection = await prisma.emailActiveSelection.upsert({
     *   create: {
     *     // ... data to create a EmailActiveSelection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailActiveSelection we want to update
     *   }
     * })
     */
    upsert<T extends EmailActiveSelectionUpsertArgs>(args: SelectSubset<T, EmailActiveSelectionUpsertArgs<ExtArgs>>): Prisma__EmailActiveSelectionClient<$Result.GetResult<Prisma.$EmailActiveSelectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailActiveSelections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActiveSelectionCountArgs} args - Arguments to filter EmailActiveSelections to count.
     * @example
     * // Count the number of EmailActiveSelections
     * const count = await prisma.emailActiveSelection.count({
     *   where: {
     *     // ... the filter for the EmailActiveSelections we want to count
     *   }
     * })
    **/
    count<T extends EmailActiveSelectionCountArgs>(
      args?: Subset<T, EmailActiveSelectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailActiveSelectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailActiveSelection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActiveSelectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailActiveSelectionAggregateArgs>(args: Subset<T, EmailActiveSelectionAggregateArgs>): Prisma.PrismaPromise<GetEmailActiveSelectionAggregateType<T>>

    /**
     * Group by EmailActiveSelection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailActiveSelectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailActiveSelectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailActiveSelectionGroupByArgs['orderBy'] }
        : { orderBy?: EmailActiveSelectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailActiveSelectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailActiveSelectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailActiveSelection model
   */
  readonly fields: EmailActiveSelectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailActiveSelection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailActiveSelectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends EmailAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmailAccountDefaultArgs<ExtArgs>>): Prisma__EmailAccountClient<$Result.GetResult<Prisma.$EmailAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailActiveSelection model
   */
  interface EmailActiveSelectionFieldRefs {
    readonly id: FieldRef<"EmailActiveSelection", 'Int'>
    readonly organizationId: FieldRef<"EmailActiveSelection", 'Int'>
    readonly userId: FieldRef<"EmailActiveSelection", 'Int'>
    readonly accountId: FieldRef<"EmailActiveSelection", 'String'>
    readonly createdAt: FieldRef<"EmailActiveSelection", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailActiveSelection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailActiveSelection findUnique
   */
  export type EmailActiveSelectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    /**
     * Filter, which EmailActiveSelection to fetch.
     */
    where: EmailActiveSelectionWhereUniqueInput
  }

  /**
   * EmailActiveSelection findUniqueOrThrow
   */
  export type EmailActiveSelectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    /**
     * Filter, which EmailActiveSelection to fetch.
     */
    where: EmailActiveSelectionWhereUniqueInput
  }

  /**
   * EmailActiveSelection findFirst
   */
  export type EmailActiveSelectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    /**
     * Filter, which EmailActiveSelection to fetch.
     */
    where?: EmailActiveSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailActiveSelections to fetch.
     */
    orderBy?: EmailActiveSelectionOrderByWithRelationInput | EmailActiveSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailActiveSelections.
     */
    cursor?: EmailActiveSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailActiveSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailActiveSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailActiveSelections.
     */
    distinct?: EmailActiveSelectionScalarFieldEnum | EmailActiveSelectionScalarFieldEnum[]
  }

  /**
   * EmailActiveSelection findFirstOrThrow
   */
  export type EmailActiveSelectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    /**
     * Filter, which EmailActiveSelection to fetch.
     */
    where?: EmailActiveSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailActiveSelections to fetch.
     */
    orderBy?: EmailActiveSelectionOrderByWithRelationInput | EmailActiveSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailActiveSelections.
     */
    cursor?: EmailActiveSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailActiveSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailActiveSelections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailActiveSelections.
     */
    distinct?: EmailActiveSelectionScalarFieldEnum | EmailActiveSelectionScalarFieldEnum[]
  }

  /**
   * EmailActiveSelection findMany
   */
  export type EmailActiveSelectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    /**
     * Filter, which EmailActiveSelections to fetch.
     */
    where?: EmailActiveSelectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailActiveSelections to fetch.
     */
    orderBy?: EmailActiveSelectionOrderByWithRelationInput | EmailActiveSelectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailActiveSelections.
     */
    cursor?: EmailActiveSelectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailActiveSelections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailActiveSelections.
     */
    skip?: number
    distinct?: EmailActiveSelectionScalarFieldEnum | EmailActiveSelectionScalarFieldEnum[]
  }

  /**
   * EmailActiveSelection create
   */
  export type EmailActiveSelectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailActiveSelection.
     */
    data: XOR<EmailActiveSelectionCreateInput, EmailActiveSelectionUncheckedCreateInput>
  }

  /**
   * EmailActiveSelection createMany
   */
  export type EmailActiveSelectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailActiveSelections.
     */
    data: EmailActiveSelectionCreateManyInput | EmailActiveSelectionCreateManyInput[]
  }

  /**
   * EmailActiveSelection createManyAndReturn
   */
  export type EmailActiveSelectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * The data used to create many EmailActiveSelections.
     */
    data: EmailActiveSelectionCreateManyInput | EmailActiveSelectionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailActiveSelection update
   */
  export type EmailActiveSelectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailActiveSelection.
     */
    data: XOR<EmailActiveSelectionUpdateInput, EmailActiveSelectionUncheckedUpdateInput>
    /**
     * Choose, which EmailActiveSelection to update.
     */
    where: EmailActiveSelectionWhereUniqueInput
  }

  /**
   * EmailActiveSelection updateMany
   */
  export type EmailActiveSelectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailActiveSelections.
     */
    data: XOR<EmailActiveSelectionUpdateManyMutationInput, EmailActiveSelectionUncheckedUpdateManyInput>
    /**
     * Filter which EmailActiveSelections to update
     */
    where?: EmailActiveSelectionWhereInput
    /**
     * Limit how many EmailActiveSelections to update.
     */
    limit?: number
  }

  /**
   * EmailActiveSelection updateManyAndReturn
   */
  export type EmailActiveSelectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * The data used to update EmailActiveSelections.
     */
    data: XOR<EmailActiveSelectionUpdateManyMutationInput, EmailActiveSelectionUncheckedUpdateManyInput>
    /**
     * Filter which EmailActiveSelections to update
     */
    where?: EmailActiveSelectionWhereInput
    /**
     * Limit how many EmailActiveSelections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailActiveSelection upsert
   */
  export type EmailActiveSelectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailActiveSelection to update in case it exists.
     */
    where: EmailActiveSelectionWhereUniqueInput
    /**
     * In case the EmailActiveSelection found by the `where` argument doesn't exist, create a new EmailActiveSelection with this data.
     */
    create: XOR<EmailActiveSelectionCreateInput, EmailActiveSelectionUncheckedCreateInput>
    /**
     * In case the EmailActiveSelection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailActiveSelectionUpdateInput, EmailActiveSelectionUncheckedUpdateInput>
  }

  /**
   * EmailActiveSelection delete
   */
  export type EmailActiveSelectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
    /**
     * Filter which EmailActiveSelection to delete.
     */
    where: EmailActiveSelectionWhereUniqueInput
  }

  /**
   * EmailActiveSelection deleteMany
   */
  export type EmailActiveSelectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailActiveSelections to delete
     */
    where?: EmailActiveSelectionWhereInput
    /**
     * Limit how many EmailActiveSelections to delete.
     */
    limit?: number
  }

  /**
   * EmailActiveSelection without action
   */
  export type EmailActiveSelectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailActiveSelection
     */
    select?: EmailActiveSelectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailActiveSelection
     */
    omit?: EmailActiveSelectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailActiveSelectionInclude<ExtArgs> | null
  }


  /**
   * Model Need
   */

  export type AggregateNeed = {
    _count: NeedCountAggregateOutputType | null
    _avg: NeedAvgAggregateOutputType | null
    _sum: NeedSumAggregateOutputType | null
    _min: NeedMinAggregateOutputType | null
    _max: NeedMaxAggregateOutputType | null
  }

  export type NeedAvgAggregateOutputType = {
    budget: number | null
    requesterId: number | null
    organizationId: number | null
  }

  export type NeedSumAggregateOutputType = {
    budget: number | null
    requesterId: number | null
    organizationId: number | null
  }

  export type NeedMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    priority: string | null
    budget: number | null
    justification: string | null
    status: string | null
    requesterId: number | null
    requesterName: string | null
    organizationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type NeedMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    category: string | null
    priority: string | null
    budget: number | null
    justification: string | null
    status: string | null
    requesterId: number | null
    requesterName: string | null
    organizationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type NeedCountAggregateOutputType = {
    id: number
    title: number
    description: number
    category: number
    priority: number
    budget: number
    justification: number
    status: number
    requesterId: number
    requesterName: number
    organizationId: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    needsSync: number
    _all: number
  }


  export type NeedAvgAggregateInputType = {
    budget?: true
    requesterId?: true
    organizationId?: true
  }

  export type NeedSumAggregateInputType = {
    budget?: true
    requesterId?: true
    organizationId?: true
  }

  export type NeedMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    budget?: true
    justification?: true
    status?: true
    requesterId?: true
    requesterName?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type NeedMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    budget?: true
    justification?: true
    status?: true
    requesterId?: true
    requesterName?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type NeedCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    category?: true
    priority?: true
    budget?: true
    justification?: true
    status?: true
    requesterId?: true
    requesterName?: true
    organizationId?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
    _all?: true
  }

  export type NeedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Need to aggregate.
     */
    where?: NeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Needs to fetch.
     */
    orderBy?: NeedOrderByWithRelationInput | NeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Needs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Needs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Needs
    **/
    _count?: true | NeedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NeedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NeedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NeedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NeedMaxAggregateInputType
  }

  export type GetNeedAggregateType<T extends NeedAggregateArgs> = {
        [P in keyof T & keyof AggregateNeed]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNeed[P]>
      : GetScalarType<T[P], AggregateNeed[P]>
  }




  export type NeedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NeedWhereInput
    orderBy?: NeedOrderByWithAggregationInput | NeedOrderByWithAggregationInput[]
    by: NeedScalarFieldEnum[] | NeedScalarFieldEnum
    having?: NeedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NeedCountAggregateInputType | true
    _avg?: NeedAvgAggregateInputType
    _sum?: NeedSumAggregateInputType
    _min?: NeedMinAggregateInputType
    _max?: NeedMaxAggregateInputType
  }

  export type NeedGroupByOutputType = {
    id: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string | null
    status: string
    requesterId: number | null
    requesterName: string | null
    organizationId: number
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean
    _count: NeedCountAggregateOutputType | null
    _avg: NeedAvgAggregateOutputType | null
    _sum: NeedSumAggregateOutputType | null
    _min: NeedMinAggregateOutputType | null
    _max: NeedMaxAggregateOutputType | null
  }

  type GetNeedGroupByPayload<T extends NeedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NeedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NeedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NeedGroupByOutputType[P]>
            : GetScalarType<T[P], NeedGroupByOutputType[P]>
        }
      >
    >


  export type NeedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    budget?: boolean
    justification?: boolean
    status?: boolean
    requesterId?: boolean
    requesterName?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    requester?: boolean | Need$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    workflow?: boolean | Need$workflowArgs<ExtArgs>
    attachments?: boolean | Need$attachmentsArgs<ExtArgs>
    _count?: boolean | NeedCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["need"]>

  export type NeedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    budget?: boolean
    justification?: boolean
    status?: boolean
    requesterId?: boolean
    requesterName?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    requester?: boolean | Need$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["need"]>

  export type NeedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    budget?: boolean
    justification?: boolean
    status?: boolean
    requesterId?: boolean
    requesterName?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    requester?: boolean | Need$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["need"]>

  export type NeedSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    budget?: boolean
    justification?: boolean
    status?: boolean
    requesterId?: boolean
    requesterName?: boolean
    organizationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }

  export type NeedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "category" | "priority" | "budget" | "justification" | "status" | "requesterId" | "requesterName" | "organizationId" | "createdAt" | "updatedAt" | "syncId" | "lastSynced" | "needsSync", ExtArgs["result"]["need"]>
  export type NeedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | Need$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
    workflow?: boolean | Need$workflowArgs<ExtArgs>
    attachments?: boolean | Need$attachmentsArgs<ExtArgs>
    _count?: boolean | NeedCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NeedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | Need$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }
  export type NeedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    requester?: boolean | Need$requesterArgs<ExtArgs>
    organization?: boolean | OrganizationDefaultArgs<ExtArgs>
  }

  export type $NeedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Need"
    objects: {
      requester: Prisma.$UserPayload<ExtArgs> | null
      organization: Prisma.$OrganizationPayload<ExtArgs>
      workflow: Prisma.$NeedWorkflowStepPayload<ExtArgs>[]
      attachments: Prisma.$NeedAttachmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      category: string
      priority: string
      budget: number
      justification: string | null
      status: string
      requesterId: number | null
      requesterName: string | null
      organizationId: number
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
      needsSync: boolean
    }, ExtArgs["result"]["need"]>
    composites: {}
  }

  type NeedGetPayload<S extends boolean | null | undefined | NeedDefaultArgs> = $Result.GetResult<Prisma.$NeedPayload, S>

  type NeedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NeedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NeedCountAggregateInputType | true
    }

  export interface NeedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Need'], meta: { name: 'Need' } }
    /**
     * Find zero or one Need that matches the filter.
     * @param {NeedFindUniqueArgs} args - Arguments to find a Need
     * @example
     * // Get one Need
     * const need = await prisma.need.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NeedFindUniqueArgs>(args: SelectSubset<T, NeedFindUniqueArgs<ExtArgs>>): Prisma__NeedClient<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Need that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NeedFindUniqueOrThrowArgs} args - Arguments to find a Need
     * @example
     * // Get one Need
     * const need = await prisma.need.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NeedFindUniqueOrThrowArgs>(args: SelectSubset<T, NeedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NeedClient<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Need that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedFindFirstArgs} args - Arguments to find a Need
     * @example
     * // Get one Need
     * const need = await prisma.need.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NeedFindFirstArgs>(args?: SelectSubset<T, NeedFindFirstArgs<ExtArgs>>): Prisma__NeedClient<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Need that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedFindFirstOrThrowArgs} args - Arguments to find a Need
     * @example
     * // Get one Need
     * const need = await prisma.need.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NeedFindFirstOrThrowArgs>(args?: SelectSubset<T, NeedFindFirstOrThrowArgs<ExtArgs>>): Prisma__NeedClient<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Needs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Needs
     * const needs = await prisma.need.findMany()
     * 
     * // Get first 10 Needs
     * const needs = await prisma.need.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const needWithIdOnly = await prisma.need.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NeedFindManyArgs>(args?: SelectSubset<T, NeedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Need.
     * @param {NeedCreateArgs} args - Arguments to create a Need.
     * @example
     * // Create one Need
     * const Need = await prisma.need.create({
     *   data: {
     *     // ... data to create a Need
     *   }
     * })
     * 
     */
    create<T extends NeedCreateArgs>(args: SelectSubset<T, NeedCreateArgs<ExtArgs>>): Prisma__NeedClient<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Needs.
     * @param {NeedCreateManyArgs} args - Arguments to create many Needs.
     * @example
     * // Create many Needs
     * const need = await prisma.need.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NeedCreateManyArgs>(args?: SelectSubset<T, NeedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Needs and returns the data saved in the database.
     * @param {NeedCreateManyAndReturnArgs} args - Arguments to create many Needs.
     * @example
     * // Create many Needs
     * const need = await prisma.need.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Needs and only return the `id`
     * const needWithIdOnly = await prisma.need.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NeedCreateManyAndReturnArgs>(args?: SelectSubset<T, NeedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Need.
     * @param {NeedDeleteArgs} args - Arguments to delete one Need.
     * @example
     * // Delete one Need
     * const Need = await prisma.need.delete({
     *   where: {
     *     // ... filter to delete one Need
     *   }
     * })
     * 
     */
    delete<T extends NeedDeleteArgs>(args: SelectSubset<T, NeedDeleteArgs<ExtArgs>>): Prisma__NeedClient<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Need.
     * @param {NeedUpdateArgs} args - Arguments to update one Need.
     * @example
     * // Update one Need
     * const need = await prisma.need.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NeedUpdateArgs>(args: SelectSubset<T, NeedUpdateArgs<ExtArgs>>): Prisma__NeedClient<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Needs.
     * @param {NeedDeleteManyArgs} args - Arguments to filter Needs to delete.
     * @example
     * // Delete a few Needs
     * const { count } = await prisma.need.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NeedDeleteManyArgs>(args?: SelectSubset<T, NeedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Needs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Needs
     * const need = await prisma.need.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NeedUpdateManyArgs>(args: SelectSubset<T, NeedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Needs and returns the data updated in the database.
     * @param {NeedUpdateManyAndReturnArgs} args - Arguments to update many Needs.
     * @example
     * // Update many Needs
     * const need = await prisma.need.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Needs and only return the `id`
     * const needWithIdOnly = await prisma.need.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NeedUpdateManyAndReturnArgs>(args: SelectSubset<T, NeedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Need.
     * @param {NeedUpsertArgs} args - Arguments to update or create a Need.
     * @example
     * // Update or create a Need
     * const need = await prisma.need.upsert({
     *   create: {
     *     // ... data to create a Need
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Need we want to update
     *   }
     * })
     */
    upsert<T extends NeedUpsertArgs>(args: SelectSubset<T, NeedUpsertArgs<ExtArgs>>): Prisma__NeedClient<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Needs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedCountArgs} args - Arguments to filter Needs to count.
     * @example
     * // Count the number of Needs
     * const count = await prisma.need.count({
     *   where: {
     *     // ... the filter for the Needs we want to count
     *   }
     * })
    **/
    count<T extends NeedCountArgs>(
      args?: Subset<T, NeedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NeedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Need.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NeedAggregateArgs>(args: Subset<T, NeedAggregateArgs>): Prisma.PrismaPromise<GetNeedAggregateType<T>>

    /**
     * Group by Need.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NeedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NeedGroupByArgs['orderBy'] }
        : { orderBy?: NeedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NeedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNeedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Need model
   */
  readonly fields: NeedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Need.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NeedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    requester<T extends Need$requesterArgs<ExtArgs> = {}>(args?: Subset<T, Need$requesterArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    organization<T extends OrganizationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganizationDefaultArgs<ExtArgs>>): Prisma__OrganizationClient<$Result.GetResult<Prisma.$OrganizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workflow<T extends Need$workflowArgs<ExtArgs> = {}>(args?: Subset<T, Need$workflowArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attachments<T extends Need$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, Need$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Need model
   */
  interface NeedFieldRefs {
    readonly id: FieldRef<"Need", 'String'>
    readonly title: FieldRef<"Need", 'String'>
    readonly description: FieldRef<"Need", 'String'>
    readonly category: FieldRef<"Need", 'String'>
    readonly priority: FieldRef<"Need", 'String'>
    readonly budget: FieldRef<"Need", 'Float'>
    readonly justification: FieldRef<"Need", 'String'>
    readonly status: FieldRef<"Need", 'String'>
    readonly requesterId: FieldRef<"Need", 'Int'>
    readonly requesterName: FieldRef<"Need", 'String'>
    readonly organizationId: FieldRef<"Need", 'Int'>
    readonly createdAt: FieldRef<"Need", 'DateTime'>
    readonly updatedAt: FieldRef<"Need", 'DateTime'>
    readonly syncId: FieldRef<"Need", 'String'>
    readonly lastSynced: FieldRef<"Need", 'DateTime'>
    readonly needsSync: FieldRef<"Need", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Need findUnique
   */
  export type NeedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    /**
     * Filter, which Need to fetch.
     */
    where: NeedWhereUniqueInput
  }

  /**
   * Need findUniqueOrThrow
   */
  export type NeedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    /**
     * Filter, which Need to fetch.
     */
    where: NeedWhereUniqueInput
  }

  /**
   * Need findFirst
   */
  export type NeedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    /**
     * Filter, which Need to fetch.
     */
    where?: NeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Needs to fetch.
     */
    orderBy?: NeedOrderByWithRelationInput | NeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Needs.
     */
    cursor?: NeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Needs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Needs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Needs.
     */
    distinct?: NeedScalarFieldEnum | NeedScalarFieldEnum[]
  }

  /**
   * Need findFirstOrThrow
   */
  export type NeedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    /**
     * Filter, which Need to fetch.
     */
    where?: NeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Needs to fetch.
     */
    orderBy?: NeedOrderByWithRelationInput | NeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Needs.
     */
    cursor?: NeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Needs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Needs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Needs.
     */
    distinct?: NeedScalarFieldEnum | NeedScalarFieldEnum[]
  }

  /**
   * Need findMany
   */
  export type NeedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    /**
     * Filter, which Needs to fetch.
     */
    where?: NeedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Needs to fetch.
     */
    orderBy?: NeedOrderByWithRelationInput | NeedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Needs.
     */
    cursor?: NeedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Needs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Needs.
     */
    skip?: number
    distinct?: NeedScalarFieldEnum | NeedScalarFieldEnum[]
  }

  /**
   * Need create
   */
  export type NeedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    /**
     * The data needed to create a Need.
     */
    data: XOR<NeedCreateInput, NeedUncheckedCreateInput>
  }

  /**
   * Need createMany
   */
  export type NeedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Needs.
     */
    data: NeedCreateManyInput | NeedCreateManyInput[]
  }

  /**
   * Need createManyAndReturn
   */
  export type NeedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * The data used to create many Needs.
     */
    data: NeedCreateManyInput | NeedCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Need update
   */
  export type NeedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    /**
     * The data needed to update a Need.
     */
    data: XOR<NeedUpdateInput, NeedUncheckedUpdateInput>
    /**
     * Choose, which Need to update.
     */
    where: NeedWhereUniqueInput
  }

  /**
   * Need updateMany
   */
  export type NeedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Needs.
     */
    data: XOR<NeedUpdateManyMutationInput, NeedUncheckedUpdateManyInput>
    /**
     * Filter which Needs to update
     */
    where?: NeedWhereInput
    /**
     * Limit how many Needs to update.
     */
    limit?: number
  }

  /**
   * Need updateManyAndReturn
   */
  export type NeedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * The data used to update Needs.
     */
    data: XOR<NeedUpdateManyMutationInput, NeedUncheckedUpdateManyInput>
    /**
     * Filter which Needs to update
     */
    where?: NeedWhereInput
    /**
     * Limit how many Needs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Need upsert
   */
  export type NeedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    /**
     * The filter to search for the Need to update in case it exists.
     */
    where: NeedWhereUniqueInput
    /**
     * In case the Need found by the `where` argument doesn't exist, create a new Need with this data.
     */
    create: XOR<NeedCreateInput, NeedUncheckedCreateInput>
    /**
     * In case the Need was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NeedUpdateInput, NeedUncheckedUpdateInput>
  }

  /**
   * Need delete
   */
  export type NeedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
    /**
     * Filter which Need to delete.
     */
    where: NeedWhereUniqueInput
  }

  /**
   * Need deleteMany
   */
  export type NeedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Needs to delete
     */
    where?: NeedWhereInput
    /**
     * Limit how many Needs to delete.
     */
    limit?: number
  }

  /**
   * Need.requester
   */
  export type Need$requesterArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Need.workflow
   */
  export type Need$workflowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    where?: NeedWorkflowStepWhereInput
    orderBy?: NeedWorkflowStepOrderByWithRelationInput | NeedWorkflowStepOrderByWithRelationInput[]
    cursor?: NeedWorkflowStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NeedWorkflowStepScalarFieldEnum | NeedWorkflowStepScalarFieldEnum[]
  }

  /**
   * Need.attachments
   */
  export type Need$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
    where?: NeedAttachmentWhereInput
    orderBy?: NeedAttachmentOrderByWithRelationInput | NeedAttachmentOrderByWithRelationInput[]
    cursor?: NeedAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NeedAttachmentScalarFieldEnum | NeedAttachmentScalarFieldEnum[]
  }

  /**
   * Need without action
   */
  export type NeedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Need
     */
    select?: NeedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Need
     */
    omit?: NeedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedInclude<ExtArgs> | null
  }


  /**
   * Model NeedWorkflowStep
   */

  export type AggregateNeedWorkflowStep = {
    _count: NeedWorkflowStepCountAggregateOutputType | null
    _avg: NeedWorkflowStepAvgAggregateOutputType | null
    _sum: NeedWorkflowStepSumAggregateOutputType | null
    _min: NeedWorkflowStepMinAggregateOutputType | null
    _max: NeedWorkflowStepMaxAggregateOutputType | null
  }

  export type NeedWorkflowStepAvgAggregateOutputType = {
    reviewerId: number | null
    reviewerLevel: number | null
  }

  export type NeedWorkflowStepSumAggregateOutputType = {
    reviewerId: number | null
    reviewerLevel: number | null
  }

  export type NeedWorkflowStepMinAggregateOutputType = {
    id: string | null
    needId: string | null
    reviewerId: number | null
    reviewerName: string | null
    reviewerLevel: number | null
    action: string | null
    isRequired: boolean | null
    isCompleted: boolean | null
    comment: string | null
    createdAt: Date | null
    completedAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type NeedWorkflowStepMaxAggregateOutputType = {
    id: string | null
    needId: string | null
    reviewerId: number | null
    reviewerName: string | null
    reviewerLevel: number | null
    action: string | null
    isRequired: boolean | null
    isCompleted: boolean | null
    comment: string | null
    createdAt: Date | null
    completedAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type NeedWorkflowStepCountAggregateOutputType = {
    id: number
    needId: number
    reviewerId: number
    reviewerName: number
    reviewerLevel: number
    action: number
    isRequired: number
    isCompleted: number
    comment: number
    createdAt: number
    completedAt: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type NeedWorkflowStepAvgAggregateInputType = {
    reviewerId?: true
    reviewerLevel?: true
  }

  export type NeedWorkflowStepSumAggregateInputType = {
    reviewerId?: true
    reviewerLevel?: true
  }

  export type NeedWorkflowStepMinAggregateInputType = {
    id?: true
    needId?: true
    reviewerId?: true
    reviewerName?: true
    reviewerLevel?: true
    action?: true
    isRequired?: true
    isCompleted?: true
    comment?: true
    createdAt?: true
    completedAt?: true
    syncId?: true
    needsSync?: true
  }

  export type NeedWorkflowStepMaxAggregateInputType = {
    id?: true
    needId?: true
    reviewerId?: true
    reviewerName?: true
    reviewerLevel?: true
    action?: true
    isRequired?: true
    isCompleted?: true
    comment?: true
    createdAt?: true
    completedAt?: true
    syncId?: true
    needsSync?: true
  }

  export type NeedWorkflowStepCountAggregateInputType = {
    id?: true
    needId?: true
    reviewerId?: true
    reviewerName?: true
    reviewerLevel?: true
    action?: true
    isRequired?: true
    isCompleted?: true
    comment?: true
    createdAt?: true
    completedAt?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type NeedWorkflowStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NeedWorkflowStep to aggregate.
     */
    where?: NeedWorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeedWorkflowSteps to fetch.
     */
    orderBy?: NeedWorkflowStepOrderByWithRelationInput | NeedWorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NeedWorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeedWorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeedWorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NeedWorkflowSteps
    **/
    _count?: true | NeedWorkflowStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NeedWorkflowStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NeedWorkflowStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NeedWorkflowStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NeedWorkflowStepMaxAggregateInputType
  }

  export type GetNeedWorkflowStepAggregateType<T extends NeedWorkflowStepAggregateArgs> = {
        [P in keyof T & keyof AggregateNeedWorkflowStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNeedWorkflowStep[P]>
      : GetScalarType<T[P], AggregateNeedWorkflowStep[P]>
  }




  export type NeedWorkflowStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NeedWorkflowStepWhereInput
    orderBy?: NeedWorkflowStepOrderByWithAggregationInput | NeedWorkflowStepOrderByWithAggregationInput[]
    by: NeedWorkflowStepScalarFieldEnum[] | NeedWorkflowStepScalarFieldEnum
    having?: NeedWorkflowStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NeedWorkflowStepCountAggregateInputType | true
    _avg?: NeedWorkflowStepAvgAggregateInputType
    _sum?: NeedWorkflowStepSumAggregateInputType
    _min?: NeedWorkflowStepMinAggregateInputType
    _max?: NeedWorkflowStepMaxAggregateInputType
  }

  export type NeedWorkflowStepGroupByOutputType = {
    id: string
    needId: string
    reviewerId: number | null
    reviewerName: string
    reviewerLevel: number
    action: string
    isRequired: boolean
    isCompleted: boolean
    comment: string | null
    createdAt: Date
    completedAt: Date | null
    syncId: string | null
    needsSync: boolean
    _count: NeedWorkflowStepCountAggregateOutputType | null
    _avg: NeedWorkflowStepAvgAggregateOutputType | null
    _sum: NeedWorkflowStepSumAggregateOutputType | null
    _min: NeedWorkflowStepMinAggregateOutputType | null
    _max: NeedWorkflowStepMaxAggregateOutputType | null
  }

  type GetNeedWorkflowStepGroupByPayload<T extends NeedWorkflowStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NeedWorkflowStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NeedWorkflowStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NeedWorkflowStepGroupByOutputType[P]>
            : GetScalarType<T[P], NeedWorkflowStepGroupByOutputType[P]>
        }
      >
    >


  export type NeedWorkflowStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    needId?: boolean
    reviewerId?: boolean
    reviewerName?: boolean
    reviewerLevel?: boolean
    action?: boolean
    isRequired?: boolean
    isCompleted?: boolean
    comment?: boolean
    createdAt?: boolean
    completedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    need?: boolean | NeedDefaultArgs<ExtArgs>
    reviewer?: boolean | NeedWorkflowStep$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["needWorkflowStep"]>

  export type NeedWorkflowStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    needId?: boolean
    reviewerId?: boolean
    reviewerName?: boolean
    reviewerLevel?: boolean
    action?: boolean
    isRequired?: boolean
    isCompleted?: boolean
    comment?: boolean
    createdAt?: boolean
    completedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    need?: boolean | NeedDefaultArgs<ExtArgs>
    reviewer?: boolean | NeedWorkflowStep$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["needWorkflowStep"]>

  export type NeedWorkflowStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    needId?: boolean
    reviewerId?: boolean
    reviewerName?: boolean
    reviewerLevel?: boolean
    action?: boolean
    isRequired?: boolean
    isCompleted?: boolean
    comment?: boolean
    createdAt?: boolean
    completedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    need?: boolean | NeedDefaultArgs<ExtArgs>
    reviewer?: boolean | NeedWorkflowStep$reviewerArgs<ExtArgs>
  }, ExtArgs["result"]["needWorkflowStep"]>

  export type NeedWorkflowStepSelectScalar = {
    id?: boolean
    needId?: boolean
    reviewerId?: boolean
    reviewerName?: boolean
    reviewerLevel?: boolean
    action?: boolean
    isRequired?: boolean
    isCompleted?: boolean
    comment?: boolean
    createdAt?: boolean
    completedAt?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type NeedWorkflowStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "needId" | "reviewerId" | "reviewerName" | "reviewerLevel" | "action" | "isRequired" | "isCompleted" | "comment" | "createdAt" | "completedAt" | "syncId" | "needsSync", ExtArgs["result"]["needWorkflowStep"]>
  export type NeedWorkflowStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    need?: boolean | NeedDefaultArgs<ExtArgs>
    reviewer?: boolean | NeedWorkflowStep$reviewerArgs<ExtArgs>
  }
  export type NeedWorkflowStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    need?: boolean | NeedDefaultArgs<ExtArgs>
    reviewer?: boolean | NeedWorkflowStep$reviewerArgs<ExtArgs>
  }
  export type NeedWorkflowStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    need?: boolean | NeedDefaultArgs<ExtArgs>
    reviewer?: boolean | NeedWorkflowStep$reviewerArgs<ExtArgs>
  }

  export type $NeedWorkflowStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NeedWorkflowStep"
    objects: {
      need: Prisma.$NeedPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      needId: string
      reviewerId: number | null
      reviewerName: string
      reviewerLevel: number
      action: string
      isRequired: boolean
      isCompleted: boolean
      comment: string | null
      createdAt: Date
      completedAt: Date | null
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["needWorkflowStep"]>
    composites: {}
  }

  type NeedWorkflowStepGetPayload<S extends boolean | null | undefined | NeedWorkflowStepDefaultArgs> = $Result.GetResult<Prisma.$NeedWorkflowStepPayload, S>

  type NeedWorkflowStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NeedWorkflowStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NeedWorkflowStepCountAggregateInputType | true
    }

  export interface NeedWorkflowStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NeedWorkflowStep'], meta: { name: 'NeedWorkflowStep' } }
    /**
     * Find zero or one NeedWorkflowStep that matches the filter.
     * @param {NeedWorkflowStepFindUniqueArgs} args - Arguments to find a NeedWorkflowStep
     * @example
     * // Get one NeedWorkflowStep
     * const needWorkflowStep = await prisma.needWorkflowStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NeedWorkflowStepFindUniqueArgs>(args: SelectSubset<T, NeedWorkflowStepFindUniqueArgs<ExtArgs>>): Prisma__NeedWorkflowStepClient<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NeedWorkflowStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NeedWorkflowStepFindUniqueOrThrowArgs} args - Arguments to find a NeedWorkflowStep
     * @example
     * // Get one NeedWorkflowStep
     * const needWorkflowStep = await prisma.needWorkflowStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NeedWorkflowStepFindUniqueOrThrowArgs>(args: SelectSubset<T, NeedWorkflowStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NeedWorkflowStepClient<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NeedWorkflowStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedWorkflowStepFindFirstArgs} args - Arguments to find a NeedWorkflowStep
     * @example
     * // Get one NeedWorkflowStep
     * const needWorkflowStep = await prisma.needWorkflowStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NeedWorkflowStepFindFirstArgs>(args?: SelectSubset<T, NeedWorkflowStepFindFirstArgs<ExtArgs>>): Prisma__NeedWorkflowStepClient<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NeedWorkflowStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedWorkflowStepFindFirstOrThrowArgs} args - Arguments to find a NeedWorkflowStep
     * @example
     * // Get one NeedWorkflowStep
     * const needWorkflowStep = await prisma.needWorkflowStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NeedWorkflowStepFindFirstOrThrowArgs>(args?: SelectSubset<T, NeedWorkflowStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__NeedWorkflowStepClient<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NeedWorkflowSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedWorkflowStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NeedWorkflowSteps
     * const needWorkflowSteps = await prisma.needWorkflowStep.findMany()
     * 
     * // Get first 10 NeedWorkflowSteps
     * const needWorkflowSteps = await prisma.needWorkflowStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const needWorkflowStepWithIdOnly = await prisma.needWorkflowStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NeedWorkflowStepFindManyArgs>(args?: SelectSubset<T, NeedWorkflowStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NeedWorkflowStep.
     * @param {NeedWorkflowStepCreateArgs} args - Arguments to create a NeedWorkflowStep.
     * @example
     * // Create one NeedWorkflowStep
     * const NeedWorkflowStep = await prisma.needWorkflowStep.create({
     *   data: {
     *     // ... data to create a NeedWorkflowStep
     *   }
     * })
     * 
     */
    create<T extends NeedWorkflowStepCreateArgs>(args: SelectSubset<T, NeedWorkflowStepCreateArgs<ExtArgs>>): Prisma__NeedWorkflowStepClient<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NeedWorkflowSteps.
     * @param {NeedWorkflowStepCreateManyArgs} args - Arguments to create many NeedWorkflowSteps.
     * @example
     * // Create many NeedWorkflowSteps
     * const needWorkflowStep = await prisma.needWorkflowStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NeedWorkflowStepCreateManyArgs>(args?: SelectSubset<T, NeedWorkflowStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NeedWorkflowSteps and returns the data saved in the database.
     * @param {NeedWorkflowStepCreateManyAndReturnArgs} args - Arguments to create many NeedWorkflowSteps.
     * @example
     * // Create many NeedWorkflowSteps
     * const needWorkflowStep = await prisma.needWorkflowStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NeedWorkflowSteps and only return the `id`
     * const needWorkflowStepWithIdOnly = await prisma.needWorkflowStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NeedWorkflowStepCreateManyAndReturnArgs>(args?: SelectSubset<T, NeedWorkflowStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NeedWorkflowStep.
     * @param {NeedWorkflowStepDeleteArgs} args - Arguments to delete one NeedWorkflowStep.
     * @example
     * // Delete one NeedWorkflowStep
     * const NeedWorkflowStep = await prisma.needWorkflowStep.delete({
     *   where: {
     *     // ... filter to delete one NeedWorkflowStep
     *   }
     * })
     * 
     */
    delete<T extends NeedWorkflowStepDeleteArgs>(args: SelectSubset<T, NeedWorkflowStepDeleteArgs<ExtArgs>>): Prisma__NeedWorkflowStepClient<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NeedWorkflowStep.
     * @param {NeedWorkflowStepUpdateArgs} args - Arguments to update one NeedWorkflowStep.
     * @example
     * // Update one NeedWorkflowStep
     * const needWorkflowStep = await prisma.needWorkflowStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NeedWorkflowStepUpdateArgs>(args: SelectSubset<T, NeedWorkflowStepUpdateArgs<ExtArgs>>): Prisma__NeedWorkflowStepClient<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NeedWorkflowSteps.
     * @param {NeedWorkflowStepDeleteManyArgs} args - Arguments to filter NeedWorkflowSteps to delete.
     * @example
     * // Delete a few NeedWorkflowSteps
     * const { count } = await prisma.needWorkflowStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NeedWorkflowStepDeleteManyArgs>(args?: SelectSubset<T, NeedWorkflowStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NeedWorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedWorkflowStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NeedWorkflowSteps
     * const needWorkflowStep = await prisma.needWorkflowStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NeedWorkflowStepUpdateManyArgs>(args: SelectSubset<T, NeedWorkflowStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NeedWorkflowSteps and returns the data updated in the database.
     * @param {NeedWorkflowStepUpdateManyAndReturnArgs} args - Arguments to update many NeedWorkflowSteps.
     * @example
     * // Update many NeedWorkflowSteps
     * const needWorkflowStep = await prisma.needWorkflowStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NeedWorkflowSteps and only return the `id`
     * const needWorkflowStepWithIdOnly = await prisma.needWorkflowStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NeedWorkflowStepUpdateManyAndReturnArgs>(args: SelectSubset<T, NeedWorkflowStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NeedWorkflowStep.
     * @param {NeedWorkflowStepUpsertArgs} args - Arguments to update or create a NeedWorkflowStep.
     * @example
     * // Update or create a NeedWorkflowStep
     * const needWorkflowStep = await prisma.needWorkflowStep.upsert({
     *   create: {
     *     // ... data to create a NeedWorkflowStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NeedWorkflowStep we want to update
     *   }
     * })
     */
    upsert<T extends NeedWorkflowStepUpsertArgs>(args: SelectSubset<T, NeedWorkflowStepUpsertArgs<ExtArgs>>): Prisma__NeedWorkflowStepClient<$Result.GetResult<Prisma.$NeedWorkflowStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NeedWorkflowSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedWorkflowStepCountArgs} args - Arguments to filter NeedWorkflowSteps to count.
     * @example
     * // Count the number of NeedWorkflowSteps
     * const count = await prisma.needWorkflowStep.count({
     *   where: {
     *     // ... the filter for the NeedWorkflowSteps we want to count
     *   }
     * })
    **/
    count<T extends NeedWorkflowStepCountArgs>(
      args?: Subset<T, NeedWorkflowStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NeedWorkflowStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NeedWorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedWorkflowStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NeedWorkflowStepAggregateArgs>(args: Subset<T, NeedWorkflowStepAggregateArgs>): Prisma.PrismaPromise<GetNeedWorkflowStepAggregateType<T>>

    /**
     * Group by NeedWorkflowStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedWorkflowStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NeedWorkflowStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NeedWorkflowStepGroupByArgs['orderBy'] }
        : { orderBy?: NeedWorkflowStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NeedWorkflowStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNeedWorkflowStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NeedWorkflowStep model
   */
  readonly fields: NeedWorkflowStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NeedWorkflowStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NeedWorkflowStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    need<T extends NeedDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NeedDefaultArgs<ExtArgs>>): Prisma__NeedClient<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends NeedWorkflowStep$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, NeedWorkflowStep$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NeedWorkflowStep model
   */
  interface NeedWorkflowStepFieldRefs {
    readonly id: FieldRef<"NeedWorkflowStep", 'String'>
    readonly needId: FieldRef<"NeedWorkflowStep", 'String'>
    readonly reviewerId: FieldRef<"NeedWorkflowStep", 'Int'>
    readonly reviewerName: FieldRef<"NeedWorkflowStep", 'String'>
    readonly reviewerLevel: FieldRef<"NeedWorkflowStep", 'Int'>
    readonly action: FieldRef<"NeedWorkflowStep", 'String'>
    readonly isRequired: FieldRef<"NeedWorkflowStep", 'Boolean'>
    readonly isCompleted: FieldRef<"NeedWorkflowStep", 'Boolean'>
    readonly comment: FieldRef<"NeedWorkflowStep", 'String'>
    readonly createdAt: FieldRef<"NeedWorkflowStep", 'DateTime'>
    readonly completedAt: FieldRef<"NeedWorkflowStep", 'DateTime'>
    readonly syncId: FieldRef<"NeedWorkflowStep", 'String'>
    readonly needsSync: FieldRef<"NeedWorkflowStep", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NeedWorkflowStep findUnique
   */
  export type NeedWorkflowStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which NeedWorkflowStep to fetch.
     */
    where: NeedWorkflowStepWhereUniqueInput
  }

  /**
   * NeedWorkflowStep findUniqueOrThrow
   */
  export type NeedWorkflowStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which NeedWorkflowStep to fetch.
     */
    where: NeedWorkflowStepWhereUniqueInput
  }

  /**
   * NeedWorkflowStep findFirst
   */
  export type NeedWorkflowStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which NeedWorkflowStep to fetch.
     */
    where?: NeedWorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeedWorkflowSteps to fetch.
     */
    orderBy?: NeedWorkflowStepOrderByWithRelationInput | NeedWorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NeedWorkflowSteps.
     */
    cursor?: NeedWorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeedWorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeedWorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NeedWorkflowSteps.
     */
    distinct?: NeedWorkflowStepScalarFieldEnum | NeedWorkflowStepScalarFieldEnum[]
  }

  /**
   * NeedWorkflowStep findFirstOrThrow
   */
  export type NeedWorkflowStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which NeedWorkflowStep to fetch.
     */
    where?: NeedWorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeedWorkflowSteps to fetch.
     */
    orderBy?: NeedWorkflowStepOrderByWithRelationInput | NeedWorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NeedWorkflowSteps.
     */
    cursor?: NeedWorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeedWorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeedWorkflowSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NeedWorkflowSteps.
     */
    distinct?: NeedWorkflowStepScalarFieldEnum | NeedWorkflowStepScalarFieldEnum[]
  }

  /**
   * NeedWorkflowStep findMany
   */
  export type NeedWorkflowStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter, which NeedWorkflowSteps to fetch.
     */
    where?: NeedWorkflowStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeedWorkflowSteps to fetch.
     */
    orderBy?: NeedWorkflowStepOrderByWithRelationInput | NeedWorkflowStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NeedWorkflowSteps.
     */
    cursor?: NeedWorkflowStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeedWorkflowSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeedWorkflowSteps.
     */
    skip?: number
    distinct?: NeedWorkflowStepScalarFieldEnum | NeedWorkflowStepScalarFieldEnum[]
  }

  /**
   * NeedWorkflowStep create
   */
  export type NeedWorkflowStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to create a NeedWorkflowStep.
     */
    data: XOR<NeedWorkflowStepCreateInput, NeedWorkflowStepUncheckedCreateInput>
  }

  /**
   * NeedWorkflowStep createMany
   */
  export type NeedWorkflowStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NeedWorkflowSteps.
     */
    data: NeedWorkflowStepCreateManyInput | NeedWorkflowStepCreateManyInput[]
  }

  /**
   * NeedWorkflowStep createManyAndReturn
   */
  export type NeedWorkflowStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * The data used to create many NeedWorkflowSteps.
     */
    data: NeedWorkflowStepCreateManyInput | NeedWorkflowStepCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NeedWorkflowStep update
   */
  export type NeedWorkflowStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    /**
     * The data needed to update a NeedWorkflowStep.
     */
    data: XOR<NeedWorkflowStepUpdateInput, NeedWorkflowStepUncheckedUpdateInput>
    /**
     * Choose, which NeedWorkflowStep to update.
     */
    where: NeedWorkflowStepWhereUniqueInput
  }

  /**
   * NeedWorkflowStep updateMany
   */
  export type NeedWorkflowStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NeedWorkflowSteps.
     */
    data: XOR<NeedWorkflowStepUpdateManyMutationInput, NeedWorkflowStepUncheckedUpdateManyInput>
    /**
     * Filter which NeedWorkflowSteps to update
     */
    where?: NeedWorkflowStepWhereInput
    /**
     * Limit how many NeedWorkflowSteps to update.
     */
    limit?: number
  }

  /**
   * NeedWorkflowStep updateManyAndReturn
   */
  export type NeedWorkflowStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * The data used to update NeedWorkflowSteps.
     */
    data: XOR<NeedWorkflowStepUpdateManyMutationInput, NeedWorkflowStepUncheckedUpdateManyInput>
    /**
     * Filter which NeedWorkflowSteps to update
     */
    where?: NeedWorkflowStepWhereInput
    /**
     * Limit how many NeedWorkflowSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NeedWorkflowStep upsert
   */
  export type NeedWorkflowStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    /**
     * The filter to search for the NeedWorkflowStep to update in case it exists.
     */
    where: NeedWorkflowStepWhereUniqueInput
    /**
     * In case the NeedWorkflowStep found by the `where` argument doesn't exist, create a new NeedWorkflowStep with this data.
     */
    create: XOR<NeedWorkflowStepCreateInput, NeedWorkflowStepUncheckedCreateInput>
    /**
     * In case the NeedWorkflowStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NeedWorkflowStepUpdateInput, NeedWorkflowStepUncheckedUpdateInput>
  }

  /**
   * NeedWorkflowStep delete
   */
  export type NeedWorkflowStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
    /**
     * Filter which NeedWorkflowStep to delete.
     */
    where: NeedWorkflowStepWhereUniqueInput
  }

  /**
   * NeedWorkflowStep deleteMany
   */
  export type NeedWorkflowStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NeedWorkflowSteps to delete
     */
    where?: NeedWorkflowStepWhereInput
    /**
     * Limit how many NeedWorkflowSteps to delete.
     */
    limit?: number
  }

  /**
   * NeedWorkflowStep.reviewer
   */
  export type NeedWorkflowStep$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * NeedWorkflowStep without action
   */
  export type NeedWorkflowStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedWorkflowStep
     */
    select?: NeedWorkflowStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedWorkflowStep
     */
    omit?: NeedWorkflowStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedWorkflowStepInclude<ExtArgs> | null
  }


  /**
   * Model NeedAttachment
   */

  export type AggregateNeedAttachment = {
    _count: NeedAttachmentCountAggregateOutputType | null
    _avg: NeedAttachmentAvgAggregateOutputType | null
    _sum: NeedAttachmentSumAggregateOutputType | null
    _min: NeedAttachmentMinAggregateOutputType | null
    _max: NeedAttachmentMaxAggregateOutputType | null
  }

  export type NeedAttachmentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type NeedAttachmentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type NeedAttachmentMinAggregateOutputType = {
    id: string | null
    needId: string | null
    fileName: string | null
    fileSize: number | null
    fileType: string | null
    uploadedBy: string | null
    url: string | null
    localPath: string | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type NeedAttachmentMaxAggregateOutputType = {
    id: string | null
    needId: string | null
    fileName: string | null
    fileSize: number | null
    fileType: string | null
    uploadedBy: string | null
    url: string | null
    localPath: string | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type NeedAttachmentCountAggregateOutputType = {
    id: number
    needId: number
    fileName: number
    fileSize: number
    fileType: number
    uploadedBy: number
    url: number
    localPath: number
    createdAt: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type NeedAttachmentAvgAggregateInputType = {
    fileSize?: true
  }

  export type NeedAttachmentSumAggregateInputType = {
    fileSize?: true
  }

  export type NeedAttachmentMinAggregateInputType = {
    id?: true
    needId?: true
    fileName?: true
    fileSize?: true
    fileType?: true
    uploadedBy?: true
    url?: true
    localPath?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type NeedAttachmentMaxAggregateInputType = {
    id?: true
    needId?: true
    fileName?: true
    fileSize?: true
    fileType?: true
    uploadedBy?: true
    url?: true
    localPath?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type NeedAttachmentCountAggregateInputType = {
    id?: true
    needId?: true
    fileName?: true
    fileSize?: true
    fileType?: true
    uploadedBy?: true
    url?: true
    localPath?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type NeedAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NeedAttachment to aggregate.
     */
    where?: NeedAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeedAttachments to fetch.
     */
    orderBy?: NeedAttachmentOrderByWithRelationInput | NeedAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NeedAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeedAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeedAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NeedAttachments
    **/
    _count?: true | NeedAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NeedAttachmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NeedAttachmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NeedAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NeedAttachmentMaxAggregateInputType
  }

  export type GetNeedAttachmentAggregateType<T extends NeedAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregateNeedAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNeedAttachment[P]>
      : GetScalarType<T[P], AggregateNeedAttachment[P]>
  }




  export type NeedAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NeedAttachmentWhereInput
    orderBy?: NeedAttachmentOrderByWithAggregationInput | NeedAttachmentOrderByWithAggregationInput[]
    by: NeedAttachmentScalarFieldEnum[] | NeedAttachmentScalarFieldEnum
    having?: NeedAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NeedAttachmentCountAggregateInputType | true
    _avg?: NeedAttachmentAvgAggregateInputType
    _sum?: NeedAttachmentSumAggregateInputType
    _min?: NeedAttachmentMinAggregateInputType
    _max?: NeedAttachmentMaxAggregateInputType
  }

  export type NeedAttachmentGroupByOutputType = {
    id: string
    needId: string
    fileName: string
    fileSize: number
    fileType: string
    uploadedBy: string
    url: string
    localPath: string | null
    createdAt: Date
    syncId: string | null
    needsSync: boolean
    _count: NeedAttachmentCountAggregateOutputType | null
    _avg: NeedAttachmentAvgAggregateOutputType | null
    _sum: NeedAttachmentSumAggregateOutputType | null
    _min: NeedAttachmentMinAggregateOutputType | null
    _max: NeedAttachmentMaxAggregateOutputType | null
  }

  type GetNeedAttachmentGroupByPayload<T extends NeedAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NeedAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NeedAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NeedAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], NeedAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type NeedAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    needId?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileType?: boolean
    uploadedBy?: boolean
    url?: boolean
    localPath?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    need?: boolean | NeedDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["needAttachment"]>

  export type NeedAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    needId?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileType?: boolean
    uploadedBy?: boolean
    url?: boolean
    localPath?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    need?: boolean | NeedDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["needAttachment"]>

  export type NeedAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    needId?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileType?: boolean
    uploadedBy?: boolean
    url?: boolean
    localPath?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    need?: boolean | NeedDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["needAttachment"]>

  export type NeedAttachmentSelectScalar = {
    id?: boolean
    needId?: boolean
    fileName?: boolean
    fileSize?: boolean
    fileType?: boolean
    uploadedBy?: boolean
    url?: boolean
    localPath?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type NeedAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "needId" | "fileName" | "fileSize" | "fileType" | "uploadedBy" | "url" | "localPath" | "createdAt" | "syncId" | "needsSync", ExtArgs["result"]["needAttachment"]>
  export type NeedAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    need?: boolean | NeedDefaultArgs<ExtArgs>
  }
  export type NeedAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    need?: boolean | NeedDefaultArgs<ExtArgs>
  }
  export type NeedAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    need?: boolean | NeedDefaultArgs<ExtArgs>
  }

  export type $NeedAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NeedAttachment"
    objects: {
      need: Prisma.$NeedPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      needId: string
      fileName: string
      fileSize: number
      fileType: string
      uploadedBy: string
      url: string
      localPath: string | null
      createdAt: Date
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["needAttachment"]>
    composites: {}
  }

  type NeedAttachmentGetPayload<S extends boolean | null | undefined | NeedAttachmentDefaultArgs> = $Result.GetResult<Prisma.$NeedAttachmentPayload, S>

  type NeedAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NeedAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NeedAttachmentCountAggregateInputType | true
    }

  export interface NeedAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NeedAttachment'], meta: { name: 'NeedAttachment' } }
    /**
     * Find zero or one NeedAttachment that matches the filter.
     * @param {NeedAttachmentFindUniqueArgs} args - Arguments to find a NeedAttachment
     * @example
     * // Get one NeedAttachment
     * const needAttachment = await prisma.needAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NeedAttachmentFindUniqueArgs>(args: SelectSubset<T, NeedAttachmentFindUniqueArgs<ExtArgs>>): Prisma__NeedAttachmentClient<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NeedAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NeedAttachmentFindUniqueOrThrowArgs} args - Arguments to find a NeedAttachment
     * @example
     * // Get one NeedAttachment
     * const needAttachment = await prisma.needAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NeedAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, NeedAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NeedAttachmentClient<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NeedAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedAttachmentFindFirstArgs} args - Arguments to find a NeedAttachment
     * @example
     * // Get one NeedAttachment
     * const needAttachment = await prisma.needAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NeedAttachmentFindFirstArgs>(args?: SelectSubset<T, NeedAttachmentFindFirstArgs<ExtArgs>>): Prisma__NeedAttachmentClient<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NeedAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedAttachmentFindFirstOrThrowArgs} args - Arguments to find a NeedAttachment
     * @example
     * // Get one NeedAttachment
     * const needAttachment = await prisma.needAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NeedAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, NeedAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__NeedAttachmentClient<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NeedAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NeedAttachments
     * const needAttachments = await prisma.needAttachment.findMany()
     * 
     * // Get first 10 NeedAttachments
     * const needAttachments = await prisma.needAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const needAttachmentWithIdOnly = await prisma.needAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NeedAttachmentFindManyArgs>(args?: SelectSubset<T, NeedAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NeedAttachment.
     * @param {NeedAttachmentCreateArgs} args - Arguments to create a NeedAttachment.
     * @example
     * // Create one NeedAttachment
     * const NeedAttachment = await prisma.needAttachment.create({
     *   data: {
     *     // ... data to create a NeedAttachment
     *   }
     * })
     * 
     */
    create<T extends NeedAttachmentCreateArgs>(args: SelectSubset<T, NeedAttachmentCreateArgs<ExtArgs>>): Prisma__NeedAttachmentClient<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NeedAttachments.
     * @param {NeedAttachmentCreateManyArgs} args - Arguments to create many NeedAttachments.
     * @example
     * // Create many NeedAttachments
     * const needAttachment = await prisma.needAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NeedAttachmentCreateManyArgs>(args?: SelectSubset<T, NeedAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NeedAttachments and returns the data saved in the database.
     * @param {NeedAttachmentCreateManyAndReturnArgs} args - Arguments to create many NeedAttachments.
     * @example
     * // Create many NeedAttachments
     * const needAttachment = await prisma.needAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NeedAttachments and only return the `id`
     * const needAttachmentWithIdOnly = await prisma.needAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NeedAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, NeedAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NeedAttachment.
     * @param {NeedAttachmentDeleteArgs} args - Arguments to delete one NeedAttachment.
     * @example
     * // Delete one NeedAttachment
     * const NeedAttachment = await prisma.needAttachment.delete({
     *   where: {
     *     // ... filter to delete one NeedAttachment
     *   }
     * })
     * 
     */
    delete<T extends NeedAttachmentDeleteArgs>(args: SelectSubset<T, NeedAttachmentDeleteArgs<ExtArgs>>): Prisma__NeedAttachmentClient<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NeedAttachment.
     * @param {NeedAttachmentUpdateArgs} args - Arguments to update one NeedAttachment.
     * @example
     * // Update one NeedAttachment
     * const needAttachment = await prisma.needAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NeedAttachmentUpdateArgs>(args: SelectSubset<T, NeedAttachmentUpdateArgs<ExtArgs>>): Prisma__NeedAttachmentClient<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NeedAttachments.
     * @param {NeedAttachmentDeleteManyArgs} args - Arguments to filter NeedAttachments to delete.
     * @example
     * // Delete a few NeedAttachments
     * const { count } = await prisma.needAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NeedAttachmentDeleteManyArgs>(args?: SelectSubset<T, NeedAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NeedAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NeedAttachments
     * const needAttachment = await prisma.needAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NeedAttachmentUpdateManyArgs>(args: SelectSubset<T, NeedAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NeedAttachments and returns the data updated in the database.
     * @param {NeedAttachmentUpdateManyAndReturnArgs} args - Arguments to update many NeedAttachments.
     * @example
     * // Update many NeedAttachments
     * const needAttachment = await prisma.needAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NeedAttachments and only return the `id`
     * const needAttachmentWithIdOnly = await prisma.needAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NeedAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, NeedAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NeedAttachment.
     * @param {NeedAttachmentUpsertArgs} args - Arguments to update or create a NeedAttachment.
     * @example
     * // Update or create a NeedAttachment
     * const needAttachment = await prisma.needAttachment.upsert({
     *   create: {
     *     // ... data to create a NeedAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NeedAttachment we want to update
     *   }
     * })
     */
    upsert<T extends NeedAttachmentUpsertArgs>(args: SelectSubset<T, NeedAttachmentUpsertArgs<ExtArgs>>): Prisma__NeedAttachmentClient<$Result.GetResult<Prisma.$NeedAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NeedAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedAttachmentCountArgs} args - Arguments to filter NeedAttachments to count.
     * @example
     * // Count the number of NeedAttachments
     * const count = await prisma.needAttachment.count({
     *   where: {
     *     // ... the filter for the NeedAttachments we want to count
     *   }
     * })
    **/
    count<T extends NeedAttachmentCountArgs>(
      args?: Subset<T, NeedAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NeedAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NeedAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NeedAttachmentAggregateArgs>(args: Subset<T, NeedAttachmentAggregateArgs>): Prisma.PrismaPromise<GetNeedAttachmentAggregateType<T>>

    /**
     * Group by NeedAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NeedAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NeedAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NeedAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: NeedAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NeedAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNeedAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NeedAttachment model
   */
  readonly fields: NeedAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NeedAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NeedAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    need<T extends NeedDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NeedDefaultArgs<ExtArgs>>): Prisma__NeedClient<$Result.GetResult<Prisma.$NeedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NeedAttachment model
   */
  interface NeedAttachmentFieldRefs {
    readonly id: FieldRef<"NeedAttachment", 'String'>
    readonly needId: FieldRef<"NeedAttachment", 'String'>
    readonly fileName: FieldRef<"NeedAttachment", 'String'>
    readonly fileSize: FieldRef<"NeedAttachment", 'Int'>
    readonly fileType: FieldRef<"NeedAttachment", 'String'>
    readonly uploadedBy: FieldRef<"NeedAttachment", 'String'>
    readonly url: FieldRef<"NeedAttachment", 'String'>
    readonly localPath: FieldRef<"NeedAttachment", 'String'>
    readonly createdAt: FieldRef<"NeedAttachment", 'DateTime'>
    readonly syncId: FieldRef<"NeedAttachment", 'String'>
    readonly needsSync: FieldRef<"NeedAttachment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * NeedAttachment findUnique
   */
  export type NeedAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which NeedAttachment to fetch.
     */
    where: NeedAttachmentWhereUniqueInput
  }

  /**
   * NeedAttachment findUniqueOrThrow
   */
  export type NeedAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which NeedAttachment to fetch.
     */
    where: NeedAttachmentWhereUniqueInput
  }

  /**
   * NeedAttachment findFirst
   */
  export type NeedAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which NeedAttachment to fetch.
     */
    where?: NeedAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeedAttachments to fetch.
     */
    orderBy?: NeedAttachmentOrderByWithRelationInput | NeedAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NeedAttachments.
     */
    cursor?: NeedAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeedAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeedAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NeedAttachments.
     */
    distinct?: NeedAttachmentScalarFieldEnum | NeedAttachmentScalarFieldEnum[]
  }

  /**
   * NeedAttachment findFirstOrThrow
   */
  export type NeedAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which NeedAttachment to fetch.
     */
    where?: NeedAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeedAttachments to fetch.
     */
    orderBy?: NeedAttachmentOrderByWithRelationInput | NeedAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NeedAttachments.
     */
    cursor?: NeedAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeedAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeedAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NeedAttachments.
     */
    distinct?: NeedAttachmentScalarFieldEnum | NeedAttachmentScalarFieldEnum[]
  }

  /**
   * NeedAttachment findMany
   */
  export type NeedAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which NeedAttachments to fetch.
     */
    where?: NeedAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NeedAttachments to fetch.
     */
    orderBy?: NeedAttachmentOrderByWithRelationInput | NeedAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NeedAttachments.
     */
    cursor?: NeedAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NeedAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NeedAttachments.
     */
    skip?: number
    distinct?: NeedAttachmentScalarFieldEnum | NeedAttachmentScalarFieldEnum[]
  }

  /**
   * NeedAttachment create
   */
  export type NeedAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a NeedAttachment.
     */
    data: XOR<NeedAttachmentCreateInput, NeedAttachmentUncheckedCreateInput>
  }

  /**
   * NeedAttachment createMany
   */
  export type NeedAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NeedAttachments.
     */
    data: NeedAttachmentCreateManyInput | NeedAttachmentCreateManyInput[]
  }

  /**
   * NeedAttachment createManyAndReturn
   */
  export type NeedAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many NeedAttachments.
     */
    data: NeedAttachmentCreateManyInput | NeedAttachmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NeedAttachment update
   */
  export type NeedAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a NeedAttachment.
     */
    data: XOR<NeedAttachmentUpdateInput, NeedAttachmentUncheckedUpdateInput>
    /**
     * Choose, which NeedAttachment to update.
     */
    where: NeedAttachmentWhereUniqueInput
  }

  /**
   * NeedAttachment updateMany
   */
  export type NeedAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NeedAttachments.
     */
    data: XOR<NeedAttachmentUpdateManyMutationInput, NeedAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which NeedAttachments to update
     */
    where?: NeedAttachmentWhereInput
    /**
     * Limit how many NeedAttachments to update.
     */
    limit?: number
  }

  /**
   * NeedAttachment updateManyAndReturn
   */
  export type NeedAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update NeedAttachments.
     */
    data: XOR<NeedAttachmentUpdateManyMutationInput, NeedAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which NeedAttachments to update
     */
    where?: NeedAttachmentWhereInput
    /**
     * Limit how many NeedAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NeedAttachment upsert
   */
  export type NeedAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the NeedAttachment to update in case it exists.
     */
    where: NeedAttachmentWhereUniqueInput
    /**
     * In case the NeedAttachment found by the `where` argument doesn't exist, create a new NeedAttachment with this data.
     */
    create: XOR<NeedAttachmentCreateInput, NeedAttachmentUncheckedCreateInput>
    /**
     * In case the NeedAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NeedAttachmentUpdateInput, NeedAttachmentUncheckedUpdateInput>
  }

  /**
   * NeedAttachment delete
   */
  export type NeedAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
    /**
     * Filter which NeedAttachment to delete.
     */
    where: NeedAttachmentWhereUniqueInput
  }

  /**
   * NeedAttachment deleteMany
   */
  export type NeedAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NeedAttachments to delete
     */
    where?: NeedAttachmentWhereInput
    /**
     * Limit how many NeedAttachments to delete.
     */
    limit?: number
  }

  /**
   * NeedAttachment without action
   */
  export type NeedAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NeedAttachment
     */
    select?: NeedAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NeedAttachment
     */
    omit?: NeedAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NeedAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceClient
   */

  export type AggregateInvoiceClient = {
    _count: InvoiceClientCountAggregateOutputType | null
    _min: InvoiceClientMinAggregateOutputType | null
    _max: InvoiceClientMaxAggregateOutputType | null
  }

  export type InvoiceClientMinAggregateOutputType = {
    id: string | null
    company: string | null
    companyName: string | null
    contactName: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    country: string | null
    taxNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type InvoiceClientMaxAggregateOutputType = {
    id: string | null
    company: string | null
    companyName: string | null
    contactName: string | null
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    country: string | null
    taxNumber: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type InvoiceClientCountAggregateOutputType = {
    id: number
    company: number
    companyName: number
    contactName: number
    email: number
    phone: number
    address: number
    city: number
    country: number
    taxNumber: number
    notes: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    needsSync: number
    _all: number
  }


  export type InvoiceClientMinAggregateInputType = {
    id?: true
    company?: true
    companyName?: true
    contactName?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    country?: true
    taxNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type InvoiceClientMaxAggregateInputType = {
    id?: true
    company?: true
    companyName?: true
    contactName?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    country?: true
    taxNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type InvoiceClientCountAggregateInputType = {
    id?: true
    company?: true
    companyName?: true
    contactName?: true
    email?: true
    phone?: true
    address?: true
    city?: true
    country?: true
    taxNumber?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
    _all?: true
  }

  export type InvoiceClientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceClient to aggregate.
     */
    where?: InvoiceClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceClients to fetch.
     */
    orderBy?: InvoiceClientOrderByWithRelationInput | InvoiceClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceClients
    **/
    _count?: true | InvoiceClientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceClientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceClientMaxAggregateInputType
  }

  export type GetInvoiceClientAggregateType<T extends InvoiceClientAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceClient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceClient[P]>
      : GetScalarType<T[P], AggregateInvoiceClient[P]>
  }




  export type InvoiceClientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceClientWhereInput
    orderBy?: InvoiceClientOrderByWithAggregationInput | InvoiceClientOrderByWithAggregationInput[]
    by: InvoiceClientScalarFieldEnum[] | InvoiceClientScalarFieldEnum
    having?: InvoiceClientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceClientCountAggregateInputType | true
    _min?: InvoiceClientMinAggregateInputType
    _max?: InvoiceClientMaxAggregateInputType
  }

  export type InvoiceClientGroupByOutputType = {
    id: string
    company: string
    companyName: string
    contactName: string
    email: string | null
    phone: string | null
    address: string | null
    city: string | null
    country: string | null
    taxNumber: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean
    _count: InvoiceClientCountAggregateOutputType | null
    _min: InvoiceClientMinAggregateOutputType | null
    _max: InvoiceClientMaxAggregateOutputType | null
  }

  type GetInvoiceClientGroupByPayload<T extends InvoiceClientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceClientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceClientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceClientGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceClientGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceClientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    companyName?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    taxNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    invoices?: boolean | InvoiceClient$invoicesArgs<ExtArgs>
    _count?: boolean | InvoiceClientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceClient"]>

  export type InvoiceClientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    companyName?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    taxNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }, ExtArgs["result"]["invoiceClient"]>

  export type InvoiceClientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    companyName?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    taxNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }, ExtArgs["result"]["invoiceClient"]>

  export type InvoiceClientSelectScalar = {
    id?: boolean
    company?: boolean
    companyName?: boolean
    contactName?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    taxNumber?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }

  export type InvoiceClientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company" | "companyName" | "contactName" | "email" | "phone" | "address" | "city" | "country" | "taxNumber" | "notes" | "createdAt" | "updatedAt" | "syncId" | "lastSynced" | "needsSync", ExtArgs["result"]["invoiceClient"]>
  export type InvoiceClientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoices?: boolean | InvoiceClient$invoicesArgs<ExtArgs>
    _count?: boolean | InvoiceClientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceClientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InvoiceClientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InvoiceClientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceClient"
    objects: {
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company: string
      companyName: string
      contactName: string
      email: string | null
      phone: string | null
      address: string | null
      city: string | null
      country: string | null
      taxNumber: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
      needsSync: boolean
    }, ExtArgs["result"]["invoiceClient"]>
    composites: {}
  }

  type InvoiceClientGetPayload<S extends boolean | null | undefined | InvoiceClientDefaultArgs> = $Result.GetResult<Prisma.$InvoiceClientPayload, S>

  type InvoiceClientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceClientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceClientCountAggregateInputType | true
    }

  export interface InvoiceClientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceClient'], meta: { name: 'InvoiceClient' } }
    /**
     * Find zero or one InvoiceClient that matches the filter.
     * @param {InvoiceClientFindUniqueArgs} args - Arguments to find a InvoiceClient
     * @example
     * // Get one InvoiceClient
     * const invoiceClient = await prisma.invoiceClient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceClientFindUniqueArgs>(args: SelectSubset<T, InvoiceClientFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClientClient<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceClient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceClientFindUniqueOrThrowArgs} args - Arguments to find a InvoiceClient
     * @example
     * // Get one InvoiceClient
     * const invoiceClient = await prisma.invoiceClient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceClientFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceClientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClientClient<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceClient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceClientFindFirstArgs} args - Arguments to find a InvoiceClient
     * @example
     * // Get one InvoiceClient
     * const invoiceClient = await prisma.invoiceClient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceClientFindFirstArgs>(args?: SelectSubset<T, InvoiceClientFindFirstArgs<ExtArgs>>): Prisma__InvoiceClientClient<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceClient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceClientFindFirstOrThrowArgs} args - Arguments to find a InvoiceClient
     * @example
     * // Get one InvoiceClient
     * const invoiceClient = await prisma.invoiceClient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceClientFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceClientFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClientClient<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceClients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceClientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceClients
     * const invoiceClients = await prisma.invoiceClient.findMany()
     * 
     * // Get first 10 InvoiceClients
     * const invoiceClients = await prisma.invoiceClient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceClientWithIdOnly = await prisma.invoiceClient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceClientFindManyArgs>(args?: SelectSubset<T, InvoiceClientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceClient.
     * @param {InvoiceClientCreateArgs} args - Arguments to create a InvoiceClient.
     * @example
     * // Create one InvoiceClient
     * const InvoiceClient = await prisma.invoiceClient.create({
     *   data: {
     *     // ... data to create a InvoiceClient
     *   }
     * })
     * 
     */
    create<T extends InvoiceClientCreateArgs>(args: SelectSubset<T, InvoiceClientCreateArgs<ExtArgs>>): Prisma__InvoiceClientClient<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceClients.
     * @param {InvoiceClientCreateManyArgs} args - Arguments to create many InvoiceClients.
     * @example
     * // Create many InvoiceClients
     * const invoiceClient = await prisma.invoiceClient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceClientCreateManyArgs>(args?: SelectSubset<T, InvoiceClientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceClients and returns the data saved in the database.
     * @param {InvoiceClientCreateManyAndReturnArgs} args - Arguments to create many InvoiceClients.
     * @example
     * // Create many InvoiceClients
     * const invoiceClient = await prisma.invoiceClient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceClients and only return the `id`
     * const invoiceClientWithIdOnly = await prisma.invoiceClient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceClientCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceClientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceClient.
     * @param {InvoiceClientDeleteArgs} args - Arguments to delete one InvoiceClient.
     * @example
     * // Delete one InvoiceClient
     * const InvoiceClient = await prisma.invoiceClient.delete({
     *   where: {
     *     // ... filter to delete one InvoiceClient
     *   }
     * })
     * 
     */
    delete<T extends InvoiceClientDeleteArgs>(args: SelectSubset<T, InvoiceClientDeleteArgs<ExtArgs>>): Prisma__InvoiceClientClient<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceClient.
     * @param {InvoiceClientUpdateArgs} args - Arguments to update one InvoiceClient.
     * @example
     * // Update one InvoiceClient
     * const invoiceClient = await prisma.invoiceClient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceClientUpdateArgs>(args: SelectSubset<T, InvoiceClientUpdateArgs<ExtArgs>>): Prisma__InvoiceClientClient<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceClients.
     * @param {InvoiceClientDeleteManyArgs} args - Arguments to filter InvoiceClients to delete.
     * @example
     * // Delete a few InvoiceClients
     * const { count } = await prisma.invoiceClient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceClientDeleteManyArgs>(args?: SelectSubset<T, InvoiceClientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceClientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceClients
     * const invoiceClient = await prisma.invoiceClient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceClientUpdateManyArgs>(args: SelectSubset<T, InvoiceClientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceClients and returns the data updated in the database.
     * @param {InvoiceClientUpdateManyAndReturnArgs} args - Arguments to update many InvoiceClients.
     * @example
     * // Update many InvoiceClients
     * const invoiceClient = await prisma.invoiceClient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceClients and only return the `id`
     * const invoiceClientWithIdOnly = await prisma.invoiceClient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceClientUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceClientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceClient.
     * @param {InvoiceClientUpsertArgs} args - Arguments to update or create a InvoiceClient.
     * @example
     * // Update or create a InvoiceClient
     * const invoiceClient = await prisma.invoiceClient.upsert({
     *   create: {
     *     // ... data to create a InvoiceClient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceClient we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceClientUpsertArgs>(args: SelectSubset<T, InvoiceClientUpsertArgs<ExtArgs>>): Prisma__InvoiceClientClient<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceClients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceClientCountArgs} args - Arguments to filter InvoiceClients to count.
     * @example
     * // Count the number of InvoiceClients
     * const count = await prisma.invoiceClient.count({
     *   where: {
     *     // ... the filter for the InvoiceClients we want to count
     *   }
     * })
    **/
    count<T extends InvoiceClientCountArgs>(
      args?: Subset<T, InvoiceClientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceClientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceClientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceClientAggregateArgs>(args: Subset<T, InvoiceClientAggregateArgs>): Prisma.PrismaPromise<GetInvoiceClientAggregateType<T>>

    /**
     * Group by InvoiceClient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceClientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceClientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceClientGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceClientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceClientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceClientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceClient model
   */
  readonly fields: InvoiceClientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceClient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoices<T extends InvoiceClient$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceClient$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceClient model
   */
  interface InvoiceClientFieldRefs {
    readonly id: FieldRef<"InvoiceClient", 'String'>
    readonly company: FieldRef<"InvoiceClient", 'String'>
    readonly companyName: FieldRef<"InvoiceClient", 'String'>
    readonly contactName: FieldRef<"InvoiceClient", 'String'>
    readonly email: FieldRef<"InvoiceClient", 'String'>
    readonly phone: FieldRef<"InvoiceClient", 'String'>
    readonly address: FieldRef<"InvoiceClient", 'String'>
    readonly city: FieldRef<"InvoiceClient", 'String'>
    readonly country: FieldRef<"InvoiceClient", 'String'>
    readonly taxNumber: FieldRef<"InvoiceClient", 'String'>
    readonly notes: FieldRef<"InvoiceClient", 'String'>
    readonly createdAt: FieldRef<"InvoiceClient", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceClient", 'DateTime'>
    readonly syncId: FieldRef<"InvoiceClient", 'String'>
    readonly lastSynced: FieldRef<"InvoiceClient", 'DateTime'>
    readonly needsSync: FieldRef<"InvoiceClient", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceClient findUnique
   */
  export type InvoiceClientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceClientInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceClient to fetch.
     */
    where: InvoiceClientWhereUniqueInput
  }

  /**
   * InvoiceClient findUniqueOrThrow
   */
  export type InvoiceClientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceClientInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceClient to fetch.
     */
    where: InvoiceClientWhereUniqueInput
  }

  /**
   * InvoiceClient findFirst
   */
  export type InvoiceClientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceClientInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceClient to fetch.
     */
    where?: InvoiceClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceClients to fetch.
     */
    orderBy?: InvoiceClientOrderByWithRelationInput | InvoiceClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceClients.
     */
    cursor?: InvoiceClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceClients.
     */
    distinct?: InvoiceClientScalarFieldEnum | InvoiceClientScalarFieldEnum[]
  }

  /**
   * InvoiceClient findFirstOrThrow
   */
  export type InvoiceClientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceClientInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceClient to fetch.
     */
    where?: InvoiceClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceClients to fetch.
     */
    orderBy?: InvoiceClientOrderByWithRelationInput | InvoiceClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceClients.
     */
    cursor?: InvoiceClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceClients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceClients.
     */
    distinct?: InvoiceClientScalarFieldEnum | InvoiceClientScalarFieldEnum[]
  }

  /**
   * InvoiceClient findMany
   */
  export type InvoiceClientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceClientInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceClients to fetch.
     */
    where?: InvoiceClientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceClients to fetch.
     */
    orderBy?: InvoiceClientOrderByWithRelationInput | InvoiceClientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceClients.
     */
    cursor?: InvoiceClientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceClients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceClients.
     */
    skip?: number
    distinct?: InvoiceClientScalarFieldEnum | InvoiceClientScalarFieldEnum[]
  }

  /**
   * InvoiceClient create
   */
  export type InvoiceClientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceClientInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceClient.
     */
    data: XOR<InvoiceClientCreateInput, InvoiceClientUncheckedCreateInput>
  }

  /**
   * InvoiceClient createMany
   */
  export type InvoiceClientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceClients.
     */
    data: InvoiceClientCreateManyInput | InvoiceClientCreateManyInput[]
  }

  /**
   * InvoiceClient createManyAndReturn
   */
  export type InvoiceClientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceClients.
     */
    data: InvoiceClientCreateManyInput | InvoiceClientCreateManyInput[]
  }

  /**
   * InvoiceClient update
   */
  export type InvoiceClientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceClientInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceClient.
     */
    data: XOR<InvoiceClientUpdateInput, InvoiceClientUncheckedUpdateInput>
    /**
     * Choose, which InvoiceClient to update.
     */
    where: InvoiceClientWhereUniqueInput
  }

  /**
   * InvoiceClient updateMany
   */
  export type InvoiceClientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceClients.
     */
    data: XOR<InvoiceClientUpdateManyMutationInput, InvoiceClientUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceClients to update
     */
    where?: InvoiceClientWhereInput
    /**
     * Limit how many InvoiceClients to update.
     */
    limit?: number
  }

  /**
   * InvoiceClient updateManyAndReturn
   */
  export type InvoiceClientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceClients.
     */
    data: XOR<InvoiceClientUpdateManyMutationInput, InvoiceClientUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceClients to update
     */
    where?: InvoiceClientWhereInput
    /**
     * Limit how many InvoiceClients to update.
     */
    limit?: number
  }

  /**
   * InvoiceClient upsert
   */
  export type InvoiceClientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceClientInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceClient to update in case it exists.
     */
    where: InvoiceClientWhereUniqueInput
    /**
     * In case the InvoiceClient found by the `where` argument doesn't exist, create a new InvoiceClient with this data.
     */
    create: XOR<InvoiceClientCreateInput, InvoiceClientUncheckedCreateInput>
    /**
     * In case the InvoiceClient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceClientUpdateInput, InvoiceClientUncheckedUpdateInput>
  }

  /**
   * InvoiceClient delete
   */
  export type InvoiceClientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceClientInclude<ExtArgs> | null
    /**
     * Filter which InvoiceClient to delete.
     */
    where: InvoiceClientWhereUniqueInput
  }

  /**
   * InvoiceClient deleteMany
   */
  export type InvoiceClientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceClients to delete
     */
    where?: InvoiceClientWhereInput
    /**
     * Limit how many InvoiceClients to delete.
     */
    limit?: number
  }

  /**
   * InvoiceClient.invoices
   */
  export type InvoiceClient$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * InvoiceClient without action
   */
  export type InvoiceClientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceClient
     */
    select?: InvoiceClientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceClient
     */
    omit?: InvoiceClientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceClientInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    total: number | null
    placementDeduction: number | null
    transfertDeduction: number | null
    managementFeeRate: number | null
    commissionRate: number | null
    paidAmount: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    total: number | null
    placementDeduction: number | null
    transfertDeduction: number | null
    managementFeeRate: number | null
    commissionRate: number | null
    paidAmount: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    template: string | null
    company: string | null
    clientId: string | null
    clientSnapshot: string | null
    issueDate: Date | null
    dueDate: Date | null
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    total: number | null
    serviceType: string | null
    templateCode: string | null
    placementTVAEnabled: boolean | null
    chargesTTCMode: boolean | null
    placementDeduction: number | null
    enablePlacementDeduction: boolean | null
    transfertDeduction: number | null
    enableTransfertDeduction: boolean | null
    projectDescription: string | null
    projectName: string | null
    managementFeeRate: number | null
    commissionRate: number | null
    acomptes: string | null
    status: string | null
    paymentTerms: string | null
    paymentMethod: string | null
    paidAt: Date | null
    paidAmount: number | null
    notes: string | null
    publicNotes: string | null
    createdBy: string | null
    createdByInitials: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    invoiceNumber: string | null
    template: string | null
    company: string | null
    clientId: string | null
    clientSnapshot: string | null
    issueDate: Date | null
    dueDate: Date | null
    subtotal: number | null
    taxRate: number | null
    taxAmount: number | null
    total: number | null
    serviceType: string | null
    templateCode: string | null
    placementTVAEnabled: boolean | null
    chargesTTCMode: boolean | null
    placementDeduction: number | null
    enablePlacementDeduction: boolean | null
    transfertDeduction: number | null
    enableTransfertDeduction: boolean | null
    projectDescription: string | null
    projectName: string | null
    managementFeeRate: number | null
    commissionRate: number | null
    acomptes: string | null
    status: string | null
    paymentTerms: string | null
    paymentMethod: string | null
    paidAt: Date | null
    paidAmount: number | null
    notes: string | null
    publicNotes: string | null
    createdBy: string | null
    createdByInitials: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    invoiceNumber: number
    template: number
    company: number
    clientId: number
    clientSnapshot: number
    issueDate: number
    dueDate: number
    subtotal: number
    taxRate: number
    taxAmount: number
    total: number
    serviceType: number
    templateCode: number
    placementTVAEnabled: number
    chargesTTCMode: number
    placementDeduction: number
    enablePlacementDeduction: number
    transfertDeduction: number
    enableTransfertDeduction: number
    projectDescription: number
    projectName: number
    managementFeeRate: number
    commissionRate: number
    acomptes: number
    status: number
    paymentTerms: number
    paymentMethod: number
    paidAt: number
    paidAmount: number
    notes: number
    publicNotes: number
    createdBy: number
    createdByInitials: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    needsSync: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    placementDeduction?: true
    transfertDeduction?: true
    managementFeeRate?: true
    commissionRate?: true
    paidAmount?: true
  }

  export type InvoiceSumAggregateInputType = {
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    placementDeduction?: true
    transfertDeduction?: true
    managementFeeRate?: true
    commissionRate?: true
    paidAmount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    invoiceNumber?: true
    template?: true
    company?: true
    clientId?: true
    clientSnapshot?: true
    issueDate?: true
    dueDate?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    serviceType?: true
    templateCode?: true
    placementTVAEnabled?: true
    chargesTTCMode?: true
    placementDeduction?: true
    enablePlacementDeduction?: true
    transfertDeduction?: true
    enableTransfertDeduction?: true
    projectDescription?: true
    projectName?: true
    managementFeeRate?: true
    commissionRate?: true
    acomptes?: true
    status?: true
    paymentTerms?: true
    paymentMethod?: true
    paidAt?: true
    paidAmount?: true
    notes?: true
    publicNotes?: true
    createdBy?: true
    createdByInitials?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    invoiceNumber?: true
    template?: true
    company?: true
    clientId?: true
    clientSnapshot?: true
    issueDate?: true
    dueDate?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    serviceType?: true
    templateCode?: true
    placementTVAEnabled?: true
    chargesTTCMode?: true
    placementDeduction?: true
    enablePlacementDeduction?: true
    transfertDeduction?: true
    enableTransfertDeduction?: true
    projectDescription?: true
    projectName?: true
    managementFeeRate?: true
    commissionRate?: true
    acomptes?: true
    status?: true
    paymentTerms?: true
    paymentMethod?: true
    paidAt?: true
    paidAmount?: true
    notes?: true
    publicNotes?: true
    createdBy?: true
    createdByInitials?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    invoiceNumber?: true
    template?: true
    company?: true
    clientId?: true
    clientSnapshot?: true
    issueDate?: true
    dueDate?: true
    subtotal?: true
    taxRate?: true
    taxAmount?: true
    total?: true
    serviceType?: true
    templateCode?: true
    placementTVAEnabled?: true
    chargesTTCMode?: true
    placementDeduction?: true
    enablePlacementDeduction?: true
    transfertDeduction?: true
    enableTransfertDeduction?: true
    projectDescription?: true
    projectName?: true
    managementFeeRate?: true
    commissionRate?: true
    acomptes?: true
    status?: true
    paymentTerms?: true
    paymentMethod?: true
    paidAt?: true
    paidAmount?: true
    notes?: true
    publicNotes?: true
    createdBy?: true
    createdByInitials?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    invoiceNumber: string
    template: string
    company: string
    clientId: string
    clientSnapshot: string | null
    issueDate: Date
    dueDate: Date
    subtotal: number
    taxRate: number
    taxAmount: number
    total: number
    serviceType: string | null
    templateCode: string | null
    placementTVAEnabled: boolean
    chargesTTCMode: boolean
    placementDeduction: number
    enablePlacementDeduction: boolean
    transfertDeduction: number
    enableTransfertDeduction: boolean
    projectDescription: string | null
    projectName: string | null
    managementFeeRate: number | null
    commissionRate: number | null
    acomptes: string | null
    status: string
    paymentTerms: string | null
    paymentMethod: string | null
    paidAt: Date | null
    paidAmount: number
    notes: string | null
    publicNotes: string | null
    createdBy: string
    createdByInitials: string | null
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    template?: boolean
    company?: boolean
    clientId?: boolean
    clientSnapshot?: boolean
    issueDate?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    serviceType?: boolean
    templateCode?: boolean
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: boolean
    enablePlacementDeduction?: boolean
    transfertDeduction?: boolean
    enableTransfertDeduction?: boolean
    projectDescription?: boolean
    projectName?: boolean
    managementFeeRate?: boolean
    commissionRate?: boolean
    acomptes?: boolean
    status?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    paidAt?: boolean
    paidAmount?: boolean
    notes?: boolean
    publicNotes?: boolean
    createdBy?: boolean
    createdByInitials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    client?: boolean | InvoiceClientDefaultArgs<ExtArgs>
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    sections?: boolean | Invoice$sectionsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    template?: boolean
    company?: boolean
    clientId?: boolean
    clientSnapshot?: boolean
    issueDate?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    serviceType?: boolean
    templateCode?: boolean
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: boolean
    enablePlacementDeduction?: boolean
    transfertDeduction?: boolean
    enableTransfertDeduction?: boolean
    projectDescription?: boolean
    projectName?: boolean
    managementFeeRate?: boolean
    commissionRate?: boolean
    acomptes?: boolean
    status?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    paidAt?: boolean
    paidAmount?: boolean
    notes?: boolean
    publicNotes?: boolean
    createdBy?: boolean
    createdByInitials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    client?: boolean | InvoiceClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceNumber?: boolean
    template?: boolean
    company?: boolean
    clientId?: boolean
    clientSnapshot?: boolean
    issueDate?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    serviceType?: boolean
    templateCode?: boolean
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: boolean
    enablePlacementDeduction?: boolean
    transfertDeduction?: boolean
    enableTransfertDeduction?: boolean
    projectDescription?: boolean
    projectName?: boolean
    managementFeeRate?: boolean
    commissionRate?: boolean
    acomptes?: boolean
    status?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    paidAt?: boolean
    paidAmount?: boolean
    notes?: boolean
    publicNotes?: boolean
    createdBy?: boolean
    createdByInitials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    client?: boolean | InvoiceClientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    invoiceNumber?: boolean
    template?: boolean
    company?: boolean
    clientId?: boolean
    clientSnapshot?: boolean
    issueDate?: boolean
    dueDate?: boolean
    subtotal?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    total?: boolean
    serviceType?: boolean
    templateCode?: boolean
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: boolean
    enablePlacementDeduction?: boolean
    transfertDeduction?: boolean
    enableTransfertDeduction?: boolean
    projectDescription?: boolean
    projectName?: boolean
    managementFeeRate?: boolean
    commissionRate?: boolean
    acomptes?: boolean
    status?: boolean
    paymentTerms?: boolean
    paymentMethod?: boolean
    paidAt?: boolean
    paidAmount?: boolean
    notes?: boolean
    publicNotes?: boolean
    createdBy?: boolean
    createdByInitials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceNumber" | "template" | "company" | "clientId" | "clientSnapshot" | "issueDate" | "dueDate" | "subtotal" | "taxRate" | "taxAmount" | "total" | "serviceType" | "templateCode" | "placementTVAEnabled" | "chargesTTCMode" | "placementDeduction" | "enablePlacementDeduction" | "transfertDeduction" | "enableTransfertDeduction" | "projectDescription" | "projectName" | "managementFeeRate" | "commissionRate" | "acomptes" | "status" | "paymentTerms" | "paymentMethod" | "paidAt" | "paidAmount" | "notes" | "publicNotes" | "createdBy" | "createdByInitials" | "createdAt" | "updatedAt" | "syncId" | "lastSynced" | "needsSync", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | InvoiceClientDefaultArgs<ExtArgs>
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    sections?: boolean | Invoice$sectionsArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | InvoiceClientDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | InvoiceClientDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      client: Prisma.$InvoiceClientPayload<ExtArgs>
      lines: Prisma.$InvoiceLinePayload<ExtArgs>[]
      sections: Prisma.$InvoiceSectionPayload<ExtArgs>[]
      payments: Prisma.$InvoicePaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceNumber: string
      template: string
      company: string
      clientId: string
      clientSnapshot: string | null
      issueDate: Date
      dueDate: Date
      subtotal: number
      taxRate: number
      taxAmount: number
      total: number
      serviceType: string | null
      templateCode: string | null
      placementTVAEnabled: boolean
      chargesTTCMode: boolean
      placementDeduction: number
      enablePlacementDeduction: boolean
      transfertDeduction: number
      enableTransfertDeduction: boolean
      projectDescription: string | null
      projectName: string | null
      managementFeeRate: number | null
      commissionRate: number | null
      acomptes: string | null
      status: string
      paymentTerms: string | null
      paymentMethod: string | null
      paidAt: Date | null
      paidAmount: number
      notes: string | null
      publicNotes: string | null
      createdBy: string
      createdByInitials: string | null
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
      needsSync: boolean
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends InvoiceClientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceClientDefaultArgs<ExtArgs>>): Prisma__InvoiceClientClient<$Result.GetResult<Prisma.$InvoiceClientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends Invoice$linesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sections<T extends Invoice$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly invoiceNumber: FieldRef<"Invoice", 'String'>
    readonly template: FieldRef<"Invoice", 'String'>
    readonly company: FieldRef<"Invoice", 'String'>
    readonly clientId: FieldRef<"Invoice", 'String'>
    readonly clientSnapshot: FieldRef<"Invoice", 'String'>
    readonly issueDate: FieldRef<"Invoice", 'DateTime'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly subtotal: FieldRef<"Invoice", 'Float'>
    readonly taxRate: FieldRef<"Invoice", 'Float'>
    readonly taxAmount: FieldRef<"Invoice", 'Float'>
    readonly total: FieldRef<"Invoice", 'Float'>
    readonly serviceType: FieldRef<"Invoice", 'String'>
    readonly templateCode: FieldRef<"Invoice", 'String'>
    readonly placementTVAEnabled: FieldRef<"Invoice", 'Boolean'>
    readonly chargesTTCMode: FieldRef<"Invoice", 'Boolean'>
    readonly placementDeduction: FieldRef<"Invoice", 'Float'>
    readonly enablePlacementDeduction: FieldRef<"Invoice", 'Boolean'>
    readonly transfertDeduction: FieldRef<"Invoice", 'Float'>
    readonly enableTransfertDeduction: FieldRef<"Invoice", 'Boolean'>
    readonly projectDescription: FieldRef<"Invoice", 'String'>
    readonly projectName: FieldRef<"Invoice", 'String'>
    readonly managementFeeRate: FieldRef<"Invoice", 'Float'>
    readonly commissionRate: FieldRef<"Invoice", 'Float'>
    readonly acomptes: FieldRef<"Invoice", 'String'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly paymentTerms: FieldRef<"Invoice", 'String'>
    readonly paymentMethod: FieldRef<"Invoice", 'String'>
    readonly paidAt: FieldRef<"Invoice", 'DateTime'>
    readonly paidAmount: FieldRef<"Invoice", 'Float'>
    readonly notes: FieldRef<"Invoice", 'String'>
    readonly publicNotes: FieldRef<"Invoice", 'String'>
    readonly createdBy: FieldRef<"Invoice", 'String'>
    readonly createdByInitials: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
    readonly syncId: FieldRef<"Invoice", 'String'>
    readonly lastSynced: FieldRef<"Invoice", 'DateTime'>
    readonly needsSync: FieldRef<"Invoice", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.lines
   */
  export type Invoice$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * Invoice.sections
   */
  export type Invoice$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
    where?: InvoiceSectionWhereInput
    orderBy?: InvoiceSectionOrderByWithRelationInput | InvoiceSectionOrderByWithRelationInput[]
    cursor?: InvoiceSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceSectionScalarFieldEnum | InvoiceSectionScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    where?: InvoicePaymentWhereInput
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    cursor?: InvoicePaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceLine
   */

  export type AggregateInvoiceLine = {
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  export type InvoiceLineAvgAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
    chargesTTC: number | null
    squareMeters: number | null
    days: number | null
    sortOrder: number | null
  }

  export type InvoiceLineSumAggregateOutputType = {
    quantity: number | null
    unitPrice: number | null
    total: number | null
    chargesTTC: number | null
    squareMeters: number | null
    days: number | null
    sortOrder: number | null
  }

  export type InvoiceLineMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
    chargesTTC: number | null
    squareMeters: number | null
    days: number | null
    sortOrder: number | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type InvoiceLineMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    quantity: number | null
    unitPrice: number | null
    total: number | null
    chargesTTC: number | null
    squareMeters: number | null
    days: number | null
    sortOrder: number | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type InvoiceLineCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    quantity: number
    unitPrice: number
    total: number
    chargesTTC: number
    squareMeters: number
    days: number
    sortOrder: number
    createdAt: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type InvoiceLineAvgAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
    chargesTTC?: true
    squareMeters?: true
    days?: true
    sortOrder?: true
  }

  export type InvoiceLineSumAggregateInputType = {
    quantity?: true
    unitPrice?: true
    total?: true
    chargesTTC?: true
    squareMeters?: true
    days?: true
    sortOrder?: true
  }

  export type InvoiceLineMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    chargesTTC?: true
    squareMeters?: true
    days?: true
    sortOrder?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type InvoiceLineMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    chargesTTC?: true
    squareMeters?: true
    days?: true
    sortOrder?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type InvoiceLineCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    quantity?: true
    unitPrice?: true
    total?: true
    chargesTTC?: true
    squareMeters?: true
    days?: true
    sortOrder?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type InvoiceLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLine to aggregate.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLines
    **/
    _count?: true | InvoiceLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type GetInvoiceLineAggregateType<T extends InvoiceLineAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLine[P]>
      : GetScalarType<T[P], AggregateInvoiceLine[P]>
  }




  export type InvoiceLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithAggregationInput | InvoiceLineOrderByWithAggregationInput[]
    by: InvoiceLineScalarFieldEnum[] | InvoiceLineScalarFieldEnum
    having?: InvoiceLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLineCountAggregateInputType | true
    _avg?: InvoiceLineAvgAggregateInputType
    _sum?: InvoiceLineSumAggregateInputType
    _min?: InvoiceLineMinAggregateInputType
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type InvoiceLineGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    quantity: number
    unitPrice: number
    total: number
    chargesTTC: number | null
    squareMeters: number | null
    days: number | null
    sortOrder: number
    createdAt: Date
    syncId: string | null
    needsSync: boolean
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  type GetInvoiceLineGroupByPayload<T extends InvoiceLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    chargesTTC?: boolean
    squareMeters?: boolean
    days?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    chargesTTC?: boolean
    squareMeters?: boolean
    days?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    chargesTTC?: boolean
    squareMeters?: boolean
    days?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    quantity?: boolean
    unitPrice?: boolean
    total?: boolean
    chargesTTC?: boolean
    squareMeters?: boolean
    days?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type InvoiceLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "description" | "quantity" | "unitPrice" | "total" | "chargesTTC" | "squareMeters" | "days" | "sortOrder" | "createdAt" | "syncId" | "needsSync", ExtArgs["result"]["invoiceLine"]>
  export type InvoiceLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceLine"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      quantity: number
      unitPrice: number
      total: number
      chargesTTC: number | null
      squareMeters: number | null
      days: number | null
      sortOrder: number
      createdAt: Date
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["invoiceLine"]>
    composites: {}
  }

  type InvoiceLineGetPayload<S extends boolean | null | undefined | InvoiceLineDefaultArgs> = $Result.GetResult<Prisma.$InvoiceLinePayload, S>

  type InvoiceLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceLineCountAggregateInputType | true
    }

  export interface InvoiceLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLine'], meta: { name: 'InvoiceLine' } }
    /**
     * Find zero or one InvoiceLine that matches the filter.
     * @param {InvoiceLineFindUniqueArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceLineFindUniqueArgs>(args: SelectSubset<T, InvoiceLineFindUniqueArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceLineFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceLineFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceLineFindFirstArgs>(args?: SelectSubset<T, InvoiceLineFindFirstArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceLineFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany()
     * 
     * // Get first 10 InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceLineFindManyArgs>(args?: SelectSubset<T, InvoiceLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceLine.
     * @param {InvoiceLineCreateArgs} args - Arguments to create a InvoiceLine.
     * @example
     * // Create one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.create({
     *   data: {
     *     // ... data to create a InvoiceLine
     *   }
     * })
     * 
     */
    create<T extends InvoiceLineCreateArgs>(args: SelectSubset<T, InvoiceLineCreateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceLines.
     * @param {InvoiceLineCreateManyArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceLineCreateManyArgs>(args?: SelectSubset<T, InvoiceLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceLines and returns the data saved in the database.
     * @param {InvoiceLineCreateManyAndReturnArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceLines and only return the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceLineCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceLine.
     * @param {InvoiceLineDeleteArgs} args - Arguments to delete one InvoiceLine.
     * @example
     * // Delete one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLine
     *   }
     * })
     * 
     */
    delete<T extends InvoiceLineDeleteArgs>(args: SelectSubset<T, InvoiceLineDeleteArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceLine.
     * @param {InvoiceLineUpdateArgs} args - Arguments to update one InvoiceLine.
     * @example
     * // Update one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceLineUpdateArgs>(args: SelectSubset<T, InvoiceLineUpdateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceLines.
     * @param {InvoiceLineDeleteManyArgs} args - Arguments to filter InvoiceLines to delete.
     * @example
     * // Delete a few InvoiceLines
     * const { count } = await prisma.invoiceLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceLineDeleteManyArgs>(args?: SelectSubset<T, InvoiceLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceLineUpdateManyArgs>(args: SelectSubset<T, InvoiceLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLines and returns the data updated in the database.
     * @param {InvoiceLineUpdateManyAndReturnArgs} args - Arguments to update many InvoiceLines.
     * @example
     * // Update many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceLines and only return the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceLineUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceLine.
     * @param {InvoiceLineUpsertArgs} args - Arguments to update or create a InvoiceLine.
     * @example
     * // Update or create a InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.upsert({
     *   create: {
     *     // ... data to create a InvoiceLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLine we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceLineUpsertArgs>(args: SelectSubset<T, InvoiceLineUpsertArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineCountArgs} args - Arguments to filter InvoiceLines to count.
     * @example
     * // Count the number of InvoiceLines
     * const count = await prisma.invoiceLine.count({
     *   where: {
     *     // ... the filter for the InvoiceLines we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLineCountArgs>(
      args?: Subset<T, InvoiceLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLineAggregateArgs>(args: Subset<T, InvoiceLineAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLineAggregateType<T>>

    /**
     * Group by InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLineGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceLine model
   */
  readonly fields: InvoiceLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceLine model
   */
  interface InvoiceLineFieldRefs {
    readonly id: FieldRef<"InvoiceLine", 'String'>
    readonly invoiceId: FieldRef<"InvoiceLine", 'String'>
    readonly description: FieldRef<"InvoiceLine", 'String'>
    readonly quantity: FieldRef<"InvoiceLine", 'Float'>
    readonly unitPrice: FieldRef<"InvoiceLine", 'Float'>
    readonly total: FieldRef<"InvoiceLine", 'Float'>
    readonly chargesTTC: FieldRef<"InvoiceLine", 'Float'>
    readonly squareMeters: FieldRef<"InvoiceLine", 'Float'>
    readonly days: FieldRef<"InvoiceLine", 'Float'>
    readonly sortOrder: FieldRef<"InvoiceLine", 'Int'>
    readonly createdAt: FieldRef<"InvoiceLine", 'DateTime'>
    readonly syncId: FieldRef<"InvoiceLine", 'String'>
    readonly needsSync: FieldRef<"InvoiceLine", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceLine findUnique
   */
  export type InvoiceLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findUniqueOrThrow
   */
  export type InvoiceLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findFirst
   */
  export type InvoiceLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findFirstOrThrow
   */
  export type InvoiceLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findMany
   */
  export type InvoiceLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLines to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine create
   */
  export type InvoiceLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLine.
     */
    data: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
  }

  /**
   * InvoiceLine createMany
   */
  export type InvoiceLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
  }

  /**
   * InvoiceLine createManyAndReturn
   */
  export type InvoiceLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLine update
   */
  export type InvoiceLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLine.
     */
    data: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLine to update.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine updateMany
   */
  export type InvoiceLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLines.
     */
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLines to update
     */
    where?: InvoiceLineWhereInput
    /**
     * Limit how many InvoiceLines to update.
     */
    limit?: number
  }

  /**
   * InvoiceLine updateManyAndReturn
   */
  export type InvoiceLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceLines.
     */
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLines to update
     */
    where?: InvoiceLineWhereInput
    /**
     * Limit how many InvoiceLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLine upsert
   */
  export type InvoiceLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLine to update in case it exists.
     */
    where: InvoiceLineWhereUniqueInput
    /**
     * In case the InvoiceLine found by the `where` argument doesn't exist, create a new InvoiceLine with this data.
     */
    create: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
    /**
     * In case the InvoiceLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
  }

  /**
   * InvoiceLine delete
   */
  export type InvoiceLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter which InvoiceLine to delete.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine deleteMany
   */
  export type InvoiceLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLines to delete
     */
    where?: InvoiceLineWhereInput
    /**
     * Limit how many InvoiceLines to delete.
     */
    limit?: number
  }

  /**
   * InvoiceLine without action
   */
  export type InvoiceLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceLine
     */
    omit?: InvoiceLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceSection
   */

  export type AggregateInvoiceSection = {
    _count: InvoiceSectionCountAggregateOutputType | null
    _avg: InvoiceSectionAvgAggregateOutputType | null
    _sum: InvoiceSectionSumAggregateOutputType | null
    _min: InvoiceSectionMinAggregateOutputType | null
    _max: InvoiceSectionMaxAggregateOutputType | null
  }

  export type InvoiceSectionAvgAggregateOutputType = {
    subtotal: number | null
    sortOrder: number | null
  }

  export type InvoiceSectionSumAggregateOutputType = {
    subtotal: number | null
    sortOrder: number | null
  }

  export type InvoiceSectionMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    title: string | null
    subtotal: number | null
    sortOrder: number | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type InvoiceSectionMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    title: string | null
    subtotal: number | null
    sortOrder: number | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type InvoiceSectionCountAggregateOutputType = {
    id: number
    invoiceId: number
    title: number
    subtotal: number
    sortOrder: number
    createdAt: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type InvoiceSectionAvgAggregateInputType = {
    subtotal?: true
    sortOrder?: true
  }

  export type InvoiceSectionSumAggregateInputType = {
    subtotal?: true
    sortOrder?: true
  }

  export type InvoiceSectionMinAggregateInputType = {
    id?: true
    invoiceId?: true
    title?: true
    subtotal?: true
    sortOrder?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type InvoiceSectionMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    title?: true
    subtotal?: true
    sortOrder?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type InvoiceSectionCountAggregateInputType = {
    id?: true
    invoiceId?: true
    title?: true
    subtotal?: true
    sortOrder?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type InvoiceSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceSection to aggregate.
     */
    where?: InvoiceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSections to fetch.
     */
    orderBy?: InvoiceSectionOrderByWithRelationInput | InvoiceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceSections
    **/
    _count?: true | InvoiceSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceSectionMaxAggregateInputType
  }

  export type GetInvoiceSectionAggregateType<T extends InvoiceSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceSection[P]>
      : GetScalarType<T[P], AggregateInvoiceSection[P]>
  }




  export type InvoiceSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceSectionWhereInput
    orderBy?: InvoiceSectionOrderByWithAggregationInput | InvoiceSectionOrderByWithAggregationInput[]
    by: InvoiceSectionScalarFieldEnum[] | InvoiceSectionScalarFieldEnum
    having?: InvoiceSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceSectionCountAggregateInputType | true
    _avg?: InvoiceSectionAvgAggregateInputType
    _sum?: InvoiceSectionSumAggregateInputType
    _min?: InvoiceSectionMinAggregateInputType
    _max?: InvoiceSectionMaxAggregateInputType
  }

  export type InvoiceSectionGroupByOutputType = {
    id: string
    invoiceId: string
    title: string
    subtotal: number
    sortOrder: number
    createdAt: Date
    syncId: string | null
    needsSync: boolean
    _count: InvoiceSectionCountAggregateOutputType | null
    _avg: InvoiceSectionAvgAggregateOutputType | null
    _sum: InvoiceSectionSumAggregateOutputType | null
    _min: InvoiceSectionMinAggregateOutputType | null
    _max: InvoiceSectionMaxAggregateOutputType | null
  }

  type GetInvoiceSectionGroupByPayload<T extends InvoiceSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceSectionGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceSectionGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    title?: boolean
    subtotal?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    lines?: boolean | InvoiceSection$linesArgs<ExtArgs>
    _count?: boolean | InvoiceSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceSection"]>

  export type InvoiceSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    title?: boolean
    subtotal?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceSection"]>

  export type InvoiceSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    title?: boolean
    subtotal?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceSection"]>

  export type InvoiceSectionSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    title?: boolean
    subtotal?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type InvoiceSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "title" | "subtotal" | "sortOrder" | "createdAt" | "syncId" | "needsSync", ExtArgs["result"]["invoiceSection"]>
  export type InvoiceSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
    lines?: boolean | InvoiceSection$linesArgs<ExtArgs>
    _count?: boolean | InvoiceSectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceSection"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
      lines: Prisma.$InvoiceSectionLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      title: string
      subtotal: number
      sortOrder: number
      createdAt: Date
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["invoiceSection"]>
    composites: {}
  }

  type InvoiceSectionGetPayload<S extends boolean | null | undefined | InvoiceSectionDefaultArgs> = $Result.GetResult<Prisma.$InvoiceSectionPayload, S>

  type InvoiceSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceSectionCountAggregateInputType | true
    }

  export interface InvoiceSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceSection'], meta: { name: 'InvoiceSection' } }
    /**
     * Find zero or one InvoiceSection that matches the filter.
     * @param {InvoiceSectionFindUniqueArgs} args - Arguments to find a InvoiceSection
     * @example
     * // Get one InvoiceSection
     * const invoiceSection = await prisma.invoiceSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceSectionFindUniqueArgs>(args: SelectSubset<T, InvoiceSectionFindUniqueArgs<ExtArgs>>): Prisma__InvoiceSectionClient<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceSectionFindUniqueOrThrowArgs} args - Arguments to find a InvoiceSection
     * @example
     * // Get one InvoiceSection
     * const invoiceSection = await prisma.invoiceSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceSectionClient<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionFindFirstArgs} args - Arguments to find a InvoiceSection
     * @example
     * // Get one InvoiceSection
     * const invoiceSection = await prisma.invoiceSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceSectionFindFirstArgs>(args?: SelectSubset<T, InvoiceSectionFindFirstArgs<ExtArgs>>): Prisma__InvoiceSectionClient<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionFindFirstOrThrowArgs} args - Arguments to find a InvoiceSection
     * @example
     * // Get one InvoiceSection
     * const invoiceSection = await prisma.invoiceSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceSectionClient<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceSections
     * const invoiceSections = await prisma.invoiceSection.findMany()
     * 
     * // Get first 10 InvoiceSections
     * const invoiceSections = await prisma.invoiceSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceSectionWithIdOnly = await prisma.invoiceSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceSectionFindManyArgs>(args?: SelectSubset<T, InvoiceSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceSection.
     * @param {InvoiceSectionCreateArgs} args - Arguments to create a InvoiceSection.
     * @example
     * // Create one InvoiceSection
     * const InvoiceSection = await prisma.invoiceSection.create({
     *   data: {
     *     // ... data to create a InvoiceSection
     *   }
     * })
     * 
     */
    create<T extends InvoiceSectionCreateArgs>(args: SelectSubset<T, InvoiceSectionCreateArgs<ExtArgs>>): Prisma__InvoiceSectionClient<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceSections.
     * @param {InvoiceSectionCreateManyArgs} args - Arguments to create many InvoiceSections.
     * @example
     * // Create many InvoiceSections
     * const invoiceSection = await prisma.invoiceSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceSectionCreateManyArgs>(args?: SelectSubset<T, InvoiceSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceSections and returns the data saved in the database.
     * @param {InvoiceSectionCreateManyAndReturnArgs} args - Arguments to create many InvoiceSections.
     * @example
     * // Create many InvoiceSections
     * const invoiceSection = await prisma.invoiceSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceSections and only return the `id`
     * const invoiceSectionWithIdOnly = await prisma.invoiceSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceSection.
     * @param {InvoiceSectionDeleteArgs} args - Arguments to delete one InvoiceSection.
     * @example
     * // Delete one InvoiceSection
     * const InvoiceSection = await prisma.invoiceSection.delete({
     *   where: {
     *     // ... filter to delete one InvoiceSection
     *   }
     * })
     * 
     */
    delete<T extends InvoiceSectionDeleteArgs>(args: SelectSubset<T, InvoiceSectionDeleteArgs<ExtArgs>>): Prisma__InvoiceSectionClient<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceSection.
     * @param {InvoiceSectionUpdateArgs} args - Arguments to update one InvoiceSection.
     * @example
     * // Update one InvoiceSection
     * const invoiceSection = await prisma.invoiceSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceSectionUpdateArgs>(args: SelectSubset<T, InvoiceSectionUpdateArgs<ExtArgs>>): Prisma__InvoiceSectionClient<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceSections.
     * @param {InvoiceSectionDeleteManyArgs} args - Arguments to filter InvoiceSections to delete.
     * @example
     * // Delete a few InvoiceSections
     * const { count } = await prisma.invoiceSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceSectionDeleteManyArgs>(args?: SelectSubset<T, InvoiceSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceSections
     * const invoiceSection = await prisma.invoiceSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceSectionUpdateManyArgs>(args: SelectSubset<T, InvoiceSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceSections and returns the data updated in the database.
     * @param {InvoiceSectionUpdateManyAndReturnArgs} args - Arguments to update many InvoiceSections.
     * @example
     * // Update many InvoiceSections
     * const invoiceSection = await prisma.invoiceSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceSections and only return the `id`
     * const invoiceSectionWithIdOnly = await prisma.invoiceSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceSection.
     * @param {InvoiceSectionUpsertArgs} args - Arguments to update or create a InvoiceSection.
     * @example
     * // Update or create a InvoiceSection
     * const invoiceSection = await prisma.invoiceSection.upsert({
     *   create: {
     *     // ... data to create a InvoiceSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceSection we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceSectionUpsertArgs>(args: SelectSubset<T, InvoiceSectionUpsertArgs<ExtArgs>>): Prisma__InvoiceSectionClient<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionCountArgs} args - Arguments to filter InvoiceSections to count.
     * @example
     * // Count the number of InvoiceSections
     * const count = await prisma.invoiceSection.count({
     *   where: {
     *     // ... the filter for the InvoiceSections we want to count
     *   }
     * })
    **/
    count<T extends InvoiceSectionCountArgs>(
      args?: Subset<T, InvoiceSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceSectionAggregateArgs>(args: Subset<T, InvoiceSectionAggregateArgs>): Prisma.PrismaPromise<GetInvoiceSectionAggregateType<T>>

    /**
     * Group by InvoiceSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceSectionGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceSection model
   */
  readonly fields: InvoiceSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lines<T extends InvoiceSection$linesArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceSection$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceSection model
   */
  interface InvoiceSectionFieldRefs {
    readonly id: FieldRef<"InvoiceSection", 'String'>
    readonly invoiceId: FieldRef<"InvoiceSection", 'String'>
    readonly title: FieldRef<"InvoiceSection", 'String'>
    readonly subtotal: FieldRef<"InvoiceSection", 'Float'>
    readonly sortOrder: FieldRef<"InvoiceSection", 'Int'>
    readonly createdAt: FieldRef<"InvoiceSection", 'DateTime'>
    readonly syncId: FieldRef<"InvoiceSection", 'String'>
    readonly needsSync: FieldRef<"InvoiceSection", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceSection findUnique
   */
  export type InvoiceSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSection to fetch.
     */
    where: InvoiceSectionWhereUniqueInput
  }

  /**
   * InvoiceSection findUniqueOrThrow
   */
  export type InvoiceSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSection to fetch.
     */
    where: InvoiceSectionWhereUniqueInput
  }

  /**
   * InvoiceSection findFirst
   */
  export type InvoiceSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSection to fetch.
     */
    where?: InvoiceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSections to fetch.
     */
    orderBy?: InvoiceSectionOrderByWithRelationInput | InvoiceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceSections.
     */
    cursor?: InvoiceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceSections.
     */
    distinct?: InvoiceSectionScalarFieldEnum | InvoiceSectionScalarFieldEnum[]
  }

  /**
   * InvoiceSection findFirstOrThrow
   */
  export type InvoiceSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSection to fetch.
     */
    where?: InvoiceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSections to fetch.
     */
    orderBy?: InvoiceSectionOrderByWithRelationInput | InvoiceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceSections.
     */
    cursor?: InvoiceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceSections.
     */
    distinct?: InvoiceSectionScalarFieldEnum | InvoiceSectionScalarFieldEnum[]
  }

  /**
   * InvoiceSection findMany
   */
  export type InvoiceSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSections to fetch.
     */
    where?: InvoiceSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSections to fetch.
     */
    orderBy?: InvoiceSectionOrderByWithRelationInput | InvoiceSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceSections.
     */
    cursor?: InvoiceSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSections.
     */
    skip?: number
    distinct?: InvoiceSectionScalarFieldEnum | InvoiceSectionScalarFieldEnum[]
  }

  /**
   * InvoiceSection create
   */
  export type InvoiceSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceSection.
     */
    data: XOR<InvoiceSectionCreateInput, InvoiceSectionUncheckedCreateInput>
  }

  /**
   * InvoiceSection createMany
   */
  export type InvoiceSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceSections.
     */
    data: InvoiceSectionCreateManyInput | InvoiceSectionCreateManyInput[]
  }

  /**
   * InvoiceSection createManyAndReturn
   */
  export type InvoiceSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceSections.
     */
    data: InvoiceSectionCreateManyInput | InvoiceSectionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceSection update
   */
  export type InvoiceSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceSection.
     */
    data: XOR<InvoiceSectionUpdateInput, InvoiceSectionUncheckedUpdateInput>
    /**
     * Choose, which InvoiceSection to update.
     */
    where: InvoiceSectionWhereUniqueInput
  }

  /**
   * InvoiceSection updateMany
   */
  export type InvoiceSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceSections.
     */
    data: XOR<InvoiceSectionUpdateManyMutationInput, InvoiceSectionUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceSections to update
     */
    where?: InvoiceSectionWhereInput
    /**
     * Limit how many InvoiceSections to update.
     */
    limit?: number
  }

  /**
   * InvoiceSection updateManyAndReturn
   */
  export type InvoiceSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceSections.
     */
    data: XOR<InvoiceSectionUpdateManyMutationInput, InvoiceSectionUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceSections to update
     */
    where?: InvoiceSectionWhereInput
    /**
     * Limit how many InvoiceSections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceSection upsert
   */
  export type InvoiceSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceSection to update in case it exists.
     */
    where: InvoiceSectionWhereUniqueInput
    /**
     * In case the InvoiceSection found by the `where` argument doesn't exist, create a new InvoiceSection with this data.
     */
    create: XOR<InvoiceSectionCreateInput, InvoiceSectionUncheckedCreateInput>
    /**
     * In case the InvoiceSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceSectionUpdateInput, InvoiceSectionUncheckedUpdateInput>
  }

  /**
   * InvoiceSection delete
   */
  export type InvoiceSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
    /**
     * Filter which InvoiceSection to delete.
     */
    where: InvoiceSectionWhereUniqueInput
  }

  /**
   * InvoiceSection deleteMany
   */
  export type InvoiceSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceSections to delete
     */
    where?: InvoiceSectionWhereInput
    /**
     * Limit how many InvoiceSections to delete.
     */
    limit?: number
  }

  /**
   * InvoiceSection.lines
   */
  export type InvoiceSection$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
    where?: InvoiceSectionLineWhereInput
    orderBy?: InvoiceSectionLineOrderByWithRelationInput | InvoiceSectionLineOrderByWithRelationInput[]
    cursor?: InvoiceSectionLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceSectionLineScalarFieldEnum | InvoiceSectionLineScalarFieldEnum[]
  }

  /**
   * InvoiceSection without action
   */
  export type InvoiceSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSection
     */
    select?: InvoiceSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSection
     */
    omit?: InvoiceSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceSectionLine
   */

  export type AggregateInvoiceSectionLine = {
    _count: InvoiceSectionLineCountAggregateOutputType | null
    _avg: InvoiceSectionLineAvgAggregateOutputType | null
    _sum: InvoiceSectionLineSumAggregateOutputType | null
    _min: InvoiceSectionLineMinAggregateOutputType | null
    _max: InvoiceSectionLineMaxAggregateOutputType | null
  }

  export type InvoiceSectionLineAvgAggregateOutputType = {
    quantity: number | null
    squareMeters: number | null
    days: number | null
    unitPrice: number | null
    total: number | null
    sortOrder: number | null
  }

  export type InvoiceSectionLineSumAggregateOutputType = {
    quantity: number | null
    squareMeters: number | null
    days: number | null
    unitPrice: number | null
    total: number | null
    sortOrder: number | null
  }

  export type InvoiceSectionLineMinAggregateOutputType = {
    id: string | null
    sectionId: string | null
    description: string | null
    quantity: number | null
    squareMeters: number | null
    days: number | null
    unitPrice: number | null
    total: number | null
    daysImpactPrice: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type InvoiceSectionLineMaxAggregateOutputType = {
    id: string | null
    sectionId: string | null
    description: string | null
    quantity: number | null
    squareMeters: number | null
    days: number | null
    unitPrice: number | null
    total: number | null
    daysImpactPrice: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type InvoiceSectionLineCountAggregateOutputType = {
    id: number
    sectionId: number
    description: number
    quantity: number
    squareMeters: number
    days: number
    unitPrice: number
    total: number
    daysImpactPrice: number
    sortOrder: number
    createdAt: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type InvoiceSectionLineAvgAggregateInputType = {
    quantity?: true
    squareMeters?: true
    days?: true
    unitPrice?: true
    total?: true
    sortOrder?: true
  }

  export type InvoiceSectionLineSumAggregateInputType = {
    quantity?: true
    squareMeters?: true
    days?: true
    unitPrice?: true
    total?: true
    sortOrder?: true
  }

  export type InvoiceSectionLineMinAggregateInputType = {
    id?: true
    sectionId?: true
    description?: true
    quantity?: true
    squareMeters?: true
    days?: true
    unitPrice?: true
    total?: true
    daysImpactPrice?: true
    sortOrder?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type InvoiceSectionLineMaxAggregateInputType = {
    id?: true
    sectionId?: true
    description?: true
    quantity?: true
    squareMeters?: true
    days?: true
    unitPrice?: true
    total?: true
    daysImpactPrice?: true
    sortOrder?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type InvoiceSectionLineCountAggregateInputType = {
    id?: true
    sectionId?: true
    description?: true
    quantity?: true
    squareMeters?: true
    days?: true
    unitPrice?: true
    total?: true
    daysImpactPrice?: true
    sortOrder?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type InvoiceSectionLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceSectionLine to aggregate.
     */
    where?: InvoiceSectionLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSectionLines to fetch.
     */
    orderBy?: InvoiceSectionLineOrderByWithRelationInput | InvoiceSectionLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceSectionLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSectionLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSectionLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceSectionLines
    **/
    _count?: true | InvoiceSectionLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceSectionLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSectionLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceSectionLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceSectionLineMaxAggregateInputType
  }

  export type GetInvoiceSectionLineAggregateType<T extends InvoiceSectionLineAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceSectionLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceSectionLine[P]>
      : GetScalarType<T[P], AggregateInvoiceSectionLine[P]>
  }




  export type InvoiceSectionLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceSectionLineWhereInput
    orderBy?: InvoiceSectionLineOrderByWithAggregationInput | InvoiceSectionLineOrderByWithAggregationInput[]
    by: InvoiceSectionLineScalarFieldEnum[] | InvoiceSectionLineScalarFieldEnum
    having?: InvoiceSectionLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceSectionLineCountAggregateInputType | true
    _avg?: InvoiceSectionLineAvgAggregateInputType
    _sum?: InvoiceSectionLineSumAggregateInputType
    _min?: InvoiceSectionLineMinAggregateInputType
    _max?: InvoiceSectionLineMaxAggregateInputType
  }

  export type InvoiceSectionLineGroupByOutputType = {
    id: string
    sectionId: string
    description: string
    quantity: number
    squareMeters: number | null
    days: number | null
    unitPrice: number
    total: number
    daysImpactPrice: boolean
    sortOrder: number
    createdAt: Date
    syncId: string | null
    needsSync: boolean
    _count: InvoiceSectionLineCountAggregateOutputType | null
    _avg: InvoiceSectionLineAvgAggregateOutputType | null
    _sum: InvoiceSectionLineSumAggregateOutputType | null
    _min: InvoiceSectionLineMinAggregateOutputType | null
    _max: InvoiceSectionLineMaxAggregateOutputType | null
  }

  type GetInvoiceSectionLineGroupByPayload<T extends InvoiceSectionLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceSectionLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceSectionLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceSectionLineGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceSectionLineGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSectionLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    description?: boolean
    quantity?: boolean
    squareMeters?: boolean
    days?: boolean
    unitPrice?: boolean
    total?: boolean
    daysImpactPrice?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    section?: boolean | InvoiceSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceSectionLine"]>

  export type InvoiceSectionLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    description?: boolean
    quantity?: boolean
    squareMeters?: boolean
    days?: boolean
    unitPrice?: boolean
    total?: boolean
    daysImpactPrice?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    section?: boolean | InvoiceSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceSectionLine"]>

  export type InvoiceSectionLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    description?: boolean
    quantity?: boolean
    squareMeters?: boolean
    days?: boolean
    unitPrice?: boolean
    total?: boolean
    daysImpactPrice?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    section?: boolean | InvoiceSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceSectionLine"]>

  export type InvoiceSectionLineSelectScalar = {
    id?: boolean
    sectionId?: boolean
    description?: boolean
    quantity?: boolean
    squareMeters?: boolean
    days?: boolean
    unitPrice?: boolean
    total?: boolean
    daysImpactPrice?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type InvoiceSectionLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sectionId" | "description" | "quantity" | "squareMeters" | "days" | "unitPrice" | "total" | "daysImpactPrice" | "sortOrder" | "createdAt" | "syncId" | "needsSync", ExtArgs["result"]["invoiceSectionLine"]>
  export type InvoiceSectionLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | InvoiceSectionDefaultArgs<ExtArgs>
  }
  export type InvoiceSectionLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | InvoiceSectionDefaultArgs<ExtArgs>
  }
  export type InvoiceSectionLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | InvoiceSectionDefaultArgs<ExtArgs>
  }

  export type $InvoiceSectionLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceSectionLine"
    objects: {
      section: Prisma.$InvoiceSectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sectionId: string
      description: string
      quantity: number
      squareMeters: number | null
      days: number | null
      unitPrice: number
      total: number
      daysImpactPrice: boolean
      sortOrder: number
      createdAt: Date
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["invoiceSectionLine"]>
    composites: {}
  }

  type InvoiceSectionLineGetPayload<S extends boolean | null | undefined | InvoiceSectionLineDefaultArgs> = $Result.GetResult<Prisma.$InvoiceSectionLinePayload, S>

  type InvoiceSectionLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceSectionLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceSectionLineCountAggregateInputType | true
    }

  export interface InvoiceSectionLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceSectionLine'], meta: { name: 'InvoiceSectionLine' } }
    /**
     * Find zero or one InvoiceSectionLine that matches the filter.
     * @param {InvoiceSectionLineFindUniqueArgs} args - Arguments to find a InvoiceSectionLine
     * @example
     * // Get one InvoiceSectionLine
     * const invoiceSectionLine = await prisma.invoiceSectionLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceSectionLineFindUniqueArgs>(args: SelectSubset<T, InvoiceSectionLineFindUniqueArgs<ExtArgs>>): Prisma__InvoiceSectionLineClient<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoiceSectionLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceSectionLineFindUniqueOrThrowArgs} args - Arguments to find a InvoiceSectionLine
     * @example
     * // Get one InvoiceSectionLine
     * const invoiceSectionLine = await prisma.invoiceSectionLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceSectionLineFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceSectionLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceSectionLineClient<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceSectionLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionLineFindFirstArgs} args - Arguments to find a InvoiceSectionLine
     * @example
     * // Get one InvoiceSectionLine
     * const invoiceSectionLine = await prisma.invoiceSectionLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceSectionLineFindFirstArgs>(args?: SelectSubset<T, InvoiceSectionLineFindFirstArgs<ExtArgs>>): Prisma__InvoiceSectionLineClient<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoiceSectionLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionLineFindFirstOrThrowArgs} args - Arguments to find a InvoiceSectionLine
     * @example
     * // Get one InvoiceSectionLine
     * const invoiceSectionLine = await prisma.invoiceSectionLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceSectionLineFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceSectionLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceSectionLineClient<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoiceSectionLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceSectionLines
     * const invoiceSectionLines = await prisma.invoiceSectionLine.findMany()
     * 
     * // Get first 10 InvoiceSectionLines
     * const invoiceSectionLines = await prisma.invoiceSectionLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceSectionLineWithIdOnly = await prisma.invoiceSectionLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceSectionLineFindManyArgs>(args?: SelectSubset<T, InvoiceSectionLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoiceSectionLine.
     * @param {InvoiceSectionLineCreateArgs} args - Arguments to create a InvoiceSectionLine.
     * @example
     * // Create one InvoiceSectionLine
     * const InvoiceSectionLine = await prisma.invoiceSectionLine.create({
     *   data: {
     *     // ... data to create a InvoiceSectionLine
     *   }
     * })
     * 
     */
    create<T extends InvoiceSectionLineCreateArgs>(args: SelectSubset<T, InvoiceSectionLineCreateArgs<ExtArgs>>): Prisma__InvoiceSectionLineClient<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoiceSectionLines.
     * @param {InvoiceSectionLineCreateManyArgs} args - Arguments to create many InvoiceSectionLines.
     * @example
     * // Create many InvoiceSectionLines
     * const invoiceSectionLine = await prisma.invoiceSectionLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceSectionLineCreateManyArgs>(args?: SelectSubset<T, InvoiceSectionLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceSectionLines and returns the data saved in the database.
     * @param {InvoiceSectionLineCreateManyAndReturnArgs} args - Arguments to create many InvoiceSectionLines.
     * @example
     * // Create many InvoiceSectionLines
     * const invoiceSectionLine = await prisma.invoiceSectionLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceSectionLines and only return the `id`
     * const invoiceSectionLineWithIdOnly = await prisma.invoiceSectionLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceSectionLineCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceSectionLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoiceSectionLine.
     * @param {InvoiceSectionLineDeleteArgs} args - Arguments to delete one InvoiceSectionLine.
     * @example
     * // Delete one InvoiceSectionLine
     * const InvoiceSectionLine = await prisma.invoiceSectionLine.delete({
     *   where: {
     *     // ... filter to delete one InvoiceSectionLine
     *   }
     * })
     * 
     */
    delete<T extends InvoiceSectionLineDeleteArgs>(args: SelectSubset<T, InvoiceSectionLineDeleteArgs<ExtArgs>>): Prisma__InvoiceSectionLineClient<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoiceSectionLine.
     * @param {InvoiceSectionLineUpdateArgs} args - Arguments to update one InvoiceSectionLine.
     * @example
     * // Update one InvoiceSectionLine
     * const invoiceSectionLine = await prisma.invoiceSectionLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceSectionLineUpdateArgs>(args: SelectSubset<T, InvoiceSectionLineUpdateArgs<ExtArgs>>): Prisma__InvoiceSectionLineClient<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoiceSectionLines.
     * @param {InvoiceSectionLineDeleteManyArgs} args - Arguments to filter InvoiceSectionLines to delete.
     * @example
     * // Delete a few InvoiceSectionLines
     * const { count } = await prisma.invoiceSectionLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceSectionLineDeleteManyArgs>(args?: SelectSubset<T, InvoiceSectionLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceSectionLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceSectionLines
     * const invoiceSectionLine = await prisma.invoiceSectionLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceSectionLineUpdateManyArgs>(args: SelectSubset<T, InvoiceSectionLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceSectionLines and returns the data updated in the database.
     * @param {InvoiceSectionLineUpdateManyAndReturnArgs} args - Arguments to update many InvoiceSectionLines.
     * @example
     * // Update many InvoiceSectionLines
     * const invoiceSectionLine = await prisma.invoiceSectionLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoiceSectionLines and only return the `id`
     * const invoiceSectionLineWithIdOnly = await prisma.invoiceSectionLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceSectionLineUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceSectionLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoiceSectionLine.
     * @param {InvoiceSectionLineUpsertArgs} args - Arguments to update or create a InvoiceSectionLine.
     * @example
     * // Update or create a InvoiceSectionLine
     * const invoiceSectionLine = await prisma.invoiceSectionLine.upsert({
     *   create: {
     *     // ... data to create a InvoiceSectionLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceSectionLine we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceSectionLineUpsertArgs>(args: SelectSubset<T, InvoiceSectionLineUpsertArgs<ExtArgs>>): Prisma__InvoiceSectionLineClient<$Result.GetResult<Prisma.$InvoiceSectionLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoiceSectionLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionLineCountArgs} args - Arguments to filter InvoiceSectionLines to count.
     * @example
     * // Count the number of InvoiceSectionLines
     * const count = await prisma.invoiceSectionLine.count({
     *   where: {
     *     // ... the filter for the InvoiceSectionLines we want to count
     *   }
     * })
    **/
    count<T extends InvoiceSectionLineCountArgs>(
      args?: Subset<T, InvoiceSectionLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceSectionLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceSectionLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceSectionLineAggregateArgs>(args: Subset<T, InvoiceSectionLineAggregateArgs>): Prisma.PrismaPromise<GetInvoiceSectionLineAggregateType<T>>

    /**
     * Group by InvoiceSectionLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceSectionLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceSectionLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceSectionLineGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceSectionLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceSectionLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceSectionLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceSectionLine model
   */
  readonly fields: InvoiceSectionLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceSectionLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceSectionLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends InvoiceSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceSectionDefaultArgs<ExtArgs>>): Prisma__InvoiceSectionClient<$Result.GetResult<Prisma.$InvoiceSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceSectionLine model
   */
  interface InvoiceSectionLineFieldRefs {
    readonly id: FieldRef<"InvoiceSectionLine", 'String'>
    readonly sectionId: FieldRef<"InvoiceSectionLine", 'String'>
    readonly description: FieldRef<"InvoiceSectionLine", 'String'>
    readonly quantity: FieldRef<"InvoiceSectionLine", 'Float'>
    readonly squareMeters: FieldRef<"InvoiceSectionLine", 'Float'>
    readonly days: FieldRef<"InvoiceSectionLine", 'Float'>
    readonly unitPrice: FieldRef<"InvoiceSectionLine", 'Float'>
    readonly total: FieldRef<"InvoiceSectionLine", 'Float'>
    readonly daysImpactPrice: FieldRef<"InvoiceSectionLine", 'Boolean'>
    readonly sortOrder: FieldRef<"InvoiceSectionLine", 'Int'>
    readonly createdAt: FieldRef<"InvoiceSectionLine", 'DateTime'>
    readonly syncId: FieldRef<"InvoiceSectionLine", 'String'>
    readonly needsSync: FieldRef<"InvoiceSectionLine", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceSectionLine findUnique
   */
  export type InvoiceSectionLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSectionLine to fetch.
     */
    where: InvoiceSectionLineWhereUniqueInput
  }

  /**
   * InvoiceSectionLine findUniqueOrThrow
   */
  export type InvoiceSectionLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSectionLine to fetch.
     */
    where: InvoiceSectionLineWhereUniqueInput
  }

  /**
   * InvoiceSectionLine findFirst
   */
  export type InvoiceSectionLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSectionLine to fetch.
     */
    where?: InvoiceSectionLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSectionLines to fetch.
     */
    orderBy?: InvoiceSectionLineOrderByWithRelationInput | InvoiceSectionLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceSectionLines.
     */
    cursor?: InvoiceSectionLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSectionLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSectionLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceSectionLines.
     */
    distinct?: InvoiceSectionLineScalarFieldEnum | InvoiceSectionLineScalarFieldEnum[]
  }

  /**
   * InvoiceSectionLine findFirstOrThrow
   */
  export type InvoiceSectionLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSectionLine to fetch.
     */
    where?: InvoiceSectionLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSectionLines to fetch.
     */
    orderBy?: InvoiceSectionLineOrderByWithRelationInput | InvoiceSectionLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceSectionLines.
     */
    cursor?: InvoiceSectionLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSectionLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSectionLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceSectionLines.
     */
    distinct?: InvoiceSectionLineScalarFieldEnum | InvoiceSectionLineScalarFieldEnum[]
  }

  /**
   * InvoiceSectionLine findMany
   */
  export type InvoiceSectionLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceSectionLines to fetch.
     */
    where?: InvoiceSectionLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceSectionLines to fetch.
     */
    orderBy?: InvoiceSectionLineOrderByWithRelationInput | InvoiceSectionLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceSectionLines.
     */
    cursor?: InvoiceSectionLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceSectionLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceSectionLines.
     */
    skip?: number
    distinct?: InvoiceSectionLineScalarFieldEnum | InvoiceSectionLineScalarFieldEnum[]
  }

  /**
   * InvoiceSectionLine create
   */
  export type InvoiceSectionLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceSectionLine.
     */
    data: XOR<InvoiceSectionLineCreateInput, InvoiceSectionLineUncheckedCreateInput>
  }

  /**
   * InvoiceSectionLine createMany
   */
  export type InvoiceSectionLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceSectionLines.
     */
    data: InvoiceSectionLineCreateManyInput | InvoiceSectionLineCreateManyInput[]
  }

  /**
   * InvoiceSectionLine createManyAndReturn
   */
  export type InvoiceSectionLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * The data used to create many InvoiceSectionLines.
     */
    data: InvoiceSectionLineCreateManyInput | InvoiceSectionLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceSectionLine update
   */
  export type InvoiceSectionLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceSectionLine.
     */
    data: XOR<InvoiceSectionLineUpdateInput, InvoiceSectionLineUncheckedUpdateInput>
    /**
     * Choose, which InvoiceSectionLine to update.
     */
    where: InvoiceSectionLineWhereUniqueInput
  }

  /**
   * InvoiceSectionLine updateMany
   */
  export type InvoiceSectionLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceSectionLines.
     */
    data: XOR<InvoiceSectionLineUpdateManyMutationInput, InvoiceSectionLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceSectionLines to update
     */
    where?: InvoiceSectionLineWhereInput
    /**
     * Limit how many InvoiceSectionLines to update.
     */
    limit?: number
  }

  /**
   * InvoiceSectionLine updateManyAndReturn
   */
  export type InvoiceSectionLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * The data used to update InvoiceSectionLines.
     */
    data: XOR<InvoiceSectionLineUpdateManyMutationInput, InvoiceSectionLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceSectionLines to update
     */
    where?: InvoiceSectionLineWhereInput
    /**
     * Limit how many InvoiceSectionLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceSectionLine upsert
   */
  export type InvoiceSectionLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceSectionLine to update in case it exists.
     */
    where: InvoiceSectionLineWhereUniqueInput
    /**
     * In case the InvoiceSectionLine found by the `where` argument doesn't exist, create a new InvoiceSectionLine with this data.
     */
    create: XOR<InvoiceSectionLineCreateInput, InvoiceSectionLineUncheckedCreateInput>
    /**
     * In case the InvoiceSectionLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceSectionLineUpdateInput, InvoiceSectionLineUncheckedUpdateInput>
  }

  /**
   * InvoiceSectionLine delete
   */
  export type InvoiceSectionLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
    /**
     * Filter which InvoiceSectionLine to delete.
     */
    where: InvoiceSectionLineWhereUniqueInput
  }

  /**
   * InvoiceSectionLine deleteMany
   */
  export type InvoiceSectionLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceSectionLines to delete
     */
    where?: InvoiceSectionLineWhereInput
    /**
     * Limit how many InvoiceSectionLines to delete.
     */
    limit?: number
  }

  /**
   * InvoiceSectionLine without action
   */
  export type InvoiceSectionLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceSectionLine
     */
    select?: InvoiceSectionLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoiceSectionLine
     */
    omit?: InvoiceSectionLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceSectionLineInclude<ExtArgs> | null
  }


  /**
   * Model InvoicePayment
   */

  export type AggregateInvoicePayment = {
    _count: InvoicePaymentCountAggregateOutputType | null
    _avg: InvoicePaymentAvgAggregateOutputType | null
    _sum: InvoicePaymentSumAggregateOutputType | null
    _min: InvoicePaymentMinAggregateOutputType | null
    _max: InvoicePaymentMaxAggregateOutputType | null
  }

  export type InvoicePaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoicePaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoicePaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: string | null
    reference: string | null
    notes: string | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type InvoicePaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    amount: number | null
    paymentDate: Date | null
    paymentMethod: string | null
    reference: string | null
    notes: string | null
    createdAt: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type InvoicePaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    amount: number
    paymentDate: number
    paymentMethod: number
    reference: number
    notes: number
    createdAt: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type InvoicePaymentAvgAggregateInputType = {
    amount?: true
  }

  export type InvoicePaymentSumAggregateInputType = {
    amount?: true
  }

  export type InvoicePaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type InvoicePaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
  }

  export type InvoicePaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    amount?: true
    paymentDate?: true
    paymentMethod?: true
    reference?: true
    notes?: true
    createdAt?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type InvoicePaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoicePayment to aggregate.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoicePayments
    **/
    _count?: true | InvoicePaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoicePaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoicePaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoicePaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoicePaymentMaxAggregateInputType
  }

  export type GetInvoicePaymentAggregateType<T extends InvoicePaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoicePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoicePayment[P]>
      : GetScalarType<T[P], AggregateInvoicePayment[P]>
  }




  export type InvoicePaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoicePaymentWhereInput
    orderBy?: InvoicePaymentOrderByWithAggregationInput | InvoicePaymentOrderByWithAggregationInput[]
    by: InvoicePaymentScalarFieldEnum[] | InvoicePaymentScalarFieldEnum
    having?: InvoicePaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoicePaymentCountAggregateInputType | true
    _avg?: InvoicePaymentAvgAggregateInputType
    _sum?: InvoicePaymentSumAggregateInputType
    _min?: InvoicePaymentMinAggregateInputType
    _max?: InvoicePaymentMaxAggregateInputType
  }

  export type InvoicePaymentGroupByOutputType = {
    id: string
    invoiceId: string
    amount: number
    paymentDate: Date
    paymentMethod: string | null
    reference: string | null
    notes: string | null
    createdAt: Date
    syncId: string | null
    needsSync: boolean
    _count: InvoicePaymentCountAggregateOutputType | null
    _avg: InvoicePaymentAvgAggregateOutputType | null
    _sum: InvoicePaymentSumAggregateOutputType | null
    _min: InvoicePaymentMinAggregateOutputType | null
    _max: InvoicePaymentMaxAggregateOutputType | null
  }

  type GetInvoicePaymentGroupByPayload<T extends InvoicePaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoicePaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoicePaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoicePaymentGroupByOutputType[P]>
            : GetScalarType<T[P], InvoicePaymentGroupByOutputType[P]>
        }
      >
    >


  export type InvoicePaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoicePayment"]>

  export type InvoicePaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoicePayment"]>

  export type InvoicePaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoicePayment"]>

  export type InvoicePaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    amount?: boolean
    paymentDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    notes?: boolean
    createdAt?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type InvoicePaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoiceId" | "amount" | "paymentDate" | "paymentMethod" | "reference" | "notes" | "createdAt" | "syncId" | "needsSync", ExtArgs["result"]["invoicePayment"]>
  export type InvoicePaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoicePaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoicePaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoicePaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoicePayment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      amount: number
      paymentDate: Date
      paymentMethod: string | null
      reference: string | null
      notes: string | null
      createdAt: Date
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["invoicePayment"]>
    composites: {}
  }

  type InvoicePaymentGetPayload<S extends boolean | null | undefined | InvoicePaymentDefaultArgs> = $Result.GetResult<Prisma.$InvoicePaymentPayload, S>

  type InvoicePaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoicePaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoicePaymentCountAggregateInputType | true
    }

  export interface InvoicePaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoicePayment'], meta: { name: 'InvoicePayment' } }
    /**
     * Find zero or one InvoicePayment that matches the filter.
     * @param {InvoicePaymentFindUniqueArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoicePaymentFindUniqueArgs>(args: SelectSubset<T, InvoicePaymentFindUniqueArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InvoicePayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoicePaymentFindUniqueOrThrowArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoicePaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoicePaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoicePayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentFindFirstArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoicePaymentFindFirstArgs>(args?: SelectSubset<T, InvoicePaymentFindFirstArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InvoicePayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentFindFirstOrThrowArgs} args - Arguments to find a InvoicePayment
     * @example
     * // Get one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoicePaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoicePaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InvoicePayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoicePayments
     * const invoicePayments = await prisma.invoicePayment.findMany()
     * 
     * // Get first 10 InvoicePayments
     * const invoicePayments = await prisma.invoicePayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoicePaymentWithIdOnly = await prisma.invoicePayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoicePaymentFindManyArgs>(args?: SelectSubset<T, InvoicePaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InvoicePayment.
     * @param {InvoicePaymentCreateArgs} args - Arguments to create a InvoicePayment.
     * @example
     * // Create one InvoicePayment
     * const InvoicePayment = await prisma.invoicePayment.create({
     *   data: {
     *     // ... data to create a InvoicePayment
     *   }
     * })
     * 
     */
    create<T extends InvoicePaymentCreateArgs>(args: SelectSubset<T, InvoicePaymentCreateArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InvoicePayments.
     * @param {InvoicePaymentCreateManyArgs} args - Arguments to create many InvoicePayments.
     * @example
     * // Create many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoicePaymentCreateManyArgs>(args?: SelectSubset<T, InvoicePaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoicePayments and returns the data saved in the database.
     * @param {InvoicePaymentCreateManyAndReturnArgs} args - Arguments to create many InvoicePayments.
     * @example
     * // Create many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoicePayments and only return the `id`
     * const invoicePaymentWithIdOnly = await prisma.invoicePayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoicePaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoicePaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InvoicePayment.
     * @param {InvoicePaymentDeleteArgs} args - Arguments to delete one InvoicePayment.
     * @example
     * // Delete one InvoicePayment
     * const InvoicePayment = await prisma.invoicePayment.delete({
     *   where: {
     *     // ... filter to delete one InvoicePayment
     *   }
     * })
     * 
     */
    delete<T extends InvoicePaymentDeleteArgs>(args: SelectSubset<T, InvoicePaymentDeleteArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InvoicePayment.
     * @param {InvoicePaymentUpdateArgs} args - Arguments to update one InvoicePayment.
     * @example
     * // Update one InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoicePaymentUpdateArgs>(args: SelectSubset<T, InvoicePaymentUpdateArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InvoicePayments.
     * @param {InvoicePaymentDeleteManyArgs} args - Arguments to filter InvoicePayments to delete.
     * @example
     * // Delete a few InvoicePayments
     * const { count } = await prisma.invoicePayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoicePaymentDeleteManyArgs>(args?: SelectSubset<T, InvoicePaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoicePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoicePaymentUpdateManyArgs>(args: SelectSubset<T, InvoicePaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoicePayments and returns the data updated in the database.
     * @param {InvoicePaymentUpdateManyAndReturnArgs} args - Arguments to update many InvoicePayments.
     * @example
     * // Update many InvoicePayments
     * const invoicePayment = await prisma.invoicePayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InvoicePayments and only return the `id`
     * const invoicePaymentWithIdOnly = await prisma.invoicePayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoicePaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoicePaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InvoicePayment.
     * @param {InvoicePaymentUpsertArgs} args - Arguments to update or create a InvoicePayment.
     * @example
     * // Update or create a InvoicePayment
     * const invoicePayment = await prisma.invoicePayment.upsert({
     *   create: {
     *     // ... data to create a InvoicePayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoicePayment we want to update
     *   }
     * })
     */
    upsert<T extends InvoicePaymentUpsertArgs>(args: SelectSubset<T, InvoicePaymentUpsertArgs<ExtArgs>>): Prisma__InvoicePaymentClient<$Result.GetResult<Prisma.$InvoicePaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InvoicePayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentCountArgs} args - Arguments to filter InvoicePayments to count.
     * @example
     * // Count the number of InvoicePayments
     * const count = await prisma.invoicePayment.count({
     *   where: {
     *     // ... the filter for the InvoicePayments we want to count
     *   }
     * })
    **/
    count<T extends InvoicePaymentCountArgs>(
      args?: Subset<T, InvoicePaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoicePaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoicePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoicePaymentAggregateArgs>(args: Subset<T, InvoicePaymentAggregateArgs>): Prisma.PrismaPromise<GetInvoicePaymentAggregateType<T>>

    /**
     * Group by InvoicePayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoicePaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoicePaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoicePaymentGroupByArgs['orderBy'] }
        : { orderBy?: InvoicePaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoicePaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoicePaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoicePayment model
   */
  readonly fields: InvoicePaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoicePayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoicePaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoicePayment model
   */
  interface InvoicePaymentFieldRefs {
    readonly id: FieldRef<"InvoicePayment", 'String'>
    readonly invoiceId: FieldRef<"InvoicePayment", 'String'>
    readonly amount: FieldRef<"InvoicePayment", 'Float'>
    readonly paymentDate: FieldRef<"InvoicePayment", 'DateTime'>
    readonly paymentMethod: FieldRef<"InvoicePayment", 'String'>
    readonly reference: FieldRef<"InvoicePayment", 'String'>
    readonly notes: FieldRef<"InvoicePayment", 'String'>
    readonly createdAt: FieldRef<"InvoicePayment", 'DateTime'>
    readonly syncId: FieldRef<"InvoicePayment", 'String'>
    readonly needsSync: FieldRef<"InvoicePayment", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * InvoicePayment findUnique
   */
  export type InvoicePaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment findUniqueOrThrow
   */
  export type InvoicePaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment findFirst
   */
  export type InvoicePaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoicePayments.
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoicePayments.
     */
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * InvoicePayment findFirstOrThrow
   */
  export type InvoicePaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayment to fetch.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoicePayments.
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoicePayments.
     */
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * InvoicePayment findMany
   */
  export type InvoicePaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter, which InvoicePayments to fetch.
     */
    where?: InvoicePaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoicePayments to fetch.
     */
    orderBy?: InvoicePaymentOrderByWithRelationInput | InvoicePaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoicePayments.
     */
    cursor?: InvoicePaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoicePayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoicePayments.
     */
    skip?: number
    distinct?: InvoicePaymentScalarFieldEnum | InvoicePaymentScalarFieldEnum[]
  }

  /**
   * InvoicePayment create
   */
  export type InvoicePaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoicePayment.
     */
    data: XOR<InvoicePaymentCreateInput, InvoicePaymentUncheckedCreateInput>
  }

  /**
   * InvoicePayment createMany
   */
  export type InvoicePaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoicePayments.
     */
    data: InvoicePaymentCreateManyInput | InvoicePaymentCreateManyInput[]
  }

  /**
   * InvoicePayment createManyAndReturn
   */
  export type InvoicePaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * The data used to create many InvoicePayments.
     */
    data: InvoicePaymentCreateManyInput | InvoicePaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoicePayment update
   */
  export type InvoicePaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoicePayment.
     */
    data: XOR<InvoicePaymentUpdateInput, InvoicePaymentUncheckedUpdateInput>
    /**
     * Choose, which InvoicePayment to update.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment updateMany
   */
  export type InvoicePaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoicePayments.
     */
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyInput>
    /**
     * Filter which InvoicePayments to update
     */
    where?: InvoicePaymentWhereInput
    /**
     * Limit how many InvoicePayments to update.
     */
    limit?: number
  }

  /**
   * InvoicePayment updateManyAndReturn
   */
  export type InvoicePaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * The data used to update InvoicePayments.
     */
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyInput>
    /**
     * Filter which InvoicePayments to update
     */
    where?: InvoicePaymentWhereInput
    /**
     * Limit how many InvoicePayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoicePayment upsert
   */
  export type InvoicePaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoicePayment to update in case it exists.
     */
    where: InvoicePaymentWhereUniqueInput
    /**
     * In case the InvoicePayment found by the `where` argument doesn't exist, create a new InvoicePayment with this data.
     */
    create: XOR<InvoicePaymentCreateInput, InvoicePaymentUncheckedCreateInput>
    /**
     * In case the InvoicePayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoicePaymentUpdateInput, InvoicePaymentUncheckedUpdateInput>
  }

  /**
   * InvoicePayment delete
   */
  export type InvoicePaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
    /**
     * Filter which InvoicePayment to delete.
     */
    where: InvoicePaymentWhereUniqueInput
  }

  /**
   * InvoicePayment deleteMany
   */
  export type InvoicePaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoicePayments to delete
     */
    where?: InvoicePaymentWhereInput
    /**
     * Limit how many InvoicePayments to delete.
     */
    limit?: number
  }

  /**
   * InvoicePayment without action
   */
  export type InvoicePaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoicePayment
     */
    select?: InvoicePaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InvoicePayment
     */
    omit?: InvoicePaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoicePaymentInclude<ExtArgs> | null
  }


  /**
   * Model ExpenseCategory
   */

  export type AggregateExpenseCategory = {
    _count: ExpenseCategoryCountAggregateOutputType | null
    _avg: ExpenseCategoryAvgAggregateOutputType | null
    _sum: ExpenseCategorySumAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  export type ExpenseCategoryAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ExpenseCategorySumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ExpenseCategoryMinAggregateOutputType = {
    id: string | null
    company: string | null
    name: string | null
    color: string | null
    icon: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type ExpenseCategoryMaxAggregateOutputType = {
    id: string | null
    company: string | null
    name: string | null
    color: string | null
    icon: string | null
    isActive: boolean | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type ExpenseCategoryCountAggregateOutputType = {
    id: number
    company: number
    name: number
    color: number
    icon: number
    isActive: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    needsSync: number
    _all: number
  }


  export type ExpenseCategoryAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ExpenseCategorySumAggregateInputType = {
    sortOrder?: true
  }

  export type ExpenseCategoryMinAggregateInputType = {
    id?: true
    company?: true
    name?: true
    color?: true
    icon?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type ExpenseCategoryMaxAggregateInputType = {
    id?: true
    company?: true
    name?: true
    color?: true
    icon?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type ExpenseCategoryCountAggregateInputType = {
    id?: true
    company?: true
    name?: true
    color?: true
    icon?: true
    isActive?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
    _all?: true
  }

  export type ExpenseCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategory to aggregate.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExpenseCategories
    **/
    _count?: true | ExpenseCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseCategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseCategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type GetExpenseCategoryAggregateType<T extends ExpenseCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateExpenseCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpenseCategory[P]>
      : GetScalarType<T[P], AggregateExpenseCategory[P]>
  }




  export type ExpenseCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseCategoryWhereInput
    orderBy?: ExpenseCategoryOrderByWithAggregationInput | ExpenseCategoryOrderByWithAggregationInput[]
    by: ExpenseCategoryScalarFieldEnum[] | ExpenseCategoryScalarFieldEnum
    having?: ExpenseCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCategoryCountAggregateInputType | true
    _avg?: ExpenseCategoryAvgAggregateInputType
    _sum?: ExpenseCategorySumAggregateInputType
    _min?: ExpenseCategoryMinAggregateInputType
    _max?: ExpenseCategoryMaxAggregateInputType
  }

  export type ExpenseCategoryGroupByOutputType = {
    id: string
    company: string
    name: string
    color: string | null
    icon: string | null
    isActive: boolean
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean
    _count: ExpenseCategoryCountAggregateOutputType | null
    _avg: ExpenseCategoryAvgAggregateOutputType | null
    _sum: ExpenseCategorySumAggregateOutputType | null
    _min: ExpenseCategoryMinAggregateOutputType | null
    _max: ExpenseCategoryMaxAggregateOutputType | null
  }

  type GetExpenseCategoryGroupByPayload<T extends ExpenseCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseCategoryGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    expenses?: boolean | ExpenseCategory$expensesArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }, ExtArgs["result"]["expenseCategory"]>

  export type ExpenseCategorySelectScalar = {
    id?: boolean
    company?: boolean
    name?: boolean
    color?: boolean
    icon?: boolean
    isActive?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }

  export type ExpenseCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company" | "name" | "color" | "icon" | "isActive" | "sortOrder" | "createdAt" | "updatedAt" | "syncId" | "lastSynced" | "needsSync", ExtArgs["result"]["expenseCategory"]>
  export type ExpenseCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | ExpenseCategory$expensesArgs<ExtArgs>
    _count?: boolean | ExpenseCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ExpenseCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ExpenseCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ExpenseCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExpenseCategory"
    objects: {
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company: string
      name: string
      color: string | null
      icon: string | null
      isActive: boolean
      sortOrder: number
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
      needsSync: boolean
    }, ExtArgs["result"]["expenseCategory"]>
    composites: {}
  }

  type ExpenseCategoryGetPayload<S extends boolean | null | undefined | ExpenseCategoryDefaultArgs> = $Result.GetResult<Prisma.$ExpenseCategoryPayload, S>

  type ExpenseCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCategoryCountAggregateInputType | true
    }

  export interface ExpenseCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExpenseCategory'], meta: { name: 'ExpenseCategory' } }
    /**
     * Find zero or one ExpenseCategory that matches the filter.
     * @param {ExpenseCategoryFindUniqueArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseCategoryFindUniqueArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ExpenseCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseCategoryFindUniqueOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseCategoryFindFirstArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ExpenseCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindFirstOrThrowArgs} args - Arguments to find a ExpenseCategory
     * @example
     * // Get one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ExpenseCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany()
     * 
     * // Get first 10 ExpenseCategories
     * const expenseCategories = await prisma.expenseCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseCategoryFindManyArgs>(args?: SelectSubset<T, ExpenseCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ExpenseCategory.
     * @param {ExpenseCategoryCreateArgs} args - Arguments to create a ExpenseCategory.
     * @example
     * // Create one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.create({
     *   data: {
     *     // ... data to create a ExpenseCategory
     *   }
     * })
     * 
     */
    create<T extends ExpenseCategoryCreateArgs>(args: SelectSubset<T, ExpenseCategoryCreateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ExpenseCategories.
     * @param {ExpenseCategoryCreateManyArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCategoryCreateManyArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExpenseCategories and returns the data saved in the database.
     * @param {ExpenseCategoryCreateManyAndReturnArgs} args - Arguments to create many ExpenseCategories.
     * @example
     * // Create many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ExpenseCategory.
     * @param {ExpenseCategoryDeleteArgs} args - Arguments to delete one ExpenseCategory.
     * @example
     * // Delete one ExpenseCategory
     * const ExpenseCategory = await prisma.expenseCategory.delete({
     *   where: {
     *     // ... filter to delete one ExpenseCategory
     *   }
     * })
     * 
     */
    delete<T extends ExpenseCategoryDeleteArgs>(args: SelectSubset<T, ExpenseCategoryDeleteArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ExpenseCategory.
     * @param {ExpenseCategoryUpdateArgs} args - Arguments to update one ExpenseCategory.
     * @example
     * // Update one ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseCategoryUpdateArgs>(args: SelectSubset<T, ExpenseCategoryUpdateArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ExpenseCategories.
     * @param {ExpenseCategoryDeleteManyArgs} args - Arguments to filter ExpenseCategories to delete.
     * @example
     * // Delete a few ExpenseCategories
     * const { count } = await prisma.expenseCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseCategoryDeleteManyArgs>(args?: SelectSubset<T, ExpenseCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseCategoryUpdateManyArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExpenseCategories and returns the data updated in the database.
     * @param {ExpenseCategoryUpdateManyAndReturnArgs} args - Arguments to update many ExpenseCategories.
     * @example
     * // Update many ExpenseCategories
     * const expenseCategory = await prisma.expenseCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExpenseCategories and only return the `id`
     * const expenseCategoryWithIdOnly = await prisma.expenseCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ExpenseCategory.
     * @param {ExpenseCategoryUpsertArgs} args - Arguments to update or create a ExpenseCategory.
     * @example
     * // Update or create a ExpenseCategory
     * const expenseCategory = await prisma.expenseCategory.upsert({
     *   create: {
     *     // ... data to create a ExpenseCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExpenseCategory we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseCategoryUpsertArgs>(args: SelectSubset<T, ExpenseCategoryUpsertArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ExpenseCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryCountArgs} args - Arguments to filter ExpenseCategories to count.
     * @example
     * // Count the number of ExpenseCategories
     * const count = await prisma.expenseCategory.count({
     *   where: {
     *     // ... the filter for the ExpenseCategories we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCategoryCountArgs>(
      args?: Subset<T, ExpenseCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseCategoryAggregateArgs>(args: Subset<T, ExpenseCategoryAggregateArgs>): Prisma.PrismaPromise<GetExpenseCategoryAggregateType<T>>

    /**
     * Group by ExpenseCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseCategoryGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExpenseCategory model
   */
  readonly fields: ExpenseCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExpenseCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenses<T extends ExpenseCategory$expensesArgs<ExtArgs> = {}>(args?: Subset<T, ExpenseCategory$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExpenseCategory model
   */
  interface ExpenseCategoryFieldRefs {
    readonly id: FieldRef<"ExpenseCategory", 'String'>
    readonly company: FieldRef<"ExpenseCategory", 'String'>
    readonly name: FieldRef<"ExpenseCategory", 'String'>
    readonly color: FieldRef<"ExpenseCategory", 'String'>
    readonly icon: FieldRef<"ExpenseCategory", 'String'>
    readonly isActive: FieldRef<"ExpenseCategory", 'Boolean'>
    readonly sortOrder: FieldRef<"ExpenseCategory", 'Int'>
    readonly createdAt: FieldRef<"ExpenseCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"ExpenseCategory", 'DateTime'>
    readonly syncId: FieldRef<"ExpenseCategory", 'String'>
    readonly lastSynced: FieldRef<"ExpenseCategory", 'DateTime'>
    readonly needsSync: FieldRef<"ExpenseCategory", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ExpenseCategory findUnique
   */
  export type ExpenseCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findUniqueOrThrow
   */
  export type ExpenseCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory findFirst
   */
  export type ExpenseCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findFirstOrThrow
   */
  export type ExpenseCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategory to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExpenseCategories.
     */
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory findMany
   */
  export type ExpenseCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter, which ExpenseCategories to fetch.
     */
    where?: ExpenseCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExpenseCategories to fetch.
     */
    orderBy?: ExpenseCategoryOrderByWithRelationInput | ExpenseCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExpenseCategories.
     */
    cursor?: ExpenseCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExpenseCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExpenseCategories.
     */
    skip?: number
    distinct?: ExpenseCategoryScalarFieldEnum | ExpenseCategoryScalarFieldEnum[]
  }

  /**
   * ExpenseCategory create
   */
  export type ExpenseCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
  }

  /**
   * ExpenseCategory createMany
   */
  export type ExpenseCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
  }

  /**
   * ExpenseCategory createManyAndReturn
   */
  export type ExpenseCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many ExpenseCategories.
     */
    data: ExpenseCategoryCreateManyInput | ExpenseCategoryCreateManyInput[]
  }

  /**
   * ExpenseCategory update
   */
  export type ExpenseCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a ExpenseCategory.
     */
    data: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
    /**
     * Choose, which ExpenseCategory to update.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory updateMany
   */
  export type ExpenseCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to update.
     */
    limit?: number
  }

  /**
   * ExpenseCategory updateManyAndReturn
   */
  export type ExpenseCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * The data used to update ExpenseCategories.
     */
    data: XOR<ExpenseCategoryUpdateManyMutationInput, ExpenseCategoryUncheckedUpdateManyInput>
    /**
     * Filter which ExpenseCategories to update
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to update.
     */
    limit?: number
  }

  /**
   * ExpenseCategory upsert
   */
  export type ExpenseCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the ExpenseCategory to update in case it exists.
     */
    where: ExpenseCategoryWhereUniqueInput
    /**
     * In case the ExpenseCategory found by the `where` argument doesn't exist, create a new ExpenseCategory with this data.
     */
    create: XOR<ExpenseCategoryCreateInput, ExpenseCategoryUncheckedCreateInput>
    /**
     * In case the ExpenseCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseCategoryUpdateInput, ExpenseCategoryUncheckedUpdateInput>
  }

  /**
   * ExpenseCategory delete
   */
  export type ExpenseCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    /**
     * Filter which ExpenseCategory to delete.
     */
    where: ExpenseCategoryWhereUniqueInput
  }

  /**
   * ExpenseCategory deleteMany
   */
  export type ExpenseCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExpenseCategories to delete
     */
    where?: ExpenseCategoryWhereInput
    /**
     * Limit how many ExpenseCategories to delete.
     */
    limit?: number
  }

  /**
   * ExpenseCategory.expenses
   */
  export type ExpenseCategory$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * ExpenseCategory without action
   */
  export type ExpenseCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    amount: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: string | null
    company: string | null
    categoryId: string | null
    description: string | null
    amount: number | null
    expenseDate: Date | null
    paymentMethod: string | null
    reference: string | null
    vendor: string | null
    receiptUrl: string | null
    localReceiptPath: string | null
    notes: string | null
    createdBy: string | null
    createdByName: string | null
    isRecurring: boolean | null
    recurringType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: string | null
    company: string | null
    categoryId: string | null
    description: string | null
    amount: number | null
    expenseDate: Date | null
    paymentMethod: string | null
    reference: string | null
    vendor: string | null
    receiptUrl: string | null
    localReceiptPath: string | null
    notes: string | null
    createdBy: string | null
    createdByName: string | null
    isRecurring: boolean | null
    recurringType: string | null
    createdAt: Date | null
    updatedAt: Date | null
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    company: number
    categoryId: number
    description: number
    amount: number
    expenseDate: number
    paymentMethod: number
    reference: number
    vendor: number
    receiptUrl: number
    localReceiptPath: number
    notes: number
    createdBy: number
    createdByName: number
    isRecurring: number
    recurringType: number
    createdAt: number
    updatedAt: number
    syncId: number
    lastSynced: number
    needsSync: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type ExpenseSumAggregateInputType = {
    amount?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    company?: true
    categoryId?: true
    description?: true
    amount?: true
    expenseDate?: true
    paymentMethod?: true
    reference?: true
    vendor?: true
    receiptUrl?: true
    localReceiptPath?: true
    notes?: true
    createdBy?: true
    createdByName?: true
    isRecurring?: true
    recurringType?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    company?: true
    categoryId?: true
    description?: true
    amount?: true
    expenseDate?: true
    paymentMethod?: true
    reference?: true
    vendor?: true
    receiptUrl?: true
    localReceiptPath?: true
    notes?: true
    createdBy?: true
    createdByName?: true
    isRecurring?: true
    recurringType?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    company?: true
    categoryId?: true
    description?: true
    amount?: true
    expenseDate?: true
    paymentMethod?: true
    reference?: true
    vendor?: true
    receiptUrl?: true
    localReceiptPath?: true
    notes?: true
    createdBy?: true
    createdByName?: true
    isRecurring?: true
    recurringType?: true
    createdAt?: true
    updatedAt?: true
    syncId?: true
    lastSynced?: true
    needsSync?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: string
    company: string
    categoryId: string | null
    description: string
    amount: number
    expenseDate: Date
    paymentMethod: string | null
    reference: string | null
    vendor: string | null
    receiptUrl: string | null
    localReceiptPath: string | null
    notes: string | null
    createdBy: string | null
    createdByName: string | null
    isRecurring: boolean
    recurringType: string | null
    createdAt: Date
    updatedAt: Date
    syncId: string | null
    lastSynced: Date | null
    needsSync: boolean
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    categoryId?: boolean
    description?: boolean
    amount?: boolean
    expenseDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    vendor?: boolean
    receiptUrl?: boolean
    localReceiptPath?: boolean
    notes?: boolean
    createdBy?: boolean
    createdByName?: boolean
    isRecurring?: boolean
    recurringType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    category?: boolean | Expense$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    categoryId?: boolean
    description?: boolean
    amount?: boolean
    expenseDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    vendor?: boolean
    receiptUrl?: boolean
    localReceiptPath?: boolean
    notes?: boolean
    createdBy?: boolean
    createdByName?: boolean
    isRecurring?: boolean
    recurringType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    category?: boolean | Expense$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    categoryId?: boolean
    description?: boolean
    amount?: boolean
    expenseDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    vendor?: boolean
    receiptUrl?: boolean
    localReceiptPath?: boolean
    notes?: boolean
    createdBy?: boolean
    createdByName?: boolean
    isRecurring?: boolean
    recurringType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
    category?: boolean | Expense$categoryArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    company?: boolean
    categoryId?: boolean
    description?: boolean
    amount?: boolean
    expenseDate?: boolean
    paymentMethod?: boolean
    reference?: boolean
    vendor?: boolean
    receiptUrl?: boolean
    localReceiptPath?: boolean
    notes?: boolean
    createdBy?: boolean
    createdByName?: boolean
    isRecurring?: boolean
    recurringType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    syncId?: boolean
    lastSynced?: boolean
    needsSync?: boolean
  }

  export type ExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company" | "categoryId" | "description" | "amount" | "expenseDate" | "paymentMethod" | "reference" | "vendor" | "receiptUrl" | "localReceiptPath" | "notes" | "createdBy" | "createdByName" | "isRecurring" | "recurringType" | "createdAt" | "updatedAt" | "syncId" | "lastSynced" | "needsSync", ExtArgs["result"]["expense"]>
  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Expense$categoryArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Expense$categoryArgs<ExtArgs>
  }
  export type ExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Expense$categoryArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      category: Prisma.$ExpenseCategoryPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company: string
      categoryId: string | null
      description: string
      amount: number
      expenseDate: Date
      paymentMethod: string | null
      reference: string | null
      vendor: string | null
      receiptUrl: string | null
      localReceiptPath: string | null
      notes: string | null
      createdBy: string | null
      createdByName: string | null
      isRecurring: boolean
      recurringType: string | null
      createdAt: Date
      updatedAt: Date
      syncId: string | null
      lastSynced: Date | null
      needsSync: boolean
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses and returns the data updated in the database.
     * @param {ExpenseUpdateManyAndReturnArgs} args - Arguments to update many Expenses.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, ExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Expense$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Expense$categoryArgs<ExtArgs>>): Prisma__ExpenseCategoryClient<$Result.GetResult<Prisma.$ExpenseCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'String'>
    readonly company: FieldRef<"Expense", 'String'>
    readonly categoryId: FieldRef<"Expense", 'String'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly expenseDate: FieldRef<"Expense", 'DateTime'>
    readonly paymentMethod: FieldRef<"Expense", 'String'>
    readonly reference: FieldRef<"Expense", 'String'>
    readonly vendor: FieldRef<"Expense", 'String'>
    readonly receiptUrl: FieldRef<"Expense", 'String'>
    readonly localReceiptPath: FieldRef<"Expense", 'String'>
    readonly notes: FieldRef<"Expense", 'String'>
    readonly createdBy: FieldRef<"Expense", 'String'>
    readonly createdByName: FieldRef<"Expense", 'String'>
    readonly isRecurring: FieldRef<"Expense", 'Boolean'>
    readonly recurringType: FieldRef<"Expense", 'String'>
    readonly createdAt: FieldRef<"Expense", 'DateTime'>
    readonly updatedAt: FieldRef<"Expense", 'DateTime'>
    readonly syncId: FieldRef<"Expense", 'String'>
    readonly lastSynced: FieldRef<"Expense", 'DateTime'>
    readonly needsSync: FieldRef<"Expense", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
  }

  /**
   * Expense updateManyAndReturn
   */
  export type ExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
    /**
     * Limit how many Expenses to delete.
     */
    limit?: number
  }

  /**
   * Expense.category
   */
  export type Expense$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExpenseCategory
     */
    select?: ExpenseCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExpenseCategory
     */
    omit?: ExpenseCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseCategoryInclude<ExtArgs> | null
    where?: ExpenseCategoryWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Expense
     */
    omit?: ExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Model TreasuryMonth
   */

  export type AggregateTreasuryMonth = {
    _count: TreasuryMonthCountAggregateOutputType | null
    _avg: TreasuryMonthAvgAggregateOutputType | null
    _sum: TreasuryMonthSumAggregateOutputType | null
    _min: TreasuryMonthMinAggregateOutputType | null
    _max: TreasuryMonthMaxAggregateOutputType | null
  }

  export type TreasuryMonthAvgAggregateOutputType = {
    year: number | null
    month: number | null
    totalIncome: number | null
    totalExpenses: number | null
    balance: number | null
  }

  export type TreasuryMonthSumAggregateOutputType = {
    year: number | null
    month: number | null
    totalIncome: number | null
    totalExpenses: number | null
    balance: number | null
  }

  export type TreasuryMonthMinAggregateOutputType = {
    id: string | null
    company: string | null
    year: number | null
    month: number | null
    totalIncome: number | null
    totalExpenses: number | null
    balance: number | null
    expensesByCategory: string | null
    lastUpdated: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type TreasuryMonthMaxAggregateOutputType = {
    id: string | null
    company: string | null
    year: number | null
    month: number | null
    totalIncome: number | null
    totalExpenses: number | null
    balance: number | null
    expensesByCategory: string | null
    lastUpdated: Date | null
    syncId: string | null
    needsSync: boolean | null
  }

  export type TreasuryMonthCountAggregateOutputType = {
    id: number
    company: number
    year: number
    month: number
    totalIncome: number
    totalExpenses: number
    balance: number
    expensesByCategory: number
    lastUpdated: number
    syncId: number
    needsSync: number
    _all: number
  }


  export type TreasuryMonthAvgAggregateInputType = {
    year?: true
    month?: true
    totalIncome?: true
    totalExpenses?: true
    balance?: true
  }

  export type TreasuryMonthSumAggregateInputType = {
    year?: true
    month?: true
    totalIncome?: true
    totalExpenses?: true
    balance?: true
  }

  export type TreasuryMonthMinAggregateInputType = {
    id?: true
    company?: true
    year?: true
    month?: true
    totalIncome?: true
    totalExpenses?: true
    balance?: true
    expensesByCategory?: true
    lastUpdated?: true
    syncId?: true
    needsSync?: true
  }

  export type TreasuryMonthMaxAggregateInputType = {
    id?: true
    company?: true
    year?: true
    month?: true
    totalIncome?: true
    totalExpenses?: true
    balance?: true
    expensesByCategory?: true
    lastUpdated?: true
    syncId?: true
    needsSync?: true
  }

  export type TreasuryMonthCountAggregateInputType = {
    id?: true
    company?: true
    year?: true
    month?: true
    totalIncome?: true
    totalExpenses?: true
    balance?: true
    expensesByCategory?: true
    lastUpdated?: true
    syncId?: true
    needsSync?: true
    _all?: true
  }

  export type TreasuryMonthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreasuryMonth to aggregate.
     */
    where?: TreasuryMonthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreasuryMonths to fetch.
     */
    orderBy?: TreasuryMonthOrderByWithRelationInput | TreasuryMonthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TreasuryMonthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreasuryMonths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreasuryMonths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TreasuryMonths
    **/
    _count?: true | TreasuryMonthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TreasuryMonthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TreasuryMonthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TreasuryMonthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TreasuryMonthMaxAggregateInputType
  }

  export type GetTreasuryMonthAggregateType<T extends TreasuryMonthAggregateArgs> = {
        [P in keyof T & keyof AggregateTreasuryMonth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTreasuryMonth[P]>
      : GetScalarType<T[P], AggregateTreasuryMonth[P]>
  }




  export type TreasuryMonthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TreasuryMonthWhereInput
    orderBy?: TreasuryMonthOrderByWithAggregationInput | TreasuryMonthOrderByWithAggregationInput[]
    by: TreasuryMonthScalarFieldEnum[] | TreasuryMonthScalarFieldEnum
    having?: TreasuryMonthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TreasuryMonthCountAggregateInputType | true
    _avg?: TreasuryMonthAvgAggregateInputType
    _sum?: TreasuryMonthSumAggregateInputType
    _min?: TreasuryMonthMinAggregateInputType
    _max?: TreasuryMonthMaxAggregateInputType
  }

  export type TreasuryMonthGroupByOutputType = {
    id: string
    company: string
    year: number
    month: number
    totalIncome: number
    totalExpenses: number
    balance: number
    expensesByCategory: string | null
    lastUpdated: Date
    syncId: string | null
    needsSync: boolean
    _count: TreasuryMonthCountAggregateOutputType | null
    _avg: TreasuryMonthAvgAggregateOutputType | null
    _sum: TreasuryMonthSumAggregateOutputType | null
    _min: TreasuryMonthMinAggregateOutputType | null
    _max: TreasuryMonthMaxAggregateOutputType | null
  }

  type GetTreasuryMonthGroupByPayload<T extends TreasuryMonthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TreasuryMonthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TreasuryMonthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TreasuryMonthGroupByOutputType[P]>
            : GetScalarType<T[P], TreasuryMonthGroupByOutputType[P]>
        }
      >
    >


  export type TreasuryMonthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    year?: boolean
    month?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    balance?: boolean
    expensesByCategory?: boolean
    lastUpdated?: boolean
    syncId?: boolean
    needsSync?: boolean
  }, ExtArgs["result"]["treasuryMonth"]>

  export type TreasuryMonthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    year?: boolean
    month?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    balance?: boolean
    expensesByCategory?: boolean
    lastUpdated?: boolean
    syncId?: boolean
    needsSync?: boolean
  }, ExtArgs["result"]["treasuryMonth"]>

  export type TreasuryMonthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company?: boolean
    year?: boolean
    month?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    balance?: boolean
    expensesByCategory?: boolean
    lastUpdated?: boolean
    syncId?: boolean
    needsSync?: boolean
  }, ExtArgs["result"]["treasuryMonth"]>

  export type TreasuryMonthSelectScalar = {
    id?: boolean
    company?: boolean
    year?: boolean
    month?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    balance?: boolean
    expensesByCategory?: boolean
    lastUpdated?: boolean
    syncId?: boolean
    needsSync?: boolean
  }

  export type TreasuryMonthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company" | "year" | "month" | "totalIncome" | "totalExpenses" | "balance" | "expensesByCategory" | "lastUpdated" | "syncId" | "needsSync", ExtArgs["result"]["treasuryMonth"]>

  export type $TreasuryMonthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TreasuryMonth"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company: string
      year: number
      month: number
      totalIncome: number
      totalExpenses: number
      balance: number
      expensesByCategory: string | null
      lastUpdated: Date
      syncId: string | null
      needsSync: boolean
    }, ExtArgs["result"]["treasuryMonth"]>
    composites: {}
  }

  type TreasuryMonthGetPayload<S extends boolean | null | undefined | TreasuryMonthDefaultArgs> = $Result.GetResult<Prisma.$TreasuryMonthPayload, S>

  type TreasuryMonthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TreasuryMonthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TreasuryMonthCountAggregateInputType | true
    }

  export interface TreasuryMonthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TreasuryMonth'], meta: { name: 'TreasuryMonth' } }
    /**
     * Find zero or one TreasuryMonth that matches the filter.
     * @param {TreasuryMonthFindUniqueArgs} args - Arguments to find a TreasuryMonth
     * @example
     * // Get one TreasuryMonth
     * const treasuryMonth = await prisma.treasuryMonth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TreasuryMonthFindUniqueArgs>(args: SelectSubset<T, TreasuryMonthFindUniqueArgs<ExtArgs>>): Prisma__TreasuryMonthClient<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TreasuryMonth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TreasuryMonthFindUniqueOrThrowArgs} args - Arguments to find a TreasuryMonth
     * @example
     * // Get one TreasuryMonth
     * const treasuryMonth = await prisma.treasuryMonth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TreasuryMonthFindUniqueOrThrowArgs>(args: SelectSubset<T, TreasuryMonthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TreasuryMonthClient<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TreasuryMonth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasuryMonthFindFirstArgs} args - Arguments to find a TreasuryMonth
     * @example
     * // Get one TreasuryMonth
     * const treasuryMonth = await prisma.treasuryMonth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TreasuryMonthFindFirstArgs>(args?: SelectSubset<T, TreasuryMonthFindFirstArgs<ExtArgs>>): Prisma__TreasuryMonthClient<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TreasuryMonth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasuryMonthFindFirstOrThrowArgs} args - Arguments to find a TreasuryMonth
     * @example
     * // Get one TreasuryMonth
     * const treasuryMonth = await prisma.treasuryMonth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TreasuryMonthFindFirstOrThrowArgs>(args?: SelectSubset<T, TreasuryMonthFindFirstOrThrowArgs<ExtArgs>>): Prisma__TreasuryMonthClient<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TreasuryMonths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasuryMonthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TreasuryMonths
     * const treasuryMonths = await prisma.treasuryMonth.findMany()
     * 
     * // Get first 10 TreasuryMonths
     * const treasuryMonths = await prisma.treasuryMonth.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const treasuryMonthWithIdOnly = await prisma.treasuryMonth.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TreasuryMonthFindManyArgs>(args?: SelectSubset<T, TreasuryMonthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TreasuryMonth.
     * @param {TreasuryMonthCreateArgs} args - Arguments to create a TreasuryMonth.
     * @example
     * // Create one TreasuryMonth
     * const TreasuryMonth = await prisma.treasuryMonth.create({
     *   data: {
     *     // ... data to create a TreasuryMonth
     *   }
     * })
     * 
     */
    create<T extends TreasuryMonthCreateArgs>(args: SelectSubset<T, TreasuryMonthCreateArgs<ExtArgs>>): Prisma__TreasuryMonthClient<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TreasuryMonths.
     * @param {TreasuryMonthCreateManyArgs} args - Arguments to create many TreasuryMonths.
     * @example
     * // Create many TreasuryMonths
     * const treasuryMonth = await prisma.treasuryMonth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TreasuryMonthCreateManyArgs>(args?: SelectSubset<T, TreasuryMonthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TreasuryMonths and returns the data saved in the database.
     * @param {TreasuryMonthCreateManyAndReturnArgs} args - Arguments to create many TreasuryMonths.
     * @example
     * // Create many TreasuryMonths
     * const treasuryMonth = await prisma.treasuryMonth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TreasuryMonths and only return the `id`
     * const treasuryMonthWithIdOnly = await prisma.treasuryMonth.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TreasuryMonthCreateManyAndReturnArgs>(args?: SelectSubset<T, TreasuryMonthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TreasuryMonth.
     * @param {TreasuryMonthDeleteArgs} args - Arguments to delete one TreasuryMonth.
     * @example
     * // Delete one TreasuryMonth
     * const TreasuryMonth = await prisma.treasuryMonth.delete({
     *   where: {
     *     // ... filter to delete one TreasuryMonth
     *   }
     * })
     * 
     */
    delete<T extends TreasuryMonthDeleteArgs>(args: SelectSubset<T, TreasuryMonthDeleteArgs<ExtArgs>>): Prisma__TreasuryMonthClient<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TreasuryMonth.
     * @param {TreasuryMonthUpdateArgs} args - Arguments to update one TreasuryMonth.
     * @example
     * // Update one TreasuryMonth
     * const treasuryMonth = await prisma.treasuryMonth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TreasuryMonthUpdateArgs>(args: SelectSubset<T, TreasuryMonthUpdateArgs<ExtArgs>>): Prisma__TreasuryMonthClient<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TreasuryMonths.
     * @param {TreasuryMonthDeleteManyArgs} args - Arguments to filter TreasuryMonths to delete.
     * @example
     * // Delete a few TreasuryMonths
     * const { count } = await prisma.treasuryMonth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TreasuryMonthDeleteManyArgs>(args?: SelectSubset<T, TreasuryMonthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TreasuryMonths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasuryMonthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TreasuryMonths
     * const treasuryMonth = await prisma.treasuryMonth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TreasuryMonthUpdateManyArgs>(args: SelectSubset<T, TreasuryMonthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TreasuryMonths and returns the data updated in the database.
     * @param {TreasuryMonthUpdateManyAndReturnArgs} args - Arguments to update many TreasuryMonths.
     * @example
     * // Update many TreasuryMonths
     * const treasuryMonth = await prisma.treasuryMonth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TreasuryMonths and only return the `id`
     * const treasuryMonthWithIdOnly = await prisma.treasuryMonth.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TreasuryMonthUpdateManyAndReturnArgs>(args: SelectSubset<T, TreasuryMonthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TreasuryMonth.
     * @param {TreasuryMonthUpsertArgs} args - Arguments to update or create a TreasuryMonth.
     * @example
     * // Update or create a TreasuryMonth
     * const treasuryMonth = await prisma.treasuryMonth.upsert({
     *   create: {
     *     // ... data to create a TreasuryMonth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TreasuryMonth we want to update
     *   }
     * })
     */
    upsert<T extends TreasuryMonthUpsertArgs>(args: SelectSubset<T, TreasuryMonthUpsertArgs<ExtArgs>>): Prisma__TreasuryMonthClient<$Result.GetResult<Prisma.$TreasuryMonthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TreasuryMonths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasuryMonthCountArgs} args - Arguments to filter TreasuryMonths to count.
     * @example
     * // Count the number of TreasuryMonths
     * const count = await prisma.treasuryMonth.count({
     *   where: {
     *     // ... the filter for the TreasuryMonths we want to count
     *   }
     * })
    **/
    count<T extends TreasuryMonthCountArgs>(
      args?: Subset<T, TreasuryMonthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TreasuryMonthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TreasuryMonth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasuryMonthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TreasuryMonthAggregateArgs>(args: Subset<T, TreasuryMonthAggregateArgs>): Prisma.PrismaPromise<GetTreasuryMonthAggregateType<T>>

    /**
     * Group by TreasuryMonth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TreasuryMonthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TreasuryMonthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TreasuryMonthGroupByArgs['orderBy'] }
        : { orderBy?: TreasuryMonthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TreasuryMonthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTreasuryMonthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TreasuryMonth model
   */
  readonly fields: TreasuryMonthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TreasuryMonth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TreasuryMonthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TreasuryMonth model
   */
  interface TreasuryMonthFieldRefs {
    readonly id: FieldRef<"TreasuryMonth", 'String'>
    readonly company: FieldRef<"TreasuryMonth", 'String'>
    readonly year: FieldRef<"TreasuryMonth", 'Int'>
    readonly month: FieldRef<"TreasuryMonth", 'Int'>
    readonly totalIncome: FieldRef<"TreasuryMonth", 'Float'>
    readonly totalExpenses: FieldRef<"TreasuryMonth", 'Float'>
    readonly balance: FieldRef<"TreasuryMonth", 'Float'>
    readonly expensesByCategory: FieldRef<"TreasuryMonth", 'String'>
    readonly lastUpdated: FieldRef<"TreasuryMonth", 'DateTime'>
    readonly syncId: FieldRef<"TreasuryMonth", 'String'>
    readonly needsSync: FieldRef<"TreasuryMonth", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * TreasuryMonth findUnique
   */
  export type TreasuryMonthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * Filter, which TreasuryMonth to fetch.
     */
    where: TreasuryMonthWhereUniqueInput
  }

  /**
   * TreasuryMonth findUniqueOrThrow
   */
  export type TreasuryMonthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * Filter, which TreasuryMonth to fetch.
     */
    where: TreasuryMonthWhereUniqueInput
  }

  /**
   * TreasuryMonth findFirst
   */
  export type TreasuryMonthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * Filter, which TreasuryMonth to fetch.
     */
    where?: TreasuryMonthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreasuryMonths to fetch.
     */
    orderBy?: TreasuryMonthOrderByWithRelationInput | TreasuryMonthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreasuryMonths.
     */
    cursor?: TreasuryMonthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreasuryMonths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreasuryMonths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreasuryMonths.
     */
    distinct?: TreasuryMonthScalarFieldEnum | TreasuryMonthScalarFieldEnum[]
  }

  /**
   * TreasuryMonth findFirstOrThrow
   */
  export type TreasuryMonthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * Filter, which TreasuryMonth to fetch.
     */
    where?: TreasuryMonthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreasuryMonths to fetch.
     */
    orderBy?: TreasuryMonthOrderByWithRelationInput | TreasuryMonthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TreasuryMonths.
     */
    cursor?: TreasuryMonthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreasuryMonths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreasuryMonths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TreasuryMonths.
     */
    distinct?: TreasuryMonthScalarFieldEnum | TreasuryMonthScalarFieldEnum[]
  }

  /**
   * TreasuryMonth findMany
   */
  export type TreasuryMonthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * Filter, which TreasuryMonths to fetch.
     */
    where?: TreasuryMonthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TreasuryMonths to fetch.
     */
    orderBy?: TreasuryMonthOrderByWithRelationInput | TreasuryMonthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TreasuryMonths.
     */
    cursor?: TreasuryMonthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TreasuryMonths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TreasuryMonths.
     */
    skip?: number
    distinct?: TreasuryMonthScalarFieldEnum | TreasuryMonthScalarFieldEnum[]
  }

  /**
   * TreasuryMonth create
   */
  export type TreasuryMonthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * The data needed to create a TreasuryMonth.
     */
    data: XOR<TreasuryMonthCreateInput, TreasuryMonthUncheckedCreateInput>
  }

  /**
   * TreasuryMonth createMany
   */
  export type TreasuryMonthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TreasuryMonths.
     */
    data: TreasuryMonthCreateManyInput | TreasuryMonthCreateManyInput[]
  }

  /**
   * TreasuryMonth createManyAndReturn
   */
  export type TreasuryMonthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * The data used to create many TreasuryMonths.
     */
    data: TreasuryMonthCreateManyInput | TreasuryMonthCreateManyInput[]
  }

  /**
   * TreasuryMonth update
   */
  export type TreasuryMonthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * The data needed to update a TreasuryMonth.
     */
    data: XOR<TreasuryMonthUpdateInput, TreasuryMonthUncheckedUpdateInput>
    /**
     * Choose, which TreasuryMonth to update.
     */
    where: TreasuryMonthWhereUniqueInput
  }

  /**
   * TreasuryMonth updateMany
   */
  export type TreasuryMonthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TreasuryMonths.
     */
    data: XOR<TreasuryMonthUpdateManyMutationInput, TreasuryMonthUncheckedUpdateManyInput>
    /**
     * Filter which TreasuryMonths to update
     */
    where?: TreasuryMonthWhereInput
    /**
     * Limit how many TreasuryMonths to update.
     */
    limit?: number
  }

  /**
   * TreasuryMonth updateManyAndReturn
   */
  export type TreasuryMonthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * The data used to update TreasuryMonths.
     */
    data: XOR<TreasuryMonthUpdateManyMutationInput, TreasuryMonthUncheckedUpdateManyInput>
    /**
     * Filter which TreasuryMonths to update
     */
    where?: TreasuryMonthWhereInput
    /**
     * Limit how many TreasuryMonths to update.
     */
    limit?: number
  }

  /**
   * TreasuryMonth upsert
   */
  export type TreasuryMonthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * The filter to search for the TreasuryMonth to update in case it exists.
     */
    where: TreasuryMonthWhereUniqueInput
    /**
     * In case the TreasuryMonth found by the `where` argument doesn't exist, create a new TreasuryMonth with this data.
     */
    create: XOR<TreasuryMonthCreateInput, TreasuryMonthUncheckedCreateInput>
    /**
     * In case the TreasuryMonth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TreasuryMonthUpdateInput, TreasuryMonthUncheckedUpdateInput>
  }

  /**
   * TreasuryMonth delete
   */
  export type TreasuryMonthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
    /**
     * Filter which TreasuryMonth to delete.
     */
    where: TreasuryMonthWhereUniqueInput
  }

  /**
   * TreasuryMonth deleteMany
   */
  export type TreasuryMonthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TreasuryMonths to delete
     */
    where?: TreasuryMonthWhereInput
    /**
     * Limit how many TreasuryMonths to delete.
     */
    limit?: number
  }

  /**
   * TreasuryMonth without action
   */
  export type TreasuryMonthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TreasuryMonth
     */
    select?: TreasuryMonthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TreasuryMonth
     */
    omit?: TreasuryMonthOmit<ExtArgs> | null
  }


  /**
   * Model SyncQueue
   */

  export type AggregateSyncQueue = {
    _count: SyncQueueCountAggregateOutputType | null
    _avg: SyncQueueAvgAggregateOutputType | null
    _sum: SyncQueueSumAggregateOutputType | null
    _min: SyncQueueMinAggregateOutputType | null
    _max: SyncQueueMaxAggregateOutputType | null
  }

  export type SyncQueueAvgAggregateOutputType = {
    id: number | null
    retries: number | null
  }

  export type SyncQueueSumAggregateOutputType = {
    id: number | null
    retries: number | null
  }

  export type SyncQueueMinAggregateOutputType = {
    id: number | null
    tableName: string | null
    recordId: string | null
    action: string | null
    data: string | null
    createdAt: Date | null
    syncedAt: Date | null
    error: string | null
    retries: number | null
  }

  export type SyncQueueMaxAggregateOutputType = {
    id: number | null
    tableName: string | null
    recordId: string | null
    action: string | null
    data: string | null
    createdAt: Date | null
    syncedAt: Date | null
    error: string | null
    retries: number | null
  }

  export type SyncQueueCountAggregateOutputType = {
    id: number
    tableName: number
    recordId: number
    action: number
    data: number
    createdAt: number
    syncedAt: number
    error: number
    retries: number
    _all: number
  }


  export type SyncQueueAvgAggregateInputType = {
    id?: true
    retries?: true
  }

  export type SyncQueueSumAggregateInputType = {
    id?: true
    retries?: true
  }

  export type SyncQueueMinAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    data?: true
    createdAt?: true
    syncedAt?: true
    error?: true
    retries?: true
  }

  export type SyncQueueMaxAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    data?: true
    createdAt?: true
    syncedAt?: true
    error?: true
    retries?: true
  }

  export type SyncQueueCountAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    action?: true
    data?: true
    createdAt?: true
    syncedAt?: true
    error?: true
    retries?: true
    _all?: true
  }

  export type SyncQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncQueue to aggregate.
     */
    where?: SyncQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueues to fetch.
     */
    orderBy?: SyncQueueOrderByWithRelationInput | SyncQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncQueues
    **/
    _count?: true | SyncQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncQueueMaxAggregateInputType
  }

  export type GetSyncQueueAggregateType<T extends SyncQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncQueue[P]>
      : GetScalarType<T[P], AggregateSyncQueue[P]>
  }




  export type SyncQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncQueueWhereInput
    orderBy?: SyncQueueOrderByWithAggregationInput | SyncQueueOrderByWithAggregationInput[]
    by: SyncQueueScalarFieldEnum[] | SyncQueueScalarFieldEnum
    having?: SyncQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncQueueCountAggregateInputType | true
    _avg?: SyncQueueAvgAggregateInputType
    _sum?: SyncQueueSumAggregateInputType
    _min?: SyncQueueMinAggregateInputType
    _max?: SyncQueueMaxAggregateInputType
  }

  export type SyncQueueGroupByOutputType = {
    id: number
    tableName: string
    recordId: string
    action: string
    data: string
    createdAt: Date
    syncedAt: Date | null
    error: string | null
    retries: number
    _count: SyncQueueCountAggregateOutputType | null
    _avg: SyncQueueAvgAggregateOutputType | null
    _sum: SyncQueueSumAggregateOutputType | null
    _min: SyncQueueMinAggregateOutputType | null
    _max: SyncQueueMaxAggregateOutputType | null
  }

  type GetSyncQueueGroupByPayload<T extends SyncQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncQueueGroupByOutputType[P]>
            : GetScalarType<T[P], SyncQueueGroupByOutputType[P]>
        }
      >
    >


  export type SyncQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    data?: boolean
    createdAt?: boolean
    syncedAt?: boolean
    error?: boolean
    retries?: boolean
  }, ExtArgs["result"]["syncQueue"]>

  export type SyncQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    data?: boolean
    createdAt?: boolean
    syncedAt?: boolean
    error?: boolean
    retries?: boolean
  }, ExtArgs["result"]["syncQueue"]>

  export type SyncQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    data?: boolean
    createdAt?: boolean
    syncedAt?: boolean
    error?: boolean
    retries?: boolean
  }, ExtArgs["result"]["syncQueue"]>

  export type SyncQueueSelectScalar = {
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    action?: boolean
    data?: boolean
    createdAt?: boolean
    syncedAt?: boolean
    error?: boolean
    retries?: boolean
  }

  export type SyncQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableName" | "recordId" | "action" | "data" | "createdAt" | "syncedAt" | "error" | "retries", ExtArgs["result"]["syncQueue"]>

  export type $SyncQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tableName: string
      recordId: string
      action: string
      data: string
      createdAt: Date
      syncedAt: Date | null
      error: string | null
      retries: number
    }, ExtArgs["result"]["syncQueue"]>
    composites: {}
  }

  type SyncQueueGetPayload<S extends boolean | null | undefined | SyncQueueDefaultArgs> = $Result.GetResult<Prisma.$SyncQueuePayload, S>

  type SyncQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncQueueCountAggregateInputType | true
    }

  export interface SyncQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncQueue'], meta: { name: 'SyncQueue' } }
    /**
     * Find zero or one SyncQueue that matches the filter.
     * @param {SyncQueueFindUniqueArgs} args - Arguments to find a SyncQueue
     * @example
     * // Get one SyncQueue
     * const syncQueue = await prisma.syncQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncQueueFindUniqueArgs>(args: SelectSubset<T, SyncQueueFindUniqueArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncQueueFindUniqueOrThrowArgs} args - Arguments to find a SyncQueue
     * @example
     * // Get one SyncQueue
     * const syncQueue = await prisma.syncQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueFindFirstArgs} args - Arguments to find a SyncQueue
     * @example
     * // Get one SyncQueue
     * const syncQueue = await prisma.syncQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncQueueFindFirstArgs>(args?: SelectSubset<T, SyncQueueFindFirstArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueFindFirstOrThrowArgs} args - Arguments to find a SyncQueue
     * @example
     * // Get one SyncQueue
     * const syncQueue = await prisma.syncQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncQueues
     * const syncQueues = await prisma.syncQueue.findMany()
     * 
     * // Get first 10 SyncQueues
     * const syncQueues = await prisma.syncQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncQueueWithIdOnly = await prisma.syncQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncQueueFindManyArgs>(args?: SelectSubset<T, SyncQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncQueue.
     * @param {SyncQueueCreateArgs} args - Arguments to create a SyncQueue.
     * @example
     * // Create one SyncQueue
     * const SyncQueue = await prisma.syncQueue.create({
     *   data: {
     *     // ... data to create a SyncQueue
     *   }
     * })
     * 
     */
    create<T extends SyncQueueCreateArgs>(args: SelectSubset<T, SyncQueueCreateArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncQueues.
     * @param {SyncQueueCreateManyArgs} args - Arguments to create many SyncQueues.
     * @example
     * // Create many SyncQueues
     * const syncQueue = await prisma.syncQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncQueueCreateManyArgs>(args?: SelectSubset<T, SyncQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncQueues and returns the data saved in the database.
     * @param {SyncQueueCreateManyAndReturnArgs} args - Arguments to create many SyncQueues.
     * @example
     * // Create many SyncQueues
     * const syncQueue = await prisma.syncQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncQueues and only return the `id`
     * const syncQueueWithIdOnly = await prisma.syncQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncQueue.
     * @param {SyncQueueDeleteArgs} args - Arguments to delete one SyncQueue.
     * @example
     * // Delete one SyncQueue
     * const SyncQueue = await prisma.syncQueue.delete({
     *   where: {
     *     // ... filter to delete one SyncQueue
     *   }
     * })
     * 
     */
    delete<T extends SyncQueueDeleteArgs>(args: SelectSubset<T, SyncQueueDeleteArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncQueue.
     * @param {SyncQueueUpdateArgs} args - Arguments to update one SyncQueue.
     * @example
     * // Update one SyncQueue
     * const syncQueue = await prisma.syncQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncQueueUpdateArgs>(args: SelectSubset<T, SyncQueueUpdateArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncQueues.
     * @param {SyncQueueDeleteManyArgs} args - Arguments to filter SyncQueues to delete.
     * @example
     * // Delete a few SyncQueues
     * const { count } = await prisma.syncQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncQueueDeleteManyArgs>(args?: SelectSubset<T, SyncQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncQueues
     * const syncQueue = await prisma.syncQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncQueueUpdateManyArgs>(args: SelectSubset<T, SyncQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncQueues and returns the data updated in the database.
     * @param {SyncQueueUpdateManyAndReturnArgs} args - Arguments to update many SyncQueues.
     * @example
     * // Update many SyncQueues
     * const syncQueue = await prisma.syncQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncQueues and only return the `id`
     * const syncQueueWithIdOnly = await prisma.syncQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncQueue.
     * @param {SyncQueueUpsertArgs} args - Arguments to update or create a SyncQueue.
     * @example
     * // Update or create a SyncQueue
     * const syncQueue = await prisma.syncQueue.upsert({
     *   create: {
     *     // ... data to create a SyncQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncQueue we want to update
     *   }
     * })
     */
    upsert<T extends SyncQueueUpsertArgs>(args: SelectSubset<T, SyncQueueUpsertArgs<ExtArgs>>): Prisma__SyncQueueClient<$Result.GetResult<Prisma.$SyncQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueCountArgs} args - Arguments to filter SyncQueues to count.
     * @example
     * // Count the number of SyncQueues
     * const count = await prisma.syncQueue.count({
     *   where: {
     *     // ... the filter for the SyncQueues we want to count
     *   }
     * })
    **/
    count<T extends SyncQueueCountArgs>(
      args?: Subset<T, SyncQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncQueueAggregateArgs>(args: Subset<T, SyncQueueAggregateArgs>): Prisma.PrismaPromise<GetSyncQueueAggregateType<T>>

    /**
     * Group by SyncQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncQueueGroupByArgs['orderBy'] }
        : { orderBy?: SyncQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncQueue model
   */
  readonly fields: SyncQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncQueue model
   */
  interface SyncQueueFieldRefs {
    readonly id: FieldRef<"SyncQueue", 'Int'>
    readonly tableName: FieldRef<"SyncQueue", 'String'>
    readonly recordId: FieldRef<"SyncQueue", 'String'>
    readonly action: FieldRef<"SyncQueue", 'String'>
    readonly data: FieldRef<"SyncQueue", 'String'>
    readonly createdAt: FieldRef<"SyncQueue", 'DateTime'>
    readonly syncedAt: FieldRef<"SyncQueue", 'DateTime'>
    readonly error: FieldRef<"SyncQueue", 'String'>
    readonly retries: FieldRef<"SyncQueue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SyncQueue findUnique
   */
  export type SyncQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * Filter, which SyncQueue to fetch.
     */
    where: SyncQueueWhereUniqueInput
  }

  /**
   * SyncQueue findUniqueOrThrow
   */
  export type SyncQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * Filter, which SyncQueue to fetch.
     */
    where: SyncQueueWhereUniqueInput
  }

  /**
   * SyncQueue findFirst
   */
  export type SyncQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * Filter, which SyncQueue to fetch.
     */
    where?: SyncQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueues to fetch.
     */
    orderBy?: SyncQueueOrderByWithRelationInput | SyncQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncQueues.
     */
    cursor?: SyncQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncQueues.
     */
    distinct?: SyncQueueScalarFieldEnum | SyncQueueScalarFieldEnum[]
  }

  /**
   * SyncQueue findFirstOrThrow
   */
  export type SyncQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * Filter, which SyncQueue to fetch.
     */
    where?: SyncQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueues to fetch.
     */
    orderBy?: SyncQueueOrderByWithRelationInput | SyncQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncQueues.
     */
    cursor?: SyncQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncQueues.
     */
    distinct?: SyncQueueScalarFieldEnum | SyncQueueScalarFieldEnum[]
  }

  /**
   * SyncQueue findMany
   */
  export type SyncQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * Filter, which SyncQueues to fetch.
     */
    where?: SyncQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncQueues to fetch.
     */
    orderBy?: SyncQueueOrderByWithRelationInput | SyncQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncQueues.
     */
    cursor?: SyncQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncQueues.
     */
    skip?: number
    distinct?: SyncQueueScalarFieldEnum | SyncQueueScalarFieldEnum[]
  }

  /**
   * SyncQueue create
   */
  export type SyncQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * The data needed to create a SyncQueue.
     */
    data: XOR<SyncQueueCreateInput, SyncQueueUncheckedCreateInput>
  }

  /**
   * SyncQueue createMany
   */
  export type SyncQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncQueues.
     */
    data: SyncQueueCreateManyInput | SyncQueueCreateManyInput[]
  }

  /**
   * SyncQueue createManyAndReturn
   */
  export type SyncQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * The data used to create many SyncQueues.
     */
    data: SyncQueueCreateManyInput | SyncQueueCreateManyInput[]
  }

  /**
   * SyncQueue update
   */
  export type SyncQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * The data needed to update a SyncQueue.
     */
    data: XOR<SyncQueueUpdateInput, SyncQueueUncheckedUpdateInput>
    /**
     * Choose, which SyncQueue to update.
     */
    where: SyncQueueWhereUniqueInput
  }

  /**
   * SyncQueue updateMany
   */
  export type SyncQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncQueues.
     */
    data: XOR<SyncQueueUpdateManyMutationInput, SyncQueueUncheckedUpdateManyInput>
    /**
     * Filter which SyncQueues to update
     */
    where?: SyncQueueWhereInput
    /**
     * Limit how many SyncQueues to update.
     */
    limit?: number
  }

  /**
   * SyncQueue updateManyAndReturn
   */
  export type SyncQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * The data used to update SyncQueues.
     */
    data: XOR<SyncQueueUpdateManyMutationInput, SyncQueueUncheckedUpdateManyInput>
    /**
     * Filter which SyncQueues to update
     */
    where?: SyncQueueWhereInput
    /**
     * Limit how many SyncQueues to update.
     */
    limit?: number
  }

  /**
   * SyncQueue upsert
   */
  export type SyncQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * The filter to search for the SyncQueue to update in case it exists.
     */
    where: SyncQueueWhereUniqueInput
    /**
     * In case the SyncQueue found by the `where` argument doesn't exist, create a new SyncQueue with this data.
     */
    create: XOR<SyncQueueCreateInput, SyncQueueUncheckedCreateInput>
    /**
     * In case the SyncQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncQueueUpdateInput, SyncQueueUncheckedUpdateInput>
  }

  /**
   * SyncQueue delete
   */
  export type SyncQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
    /**
     * Filter which SyncQueue to delete.
     */
    where: SyncQueueWhereUniqueInput
  }

  /**
   * SyncQueue deleteMany
   */
  export type SyncQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncQueues to delete
     */
    where?: SyncQueueWhereInput
    /**
     * Limit how many SyncQueues to delete.
     */
    limit?: number
  }

  /**
   * SyncQueue without action
   */
  export type SyncQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncQueue
     */
    select?: SyncQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncQueue
     */
    omit?: SyncQueueOmit<ExtArgs> | null
  }


  /**
   * Model SyncStatus
   */

  export type AggregateSyncStatus = {
    _count: SyncStatusCountAggregateOutputType | null
    _avg: SyncStatusAvgAggregateOutputType | null
    _sum: SyncStatusSumAggregateOutputType | null
    _min: SyncStatusMinAggregateOutputType | null
    _max: SyncStatusMaxAggregateOutputType | null
  }

  export type SyncStatusAvgAggregateOutputType = {
    id: number | null
    pendingChanges: number | null
  }

  export type SyncStatusSumAggregateOutputType = {
    id: number | null
    pendingChanges: number | null
  }

  export type SyncStatusMinAggregateOutputType = {
    id: number | null
    lastSyncAt: Date | null
    lastSyncSuccess: boolean | null
    pendingChanges: number | null
    serverUrl: string | null
  }

  export type SyncStatusMaxAggregateOutputType = {
    id: number | null
    lastSyncAt: Date | null
    lastSyncSuccess: boolean | null
    pendingChanges: number | null
    serverUrl: string | null
  }

  export type SyncStatusCountAggregateOutputType = {
    id: number
    lastSyncAt: number
    lastSyncSuccess: number
    pendingChanges: number
    serverUrl: number
    _all: number
  }


  export type SyncStatusAvgAggregateInputType = {
    id?: true
    pendingChanges?: true
  }

  export type SyncStatusSumAggregateInputType = {
    id?: true
    pendingChanges?: true
  }

  export type SyncStatusMinAggregateInputType = {
    id?: true
    lastSyncAt?: true
    lastSyncSuccess?: true
    pendingChanges?: true
    serverUrl?: true
  }

  export type SyncStatusMaxAggregateInputType = {
    id?: true
    lastSyncAt?: true
    lastSyncSuccess?: true
    pendingChanges?: true
    serverUrl?: true
  }

  export type SyncStatusCountAggregateInputType = {
    id?: true
    lastSyncAt?: true
    lastSyncSuccess?: true
    pendingChanges?: true
    serverUrl?: true
    _all?: true
  }

  export type SyncStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncStatus to aggregate.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SyncStatuses
    **/
    _count?: true | SyncStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SyncStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SyncStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SyncStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SyncStatusMaxAggregateInputType
  }

  export type GetSyncStatusAggregateType<T extends SyncStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateSyncStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSyncStatus[P]>
      : GetScalarType<T[P], AggregateSyncStatus[P]>
  }




  export type SyncStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SyncStatusWhereInput
    orderBy?: SyncStatusOrderByWithAggregationInput | SyncStatusOrderByWithAggregationInput[]
    by: SyncStatusScalarFieldEnum[] | SyncStatusScalarFieldEnum
    having?: SyncStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SyncStatusCountAggregateInputType | true
    _avg?: SyncStatusAvgAggregateInputType
    _sum?: SyncStatusSumAggregateInputType
    _min?: SyncStatusMinAggregateInputType
    _max?: SyncStatusMaxAggregateInputType
  }

  export type SyncStatusGroupByOutputType = {
    id: number
    lastSyncAt: Date | null
    lastSyncSuccess: boolean
    pendingChanges: number
    serverUrl: string | null
    _count: SyncStatusCountAggregateOutputType | null
    _avg: SyncStatusAvgAggregateOutputType | null
    _sum: SyncStatusSumAggregateOutputType | null
    _min: SyncStatusMinAggregateOutputType | null
    _max: SyncStatusMaxAggregateOutputType | null
  }

  type GetSyncStatusGroupByPayload<T extends SyncStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SyncStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SyncStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SyncStatusGroupByOutputType[P]>
            : GetScalarType<T[P], SyncStatusGroupByOutputType[P]>
        }
      >
    >


  export type SyncStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSyncAt?: boolean
    lastSyncSuccess?: boolean
    pendingChanges?: boolean
    serverUrl?: boolean
  }, ExtArgs["result"]["syncStatus"]>

  export type SyncStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSyncAt?: boolean
    lastSyncSuccess?: boolean
    pendingChanges?: boolean
    serverUrl?: boolean
  }, ExtArgs["result"]["syncStatus"]>

  export type SyncStatusSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastSyncAt?: boolean
    lastSyncSuccess?: boolean
    pendingChanges?: boolean
    serverUrl?: boolean
  }, ExtArgs["result"]["syncStatus"]>

  export type SyncStatusSelectScalar = {
    id?: boolean
    lastSyncAt?: boolean
    lastSyncSuccess?: boolean
    pendingChanges?: boolean
    serverUrl?: boolean
  }

  export type SyncStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lastSyncAt" | "lastSyncSuccess" | "pendingChanges" | "serverUrl", ExtArgs["result"]["syncStatus"]>

  export type $SyncStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SyncStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      lastSyncAt: Date | null
      lastSyncSuccess: boolean
      pendingChanges: number
      serverUrl: string | null
    }, ExtArgs["result"]["syncStatus"]>
    composites: {}
  }

  type SyncStatusGetPayload<S extends boolean | null | undefined | SyncStatusDefaultArgs> = $Result.GetResult<Prisma.$SyncStatusPayload, S>

  type SyncStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SyncStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SyncStatusCountAggregateInputType | true
    }

  export interface SyncStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SyncStatus'], meta: { name: 'SyncStatus' } }
    /**
     * Find zero or one SyncStatus that matches the filter.
     * @param {SyncStatusFindUniqueArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SyncStatusFindUniqueArgs>(args: SelectSubset<T, SyncStatusFindUniqueArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SyncStatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SyncStatusFindUniqueOrThrowArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SyncStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, SyncStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusFindFirstArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SyncStatusFindFirstArgs>(args?: SelectSubset<T, SyncStatusFindFirstArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SyncStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusFindFirstOrThrowArgs} args - Arguments to find a SyncStatus
     * @example
     * // Get one SyncStatus
     * const syncStatus = await prisma.syncStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SyncStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, SyncStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SyncStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SyncStatuses
     * const syncStatuses = await prisma.syncStatus.findMany()
     * 
     * // Get first 10 SyncStatuses
     * const syncStatuses = await prisma.syncStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const syncStatusWithIdOnly = await prisma.syncStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SyncStatusFindManyArgs>(args?: SelectSubset<T, SyncStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SyncStatus.
     * @param {SyncStatusCreateArgs} args - Arguments to create a SyncStatus.
     * @example
     * // Create one SyncStatus
     * const SyncStatus = await prisma.syncStatus.create({
     *   data: {
     *     // ... data to create a SyncStatus
     *   }
     * })
     * 
     */
    create<T extends SyncStatusCreateArgs>(args: SelectSubset<T, SyncStatusCreateArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SyncStatuses.
     * @param {SyncStatusCreateManyArgs} args - Arguments to create many SyncStatuses.
     * @example
     * // Create many SyncStatuses
     * const syncStatus = await prisma.syncStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SyncStatusCreateManyArgs>(args?: SelectSubset<T, SyncStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SyncStatuses and returns the data saved in the database.
     * @param {SyncStatusCreateManyAndReturnArgs} args - Arguments to create many SyncStatuses.
     * @example
     * // Create many SyncStatuses
     * const syncStatus = await prisma.syncStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SyncStatuses and only return the `id`
     * const syncStatusWithIdOnly = await prisma.syncStatus.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SyncStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, SyncStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SyncStatus.
     * @param {SyncStatusDeleteArgs} args - Arguments to delete one SyncStatus.
     * @example
     * // Delete one SyncStatus
     * const SyncStatus = await prisma.syncStatus.delete({
     *   where: {
     *     // ... filter to delete one SyncStatus
     *   }
     * })
     * 
     */
    delete<T extends SyncStatusDeleteArgs>(args: SelectSubset<T, SyncStatusDeleteArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SyncStatus.
     * @param {SyncStatusUpdateArgs} args - Arguments to update one SyncStatus.
     * @example
     * // Update one SyncStatus
     * const syncStatus = await prisma.syncStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SyncStatusUpdateArgs>(args: SelectSubset<T, SyncStatusUpdateArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SyncStatuses.
     * @param {SyncStatusDeleteManyArgs} args - Arguments to filter SyncStatuses to delete.
     * @example
     * // Delete a few SyncStatuses
     * const { count } = await prisma.syncStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SyncStatusDeleteManyArgs>(args?: SelectSubset<T, SyncStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SyncStatuses
     * const syncStatus = await prisma.syncStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SyncStatusUpdateManyArgs>(args: SelectSubset<T, SyncStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SyncStatuses and returns the data updated in the database.
     * @param {SyncStatusUpdateManyAndReturnArgs} args - Arguments to update many SyncStatuses.
     * @example
     * // Update many SyncStatuses
     * const syncStatus = await prisma.syncStatus.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SyncStatuses and only return the `id`
     * const syncStatusWithIdOnly = await prisma.syncStatus.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SyncStatusUpdateManyAndReturnArgs>(args: SelectSubset<T, SyncStatusUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SyncStatus.
     * @param {SyncStatusUpsertArgs} args - Arguments to update or create a SyncStatus.
     * @example
     * // Update or create a SyncStatus
     * const syncStatus = await prisma.syncStatus.upsert({
     *   create: {
     *     // ... data to create a SyncStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SyncStatus we want to update
     *   }
     * })
     */
    upsert<T extends SyncStatusUpsertArgs>(args: SelectSubset<T, SyncStatusUpsertArgs<ExtArgs>>): Prisma__SyncStatusClient<$Result.GetResult<Prisma.$SyncStatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SyncStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusCountArgs} args - Arguments to filter SyncStatuses to count.
     * @example
     * // Count the number of SyncStatuses
     * const count = await prisma.syncStatus.count({
     *   where: {
     *     // ... the filter for the SyncStatuses we want to count
     *   }
     * })
    **/
    count<T extends SyncStatusCountArgs>(
      args?: Subset<T, SyncStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SyncStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SyncStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SyncStatusAggregateArgs>(args: Subset<T, SyncStatusAggregateArgs>): Prisma.PrismaPromise<GetSyncStatusAggregateType<T>>

    /**
     * Group by SyncStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SyncStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SyncStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SyncStatusGroupByArgs['orderBy'] }
        : { orderBy?: SyncStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SyncStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSyncStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SyncStatus model
   */
  readonly fields: SyncStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SyncStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SyncStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SyncStatus model
   */
  interface SyncStatusFieldRefs {
    readonly id: FieldRef<"SyncStatus", 'Int'>
    readonly lastSyncAt: FieldRef<"SyncStatus", 'DateTime'>
    readonly lastSyncSuccess: FieldRef<"SyncStatus", 'Boolean'>
    readonly pendingChanges: FieldRef<"SyncStatus", 'Int'>
    readonly serverUrl: FieldRef<"SyncStatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SyncStatus findUnique
   */
  export type SyncStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus findUniqueOrThrow
   */
  export type SyncStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus findFirst
   */
  export type SyncStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncStatuses.
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncStatuses.
     */
    distinct?: SyncStatusScalarFieldEnum | SyncStatusScalarFieldEnum[]
  }

  /**
   * SyncStatus findFirstOrThrow
   */
  export type SyncStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * Filter, which SyncStatus to fetch.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SyncStatuses.
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SyncStatuses.
     */
    distinct?: SyncStatusScalarFieldEnum | SyncStatusScalarFieldEnum[]
  }

  /**
   * SyncStatus findMany
   */
  export type SyncStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * Filter, which SyncStatuses to fetch.
     */
    where?: SyncStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SyncStatuses to fetch.
     */
    orderBy?: SyncStatusOrderByWithRelationInput | SyncStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SyncStatuses.
     */
    cursor?: SyncStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SyncStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SyncStatuses.
     */
    skip?: number
    distinct?: SyncStatusScalarFieldEnum | SyncStatusScalarFieldEnum[]
  }

  /**
   * SyncStatus create
   */
  export type SyncStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * The data needed to create a SyncStatus.
     */
    data?: XOR<SyncStatusCreateInput, SyncStatusUncheckedCreateInput>
  }

  /**
   * SyncStatus createMany
   */
  export type SyncStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SyncStatuses.
     */
    data: SyncStatusCreateManyInput | SyncStatusCreateManyInput[]
  }

  /**
   * SyncStatus createManyAndReturn
   */
  export type SyncStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * The data used to create many SyncStatuses.
     */
    data: SyncStatusCreateManyInput | SyncStatusCreateManyInput[]
  }

  /**
   * SyncStatus update
   */
  export type SyncStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * The data needed to update a SyncStatus.
     */
    data: XOR<SyncStatusUpdateInput, SyncStatusUncheckedUpdateInput>
    /**
     * Choose, which SyncStatus to update.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus updateMany
   */
  export type SyncStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SyncStatuses.
     */
    data: XOR<SyncStatusUpdateManyMutationInput, SyncStatusUncheckedUpdateManyInput>
    /**
     * Filter which SyncStatuses to update
     */
    where?: SyncStatusWhereInput
    /**
     * Limit how many SyncStatuses to update.
     */
    limit?: number
  }

  /**
   * SyncStatus updateManyAndReturn
   */
  export type SyncStatusUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * The data used to update SyncStatuses.
     */
    data: XOR<SyncStatusUpdateManyMutationInput, SyncStatusUncheckedUpdateManyInput>
    /**
     * Filter which SyncStatuses to update
     */
    where?: SyncStatusWhereInput
    /**
     * Limit how many SyncStatuses to update.
     */
    limit?: number
  }

  /**
   * SyncStatus upsert
   */
  export type SyncStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * The filter to search for the SyncStatus to update in case it exists.
     */
    where: SyncStatusWhereUniqueInput
    /**
     * In case the SyncStatus found by the `where` argument doesn't exist, create a new SyncStatus with this data.
     */
    create: XOR<SyncStatusCreateInput, SyncStatusUncheckedCreateInput>
    /**
     * In case the SyncStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SyncStatusUpdateInput, SyncStatusUncheckedUpdateInput>
  }

  /**
   * SyncStatus delete
   */
  export type SyncStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
    /**
     * Filter which SyncStatus to delete.
     */
    where: SyncStatusWhereUniqueInput
  }

  /**
   * SyncStatus deleteMany
   */
  export type SyncStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SyncStatuses to delete
     */
    where?: SyncStatusWhereInput
    /**
     * Limit how many SyncStatuses to delete.
     */
    limit?: number
  }

  /**
   * SyncStatus without action
   */
  export type SyncStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SyncStatus
     */
    select?: SyncStatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SyncStatus
     */
    omit?: SyncStatusOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OrganizationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced'
  };

  export type OrganizationScalarFieldEnum = (typeof OrganizationScalarFieldEnum)[keyof typeof OrganizationScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    externalId: 'externalId',
    email: 'email',
    displayName: 'displayName',
    name: 'name',
    pinHash: 'pinHash',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    kind: 'kind',
    channel: 'channel',
    content: 'content',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced',
    needsSync: 'needsSync'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    title: 'title',
    description: 'description',
    status: 'status',
    dueAt: 'dueAt',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced',
    needsSync: 'needsSync'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const TaskRunScalarFieldEnum: {
    id: 'id',
    taskId: 'taskId',
    runType: 'runType',
    result: 'result',
    message: 'message',
    createdAt: 'createdAt',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type TaskRunScalarFieldEnum = (typeof TaskRunScalarFieldEnum)[keyof typeof TaskRunScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    subjectType: 'subjectType',
    subjectId: 'subjectId',
    action: 'action',
    detail: 'detail',
    createdAt: 'createdAt',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const RequisitionScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    priority: 'priority',
    budget: 'budget',
    justification: 'justification',
    status: 'status',
    requesterId: 'requesterId',
    organizationId: 'organizationId',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced',
    needsSync: 'needsSync'
  };

  export type RequisitionScalarFieldEnum = (typeof RequisitionScalarFieldEnum)[keyof typeof RequisitionScalarFieldEnum]


  export const WorkflowStepScalarFieldEnum: {
    id: 'id',
    requisitionId: 'requisitionId',
    reviewerId: 'reviewerId',
    reviewerName: 'reviewerName',
    reviewerLevel: 'reviewerLevel',
    action: 'action',
    isRequired: 'isRequired',
    isCompleted: 'isCompleted',
    comment: 'comment',
    createdAt: 'createdAt',
    completedAt: 'completedAt',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type WorkflowStepScalarFieldEnum = (typeof WorkflowStepScalarFieldEnum)[keyof typeof WorkflowStepScalarFieldEnum]


  export const MeetingScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    creatorId: 'creatorId',
    title: 'title',
    notes: 'notes',
    participants: 'participants',
    status: 'status',
    extractedActions: 'extractedActions',
    tasksCreated: 'tasksCreated',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced',
    needsSync: 'needsSync'
  };

  export type MeetingScalarFieldEnum = (typeof MeetingScalarFieldEnum)[keyof typeof MeetingScalarFieldEnum]


  export const EmailAccountScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    email: 'email',
    providerId: 'providerId',
    providerName: 'providerName',
    provider: 'provider',
    credentials: 'credentials',
    isConnected: 'isConnected',
    unreadCount: 'unreadCount',
    connectedAt: 'connectedAt',
    lastSync: 'lastSync',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type EmailAccountScalarFieldEnum = (typeof EmailAccountScalarFieldEnum)[keyof typeof EmailAccountScalarFieldEnum]


  export const EmailActiveSelectionScalarFieldEnum: {
    id: 'id',
    organizationId: 'organizationId',
    userId: 'userId',
    accountId: 'accountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailActiveSelectionScalarFieldEnum = (typeof EmailActiveSelectionScalarFieldEnum)[keyof typeof EmailActiveSelectionScalarFieldEnum]


  export const NeedScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    category: 'category',
    priority: 'priority',
    budget: 'budget',
    justification: 'justification',
    status: 'status',
    requesterId: 'requesterId',
    requesterName: 'requesterName',
    organizationId: 'organizationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced',
    needsSync: 'needsSync'
  };

  export type NeedScalarFieldEnum = (typeof NeedScalarFieldEnum)[keyof typeof NeedScalarFieldEnum]


  export const NeedWorkflowStepScalarFieldEnum: {
    id: 'id',
    needId: 'needId',
    reviewerId: 'reviewerId',
    reviewerName: 'reviewerName',
    reviewerLevel: 'reviewerLevel',
    action: 'action',
    isRequired: 'isRequired',
    isCompleted: 'isCompleted',
    comment: 'comment',
    createdAt: 'createdAt',
    completedAt: 'completedAt',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type NeedWorkflowStepScalarFieldEnum = (typeof NeedWorkflowStepScalarFieldEnum)[keyof typeof NeedWorkflowStepScalarFieldEnum]


  export const NeedAttachmentScalarFieldEnum: {
    id: 'id',
    needId: 'needId',
    fileName: 'fileName',
    fileSize: 'fileSize',
    fileType: 'fileType',
    uploadedBy: 'uploadedBy',
    url: 'url',
    localPath: 'localPath',
    createdAt: 'createdAt',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type NeedAttachmentScalarFieldEnum = (typeof NeedAttachmentScalarFieldEnum)[keyof typeof NeedAttachmentScalarFieldEnum]


  export const InvoiceClientScalarFieldEnum: {
    id: 'id',
    company: 'company',
    companyName: 'companyName',
    contactName: 'contactName',
    email: 'email',
    phone: 'phone',
    address: 'address',
    city: 'city',
    country: 'country',
    taxNumber: 'taxNumber',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced',
    needsSync: 'needsSync'
  };

  export type InvoiceClientScalarFieldEnum = (typeof InvoiceClientScalarFieldEnum)[keyof typeof InvoiceClientScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    invoiceNumber: 'invoiceNumber',
    template: 'template',
    company: 'company',
    clientId: 'clientId',
    clientSnapshot: 'clientSnapshot',
    issueDate: 'issueDate',
    dueDate: 'dueDate',
    subtotal: 'subtotal',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    total: 'total',
    serviceType: 'serviceType',
    templateCode: 'templateCode',
    placementTVAEnabled: 'placementTVAEnabled',
    chargesTTCMode: 'chargesTTCMode',
    placementDeduction: 'placementDeduction',
    enablePlacementDeduction: 'enablePlacementDeduction',
    transfertDeduction: 'transfertDeduction',
    enableTransfertDeduction: 'enableTransfertDeduction',
    projectDescription: 'projectDescription',
    projectName: 'projectName',
    managementFeeRate: 'managementFeeRate',
    commissionRate: 'commissionRate',
    acomptes: 'acomptes',
    status: 'status',
    paymentTerms: 'paymentTerms',
    paymentMethod: 'paymentMethod',
    paidAt: 'paidAt',
    paidAmount: 'paidAmount',
    notes: 'notes',
    publicNotes: 'publicNotes',
    createdBy: 'createdBy',
    createdByInitials: 'createdByInitials',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced',
    needsSync: 'needsSync'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceLineScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    quantity: 'quantity',
    unitPrice: 'unitPrice',
    total: 'total',
    chargesTTC: 'chargesTTC',
    squareMeters: 'squareMeters',
    days: 'days',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type InvoiceLineScalarFieldEnum = (typeof InvoiceLineScalarFieldEnum)[keyof typeof InvoiceLineScalarFieldEnum]


  export const InvoiceSectionScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    title: 'title',
    subtotal: 'subtotal',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type InvoiceSectionScalarFieldEnum = (typeof InvoiceSectionScalarFieldEnum)[keyof typeof InvoiceSectionScalarFieldEnum]


  export const InvoiceSectionLineScalarFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    description: 'description',
    quantity: 'quantity',
    squareMeters: 'squareMeters',
    days: 'days',
    unitPrice: 'unitPrice',
    total: 'total',
    daysImpactPrice: 'daysImpactPrice',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type InvoiceSectionLineScalarFieldEnum = (typeof InvoiceSectionLineScalarFieldEnum)[keyof typeof InvoiceSectionLineScalarFieldEnum]


  export const InvoicePaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    amount: 'amount',
    paymentDate: 'paymentDate',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    notes: 'notes',
    createdAt: 'createdAt',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type InvoicePaymentScalarFieldEnum = (typeof InvoicePaymentScalarFieldEnum)[keyof typeof InvoicePaymentScalarFieldEnum]


  export const ExpenseCategoryScalarFieldEnum: {
    id: 'id',
    company: 'company',
    name: 'name',
    color: 'color',
    icon: 'icon',
    isActive: 'isActive',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced',
    needsSync: 'needsSync'
  };

  export type ExpenseCategoryScalarFieldEnum = (typeof ExpenseCategoryScalarFieldEnum)[keyof typeof ExpenseCategoryScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    company: 'company',
    categoryId: 'categoryId',
    description: 'description',
    amount: 'amount',
    expenseDate: 'expenseDate',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    vendor: 'vendor',
    receiptUrl: 'receiptUrl',
    localReceiptPath: 'localReceiptPath',
    notes: 'notes',
    createdBy: 'createdBy',
    createdByName: 'createdByName',
    isRecurring: 'isRecurring',
    recurringType: 'recurringType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    syncId: 'syncId',
    lastSynced: 'lastSynced',
    needsSync: 'needsSync'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const TreasuryMonthScalarFieldEnum: {
    id: 'id',
    company: 'company',
    year: 'year',
    month: 'month',
    totalIncome: 'totalIncome',
    totalExpenses: 'totalExpenses',
    balance: 'balance',
    expensesByCategory: 'expensesByCategory',
    lastUpdated: 'lastUpdated',
    syncId: 'syncId',
    needsSync: 'needsSync'
  };

  export type TreasuryMonthScalarFieldEnum = (typeof TreasuryMonthScalarFieldEnum)[keyof typeof TreasuryMonthScalarFieldEnum]


  export const SyncQueueScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    recordId: 'recordId',
    action: 'action',
    data: 'data',
    createdAt: 'createdAt',
    syncedAt: 'syncedAt',
    error: 'error',
    retries: 'retries'
  };

  export type SyncQueueScalarFieldEnum = (typeof SyncQueueScalarFieldEnum)[keyof typeof SyncQueueScalarFieldEnum]


  export const SyncStatusScalarFieldEnum: {
    id: 'id',
    lastSyncAt: 'lastSyncAt',
    lastSyncSuccess: 'lastSyncSuccess',
    pendingChanges: 'pendingChanges',
    serverUrl: 'serverUrl'
  };

  export type SyncStatusScalarFieldEnum = (typeof SyncStatusScalarFieldEnum)[keyof typeof SyncStatusScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type OrganizationWhereInput = {
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    id?: IntFilter<"Organization"> | number
    name?: StringFilter<"Organization"> | string
    slug?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    syncId?: StringNullableFilter<"Organization"> | string | null
    lastSynced?: DateTimeNullableFilter<"Organization"> | Date | string | null
    users?: UserListRelationFilter
    messages?: MessageListRelationFilter
    tasks?: TaskListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    requisitions?: RequisitionListRelationFilter
    needs?: NeedListRelationFilter
    meetings?: MeetingListRelationFilter
    emailAccounts?: EmailAccountListRelationFilter
    emailSelections?: EmailActiveSelectionListRelationFilter
  }

  export type OrganizationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    users?: UserOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    requisitions?: RequisitionOrderByRelationAggregateInput
    needs?: NeedOrderByRelationAggregateInput
    meetings?: MeetingOrderByRelationAggregateInput
    emailAccounts?: EmailAccountOrderByRelationAggregateInput
    emailSelections?: EmailActiveSelectionOrderByRelationAggregateInput
  }

  export type OrganizationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    syncId?: string
    AND?: OrganizationWhereInput | OrganizationWhereInput[]
    OR?: OrganizationWhereInput[]
    NOT?: OrganizationWhereInput | OrganizationWhereInput[]
    name?: StringFilter<"Organization"> | string
    createdAt?: DateTimeFilter<"Organization"> | Date | string
    updatedAt?: DateTimeFilter<"Organization"> | Date | string
    lastSynced?: DateTimeNullableFilter<"Organization"> | Date | string | null
    users?: UserListRelationFilter
    messages?: MessageListRelationFilter
    tasks?: TaskListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    requisitions?: RequisitionListRelationFilter
    needs?: NeedListRelationFilter
    meetings?: MeetingListRelationFilter
    emailAccounts?: EmailAccountListRelationFilter
    emailSelections?: EmailActiveSelectionListRelationFilter
  }, "id" | "slug" | "syncId">

  export type OrganizationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    _count?: OrganizationCountOrderByAggregateInput
    _avg?: OrganizationAvgOrderByAggregateInput
    _max?: OrganizationMaxOrderByAggregateInput
    _min?: OrganizationMinOrderByAggregateInput
    _sum?: OrganizationSumOrderByAggregateInput
  }

  export type OrganizationScalarWhereWithAggregatesInput = {
    AND?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    OR?: OrganizationScalarWhereWithAggregatesInput[]
    NOT?: OrganizationScalarWhereWithAggregatesInput | OrganizationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Organization"> | number
    name?: StringWithAggregatesFilter<"Organization"> | string
    slug?: StringWithAggregatesFilter<"Organization"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Organization"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"Organization"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"Organization"> | Date | string | null
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    organizationId?: IntFilter<"User"> | number
    externalId?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    pinHash?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    syncId?: StringNullableFilter<"User"> | string | null
    lastSynced?: DateTimeNullableFilter<"User"> | Date | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    messages?: MessageListRelationFilter
    tasks?: TaskListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    requisitionsRequested?: RequisitionListRelationFilter
    workflowStepsReviewed?: WorkflowStepListRelationFilter
    needsRequested?: NeedListRelationFilter
    needWorkflowStepsReviewed?: NeedWorkflowStepListRelationFilter
    meetingsCreated?: MeetingListRelationFilter
    emailAccounts?: EmailAccountListRelationFilter
    emailSelections?: EmailActiveSelectionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    pinHash?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    organization?: OrganizationOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
    tasks?: TaskOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    requisitionsRequested?: RequisitionOrderByRelationAggregateInput
    workflowStepsReviewed?: WorkflowStepOrderByRelationAggregateInput
    needsRequested?: NeedOrderByRelationAggregateInput
    needWorkflowStepsReviewed?: NeedWorkflowStepOrderByRelationAggregateInput
    meetingsCreated?: MeetingOrderByRelationAggregateInput
    emailAccounts?: EmailAccountOrderByRelationAggregateInput
    emailSelections?: EmailActiveSelectionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    externalId?: string
    email?: string
    syncId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    organizationId?: IntFilter<"User"> | number
    displayName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    pinHash?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastSynced?: DateTimeNullableFilter<"User"> | Date | string | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    messages?: MessageListRelationFilter
    tasks?: TaskListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
    requisitionsRequested?: RequisitionListRelationFilter
    workflowStepsReviewed?: WorkflowStepListRelationFilter
    needsRequested?: NeedListRelationFilter
    needWorkflowStepsReviewed?: NeedWorkflowStepListRelationFilter
    meetingsCreated?: MeetingListRelationFilter
    emailAccounts?: EmailAccountListRelationFilter
    emailSelections?: EmailActiveSelectionListRelationFilter
  }, "id" | "externalId" | "email" | "syncId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    externalId?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    displayName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    pinHash?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    organizationId?: IntWithAggregatesFilter<"User"> | number
    externalId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    displayName?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    pinHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: IntFilter<"Message"> | number
    organizationId?: IntFilter<"Message"> | number
    userId?: IntNullableFilter<"Message"> | number | null
    kind?: StringFilter<"Message"> | string
    channel?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    metadata?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    syncId?: StringNullableFilter<"Message"> | string | null
    lastSynced?: DateTimeNullableFilter<"Message"> | Date | string | null
    needsSync?: BoolFilter<"Message"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    kind?: SortOrder
    channel?: SortOrderInput | SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    syncId?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    organizationId?: IntFilter<"Message"> | number
    userId?: IntNullableFilter<"Message"> | number | null
    kind?: StringFilter<"Message"> | string
    channel?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    metadata?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    lastSynced?: DateTimeNullableFilter<"Message"> | Date | string | null
    needsSync?: BoolFilter<"Message"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "syncId">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    kind?: SortOrder
    channel?: SortOrderInput | SortOrder
    content?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Message"> | number
    organizationId?: IntWithAggregatesFilter<"Message"> | number
    userId?: IntNullableWithAggregatesFilter<"Message"> | number | null
    kind?: StringWithAggregatesFilter<"Message"> | string
    channel?: StringNullableWithAggregatesFilter<"Message"> | string | null
    content?: StringWithAggregatesFilter<"Message"> | string
    metadata?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    needsSync?: BoolWithAggregatesFilter<"Message"> | boolean
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: IntFilter<"Task"> | number
    organizationId?: IntFilter<"Task"> | number
    userId?: IntNullableFilter<"Task"> | number | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    dueAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    metadata?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    syncId?: StringNullableFilter<"Task"> | string | null
    lastSynced?: DateTimeNullableFilter<"Task"> | Date | string | null
    needsSync?: BoolFilter<"Task"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    runs?: TaskRunListRelationFilter
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    dueAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    runs?: TaskRunOrderByRelationAggregateInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    syncId?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    organizationId?: IntFilter<"Task"> | number
    userId?: IntNullableFilter<"Task"> | number | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    dueAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    metadata?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    lastSynced?: DateTimeNullableFilter<"Task"> | Date | string | null
    needsSync?: BoolFilter<"Task"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    runs?: TaskRunListRelationFilter
  }, "id" | "syncId">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    dueAt?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _avg?: TaskAvgOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
    _sum?: TaskSumOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Task"> | number
    organizationId?: IntWithAggregatesFilter<"Task"> | number
    userId?: IntNullableWithAggregatesFilter<"Task"> | number | null
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: StringWithAggregatesFilter<"Task"> | string
    dueAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    metadata?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    needsSync?: BoolWithAggregatesFilter<"Task"> | boolean
  }

  export type TaskRunWhereInput = {
    AND?: TaskRunWhereInput | TaskRunWhereInput[]
    OR?: TaskRunWhereInput[]
    NOT?: TaskRunWhereInput | TaskRunWhereInput[]
    id?: IntFilter<"TaskRun"> | number
    taskId?: IntFilter<"TaskRun"> | number
    runType?: StringFilter<"TaskRun"> | string
    result?: StringFilter<"TaskRun"> | string
    message?: StringNullableFilter<"TaskRun"> | string | null
    createdAt?: DateTimeFilter<"TaskRun"> | Date | string
    syncId?: StringNullableFilter<"TaskRun"> | string | null
    needsSync?: BoolFilter<"TaskRun"> | boolean
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }

  export type TaskRunOrderByWithRelationInput = {
    id?: SortOrder
    taskId?: SortOrder
    runType?: SortOrder
    result?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    task?: TaskOrderByWithRelationInput
  }

  export type TaskRunWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    syncId?: string
    AND?: TaskRunWhereInput | TaskRunWhereInput[]
    OR?: TaskRunWhereInput[]
    NOT?: TaskRunWhereInput | TaskRunWhereInput[]
    taskId?: IntFilter<"TaskRun"> | number
    runType?: StringFilter<"TaskRun"> | string
    result?: StringFilter<"TaskRun"> | string
    message?: StringNullableFilter<"TaskRun"> | string | null
    createdAt?: DateTimeFilter<"TaskRun"> | Date | string
    needsSync?: BoolFilter<"TaskRun"> | boolean
    task?: XOR<TaskScalarRelationFilter, TaskWhereInput>
  }, "id" | "syncId">

  export type TaskRunOrderByWithAggregationInput = {
    id?: SortOrder
    taskId?: SortOrder
    runType?: SortOrder
    result?: SortOrder
    message?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: TaskRunCountOrderByAggregateInput
    _avg?: TaskRunAvgOrderByAggregateInput
    _max?: TaskRunMaxOrderByAggregateInput
    _min?: TaskRunMinOrderByAggregateInput
    _sum?: TaskRunSumOrderByAggregateInput
  }

  export type TaskRunScalarWhereWithAggregatesInput = {
    AND?: TaskRunScalarWhereWithAggregatesInput | TaskRunScalarWhereWithAggregatesInput[]
    OR?: TaskRunScalarWhereWithAggregatesInput[]
    NOT?: TaskRunScalarWhereWithAggregatesInput | TaskRunScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TaskRun"> | number
    taskId?: IntWithAggregatesFilter<"TaskRun"> | number
    runType?: StringWithAggregatesFilter<"TaskRun"> | string
    result?: StringWithAggregatesFilter<"TaskRun"> | string
    message?: StringNullableWithAggregatesFilter<"TaskRun"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TaskRun"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"TaskRun"> | string | null
    needsSync?: BoolWithAggregatesFilter<"TaskRun"> | boolean
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    organizationId?: IntFilter<"ActivityLog"> | number
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    subjectType?: StringFilter<"ActivityLog"> | string
    subjectId?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringFilter<"ActivityLog"> | string
    detail?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    syncId?: StringNullableFilter<"ActivityLog"> | string | null
    needsSync?: BoolFilter<"ActivityLog"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    subjectType?: SortOrder
    subjectId?: SortOrderInput | SortOrder
    action?: SortOrder
    detail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    syncId?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    organizationId?: IntFilter<"ActivityLog"> | number
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    subjectType?: StringFilter<"ActivityLog"> | string
    subjectId?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringFilter<"ActivityLog"> | string
    detail?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    needsSync?: BoolFilter<"ActivityLog"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "syncId">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    subjectType?: SortOrder
    subjectId?: SortOrderInput | SortOrder
    action?: SortOrder
    detail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ActivityLog"> | number
    organizationId?: IntWithAggregatesFilter<"ActivityLog"> | number
    userId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    subjectType?: StringWithAggregatesFilter<"ActivityLog"> | string
    subjectId?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    detail?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    needsSync?: BoolWithAggregatesFilter<"ActivityLog"> | boolean
  }

  export type RequisitionWhereInput = {
    AND?: RequisitionWhereInput | RequisitionWhereInput[]
    OR?: RequisitionWhereInput[]
    NOT?: RequisitionWhereInput | RequisitionWhereInput[]
    id?: StringFilter<"Requisition"> | string
    title?: StringFilter<"Requisition"> | string
    description?: StringFilter<"Requisition"> | string
    category?: StringFilter<"Requisition"> | string
    priority?: StringFilter<"Requisition"> | string
    budget?: FloatFilter<"Requisition"> | number
    justification?: StringFilter<"Requisition"> | string
    status?: StringFilter<"Requisition"> | string
    requesterId?: IntNullableFilter<"Requisition"> | number | null
    organizationId?: IntFilter<"Requisition"> | number
    approvedAt?: DateTimeNullableFilter<"Requisition"> | Date | string | null
    createdAt?: DateTimeFilter<"Requisition"> | Date | string
    updatedAt?: DateTimeFilter<"Requisition"> | Date | string
    syncId?: StringNullableFilter<"Requisition"> | string | null
    lastSynced?: DateTimeNullableFilter<"Requisition"> | Date | string | null
    needsSync?: BoolFilter<"Requisition"> | boolean
    requester?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    workflow?: WorkflowStepListRelationFilter
  }

  export type RequisitionOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    justification?: SortOrder
    status?: SortOrder
    requesterId?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    requester?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    workflow?: WorkflowStepOrderByRelationAggregateInput
  }

  export type RequisitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: RequisitionWhereInput | RequisitionWhereInput[]
    OR?: RequisitionWhereInput[]
    NOT?: RequisitionWhereInput | RequisitionWhereInput[]
    title?: StringFilter<"Requisition"> | string
    description?: StringFilter<"Requisition"> | string
    category?: StringFilter<"Requisition"> | string
    priority?: StringFilter<"Requisition"> | string
    budget?: FloatFilter<"Requisition"> | number
    justification?: StringFilter<"Requisition"> | string
    status?: StringFilter<"Requisition"> | string
    requesterId?: IntNullableFilter<"Requisition"> | number | null
    organizationId?: IntFilter<"Requisition"> | number
    approvedAt?: DateTimeNullableFilter<"Requisition"> | Date | string | null
    createdAt?: DateTimeFilter<"Requisition"> | Date | string
    updatedAt?: DateTimeFilter<"Requisition"> | Date | string
    lastSynced?: DateTimeNullableFilter<"Requisition"> | Date | string | null
    needsSync?: BoolFilter<"Requisition"> | boolean
    requester?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    workflow?: WorkflowStepListRelationFilter
  }, "id" | "syncId">

  export type RequisitionOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    justification?: SortOrder
    status?: SortOrder
    requesterId?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: RequisitionCountOrderByAggregateInput
    _avg?: RequisitionAvgOrderByAggregateInput
    _max?: RequisitionMaxOrderByAggregateInput
    _min?: RequisitionMinOrderByAggregateInput
    _sum?: RequisitionSumOrderByAggregateInput
  }

  export type RequisitionScalarWhereWithAggregatesInput = {
    AND?: RequisitionScalarWhereWithAggregatesInput | RequisitionScalarWhereWithAggregatesInput[]
    OR?: RequisitionScalarWhereWithAggregatesInput[]
    NOT?: RequisitionScalarWhereWithAggregatesInput | RequisitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Requisition"> | string
    title?: StringWithAggregatesFilter<"Requisition"> | string
    description?: StringWithAggregatesFilter<"Requisition"> | string
    category?: StringWithAggregatesFilter<"Requisition"> | string
    priority?: StringWithAggregatesFilter<"Requisition"> | string
    budget?: FloatWithAggregatesFilter<"Requisition"> | number
    justification?: StringWithAggregatesFilter<"Requisition"> | string
    status?: StringWithAggregatesFilter<"Requisition"> | string
    requesterId?: IntNullableWithAggregatesFilter<"Requisition"> | number | null
    organizationId?: IntWithAggregatesFilter<"Requisition"> | number
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Requisition"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Requisition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Requisition"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"Requisition"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"Requisition"> | Date | string | null
    needsSync?: BoolWithAggregatesFilter<"Requisition"> | boolean
  }

  export type WorkflowStepWhereInput = {
    AND?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    OR?: WorkflowStepWhereInput[]
    NOT?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    id?: StringFilter<"WorkflowStep"> | string
    requisitionId?: StringFilter<"WorkflowStep"> | string
    reviewerId?: IntNullableFilter<"WorkflowStep"> | number | null
    reviewerName?: StringFilter<"WorkflowStep"> | string
    reviewerLevel?: IntFilter<"WorkflowStep"> | number
    action?: StringFilter<"WorkflowStep"> | string
    isRequired?: BoolFilter<"WorkflowStep"> | boolean
    isCompleted?: BoolFilter<"WorkflowStep"> | boolean
    comment?: StringNullableFilter<"WorkflowStep"> | string | null
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowStep"> | Date | string | null
    syncId?: StringNullableFilter<"WorkflowStep"> | string | null
    needsSync?: BoolFilter<"WorkflowStep"> | boolean
    requisition?: XOR<RequisitionScalarRelationFilter, RequisitionWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type WorkflowStepOrderByWithRelationInput = {
    id?: SortOrder
    requisitionId?: SortOrder
    reviewerId?: SortOrderInput | SortOrder
    reviewerName?: SortOrder
    reviewerLevel?: SortOrder
    action?: SortOrder
    isRequired?: SortOrder
    isCompleted?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    requisition?: RequisitionOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type WorkflowStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    OR?: WorkflowStepWhereInput[]
    NOT?: WorkflowStepWhereInput | WorkflowStepWhereInput[]
    requisitionId?: StringFilter<"WorkflowStep"> | string
    reviewerId?: IntNullableFilter<"WorkflowStep"> | number | null
    reviewerName?: StringFilter<"WorkflowStep"> | string
    reviewerLevel?: IntFilter<"WorkflowStep"> | number
    action?: StringFilter<"WorkflowStep"> | string
    isRequired?: BoolFilter<"WorkflowStep"> | boolean
    isCompleted?: BoolFilter<"WorkflowStep"> | boolean
    comment?: StringNullableFilter<"WorkflowStep"> | string | null
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowStep"> | Date | string | null
    needsSync?: BoolFilter<"WorkflowStep"> | boolean
    requisition?: XOR<RequisitionScalarRelationFilter, RequisitionWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "syncId">

  export type WorkflowStepOrderByWithAggregationInput = {
    id?: SortOrder
    requisitionId?: SortOrder
    reviewerId?: SortOrderInput | SortOrder
    reviewerName?: SortOrder
    reviewerLevel?: SortOrder
    action?: SortOrder
    isRequired?: SortOrder
    isCompleted?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: WorkflowStepCountOrderByAggregateInput
    _avg?: WorkflowStepAvgOrderByAggregateInput
    _max?: WorkflowStepMaxOrderByAggregateInput
    _min?: WorkflowStepMinOrderByAggregateInput
    _sum?: WorkflowStepSumOrderByAggregateInput
  }

  export type WorkflowStepScalarWhereWithAggregatesInput = {
    AND?: WorkflowStepScalarWhereWithAggregatesInput | WorkflowStepScalarWhereWithAggregatesInput[]
    OR?: WorkflowStepScalarWhereWithAggregatesInput[]
    NOT?: WorkflowStepScalarWhereWithAggregatesInput | WorkflowStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkflowStep"> | string
    requisitionId?: StringWithAggregatesFilter<"WorkflowStep"> | string
    reviewerId?: IntNullableWithAggregatesFilter<"WorkflowStep"> | number | null
    reviewerName?: StringWithAggregatesFilter<"WorkflowStep"> | string
    reviewerLevel?: IntWithAggregatesFilter<"WorkflowStep"> | number
    action?: StringWithAggregatesFilter<"WorkflowStep"> | string
    isRequired?: BoolWithAggregatesFilter<"WorkflowStep"> | boolean
    isCompleted?: BoolWithAggregatesFilter<"WorkflowStep"> | boolean
    comment?: StringNullableWithAggregatesFilter<"WorkflowStep"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WorkflowStep"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"WorkflowStep"> | Date | string | null
    syncId?: StringNullableWithAggregatesFilter<"WorkflowStep"> | string | null
    needsSync?: BoolWithAggregatesFilter<"WorkflowStep"> | boolean
  }

  export type MeetingWhereInput = {
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    id?: StringFilter<"Meeting"> | string
    organizationId?: IntFilter<"Meeting"> | number
    creatorId?: IntNullableFilter<"Meeting"> | number | null
    title?: StringFilter<"Meeting"> | string
    notes?: StringFilter<"Meeting"> | string
    participants?: StringNullableFilter<"Meeting"> | string | null
    status?: StringFilter<"Meeting"> | string
    extractedActions?: StringNullableFilter<"Meeting"> | string | null
    tasksCreated?: StringNullableFilter<"Meeting"> | string | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    syncId?: StringNullableFilter<"Meeting"> | string | null
    lastSynced?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    needsSync?: BoolFilter<"Meeting"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type MeetingOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    title?: SortOrder
    notes?: SortOrder
    participants?: SortOrderInput | SortOrder
    status?: SortOrder
    extractedActions?: SortOrderInput | SortOrder
    tasksCreated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
  }

  export type MeetingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: MeetingWhereInput | MeetingWhereInput[]
    OR?: MeetingWhereInput[]
    NOT?: MeetingWhereInput | MeetingWhereInput[]
    organizationId?: IntFilter<"Meeting"> | number
    creatorId?: IntNullableFilter<"Meeting"> | number | null
    title?: StringFilter<"Meeting"> | string
    notes?: StringFilter<"Meeting"> | string
    participants?: StringNullableFilter<"Meeting"> | string | null
    status?: StringFilter<"Meeting"> | string
    extractedActions?: StringNullableFilter<"Meeting"> | string | null
    tasksCreated?: StringNullableFilter<"Meeting"> | string | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    lastSynced?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    needsSync?: BoolFilter<"Meeting"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "syncId">

  export type MeetingOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    creatorId?: SortOrderInput | SortOrder
    title?: SortOrder
    notes?: SortOrder
    participants?: SortOrderInput | SortOrder
    status?: SortOrder
    extractedActions?: SortOrderInput | SortOrder
    tasksCreated?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: MeetingCountOrderByAggregateInput
    _avg?: MeetingAvgOrderByAggregateInput
    _max?: MeetingMaxOrderByAggregateInput
    _min?: MeetingMinOrderByAggregateInput
    _sum?: MeetingSumOrderByAggregateInput
  }

  export type MeetingScalarWhereWithAggregatesInput = {
    AND?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    OR?: MeetingScalarWhereWithAggregatesInput[]
    NOT?: MeetingScalarWhereWithAggregatesInput | MeetingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Meeting"> | string
    organizationId?: IntWithAggregatesFilter<"Meeting"> | number
    creatorId?: IntNullableWithAggregatesFilter<"Meeting"> | number | null
    title?: StringWithAggregatesFilter<"Meeting"> | string
    notes?: StringWithAggregatesFilter<"Meeting"> | string
    participants?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    status?: StringWithAggregatesFilter<"Meeting"> | string
    extractedActions?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    tasksCreated?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Meeting"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"Meeting"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"Meeting"> | Date | string | null
    needsSync?: BoolWithAggregatesFilter<"Meeting"> | boolean
  }

  export type EmailAccountWhereInput = {
    AND?: EmailAccountWhereInput | EmailAccountWhereInput[]
    OR?: EmailAccountWhereInput[]
    NOT?: EmailAccountWhereInput | EmailAccountWhereInput[]
    id?: StringFilter<"EmailAccount"> | string
    organizationId?: IntFilter<"EmailAccount"> | number
    userId?: IntNullableFilter<"EmailAccount"> | number | null
    email?: StringFilter<"EmailAccount"> | string
    providerId?: StringFilter<"EmailAccount"> | string
    providerName?: StringNullableFilter<"EmailAccount"> | string | null
    provider?: StringNullableFilter<"EmailAccount"> | string | null
    credentials?: StringNullableFilter<"EmailAccount"> | string | null
    isConnected?: BoolFilter<"EmailAccount"> | boolean
    unreadCount?: IntFilter<"EmailAccount"> | number
    connectedAt?: DateTimeNullableFilter<"EmailAccount"> | Date | string | null
    lastSync?: DateTimeNullableFilter<"EmailAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailAccount"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAccount"> | Date | string
    syncId?: StringNullableFilter<"EmailAccount"> | string | null
    needsSync?: BoolFilter<"EmailAccount"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    selections?: EmailActiveSelectionListRelationFilter
  }

  export type EmailAccountOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrder
    providerId?: SortOrder
    providerName?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    credentials?: SortOrderInput | SortOrder
    isConnected?: SortOrder
    unreadCount?: SortOrder
    connectedAt?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    selections?: EmailActiveSelectionOrderByRelationAggregateInput
  }

  export type EmailAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: EmailAccountWhereInput | EmailAccountWhereInput[]
    OR?: EmailAccountWhereInput[]
    NOT?: EmailAccountWhereInput | EmailAccountWhereInput[]
    organizationId?: IntFilter<"EmailAccount"> | number
    userId?: IntNullableFilter<"EmailAccount"> | number | null
    email?: StringFilter<"EmailAccount"> | string
    providerId?: StringFilter<"EmailAccount"> | string
    providerName?: StringNullableFilter<"EmailAccount"> | string | null
    provider?: StringNullableFilter<"EmailAccount"> | string | null
    credentials?: StringNullableFilter<"EmailAccount"> | string | null
    isConnected?: BoolFilter<"EmailAccount"> | boolean
    unreadCount?: IntFilter<"EmailAccount"> | number
    connectedAt?: DateTimeNullableFilter<"EmailAccount"> | Date | string | null
    lastSync?: DateTimeNullableFilter<"EmailAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailAccount"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAccount"> | Date | string
    needsSync?: BoolFilter<"EmailAccount"> | boolean
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    selections?: EmailActiveSelectionListRelationFilter
  }, "id" | "syncId">

  export type EmailAccountOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrder
    providerId?: SortOrder
    providerName?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    credentials?: SortOrderInput | SortOrder
    isConnected?: SortOrder
    unreadCount?: SortOrder
    connectedAt?: SortOrderInput | SortOrder
    lastSync?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: EmailAccountCountOrderByAggregateInput
    _avg?: EmailAccountAvgOrderByAggregateInput
    _max?: EmailAccountMaxOrderByAggregateInput
    _min?: EmailAccountMinOrderByAggregateInput
    _sum?: EmailAccountSumOrderByAggregateInput
  }

  export type EmailAccountScalarWhereWithAggregatesInput = {
    AND?: EmailAccountScalarWhereWithAggregatesInput | EmailAccountScalarWhereWithAggregatesInput[]
    OR?: EmailAccountScalarWhereWithAggregatesInput[]
    NOT?: EmailAccountScalarWhereWithAggregatesInput | EmailAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailAccount"> | string
    organizationId?: IntWithAggregatesFilter<"EmailAccount"> | number
    userId?: IntNullableWithAggregatesFilter<"EmailAccount"> | number | null
    email?: StringWithAggregatesFilter<"EmailAccount"> | string
    providerId?: StringWithAggregatesFilter<"EmailAccount"> | string
    providerName?: StringNullableWithAggregatesFilter<"EmailAccount"> | string | null
    provider?: StringNullableWithAggregatesFilter<"EmailAccount"> | string | null
    credentials?: StringNullableWithAggregatesFilter<"EmailAccount"> | string | null
    isConnected?: BoolWithAggregatesFilter<"EmailAccount"> | boolean
    unreadCount?: IntWithAggregatesFilter<"EmailAccount"> | number
    connectedAt?: DateTimeNullableWithAggregatesFilter<"EmailAccount"> | Date | string | null
    lastSync?: DateTimeNullableWithAggregatesFilter<"EmailAccount"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailAccount"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"EmailAccount"> | string | null
    needsSync?: BoolWithAggregatesFilter<"EmailAccount"> | boolean
  }

  export type EmailActiveSelectionWhereInput = {
    AND?: EmailActiveSelectionWhereInput | EmailActiveSelectionWhereInput[]
    OR?: EmailActiveSelectionWhereInput[]
    NOT?: EmailActiveSelectionWhereInput | EmailActiveSelectionWhereInput[]
    id?: IntFilter<"EmailActiveSelection"> | number
    organizationId?: IntFilter<"EmailActiveSelection"> | number
    userId?: IntFilter<"EmailActiveSelection"> | number
    accountId?: StringFilter<"EmailActiveSelection"> | string
    createdAt?: DateTimeFilter<"EmailActiveSelection"> | Date | string
    updatedAt?: DateTimeFilter<"EmailActiveSelection"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<EmailAccountScalarRelationFilter, EmailAccountWhereInput>
  }

  export type EmailActiveSelectionOrderByWithRelationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    organization?: OrganizationOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    account?: EmailAccountOrderByWithRelationInput
  }

  export type EmailActiveSelectionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    organizationId_userId?: EmailActiveSelectionOrganizationIdUserIdCompoundUniqueInput
    AND?: EmailActiveSelectionWhereInput | EmailActiveSelectionWhereInput[]
    OR?: EmailActiveSelectionWhereInput[]
    NOT?: EmailActiveSelectionWhereInput | EmailActiveSelectionWhereInput[]
    organizationId?: IntFilter<"EmailActiveSelection"> | number
    userId?: IntFilter<"EmailActiveSelection"> | number
    accountId?: StringFilter<"EmailActiveSelection"> | string
    createdAt?: DateTimeFilter<"EmailActiveSelection"> | Date | string
    updatedAt?: DateTimeFilter<"EmailActiveSelection"> | Date | string
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    account?: XOR<EmailAccountScalarRelationFilter, EmailAccountWhereInput>
  }, "id" | "organizationId_userId">

  export type EmailActiveSelectionOrderByWithAggregationInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailActiveSelectionCountOrderByAggregateInput
    _avg?: EmailActiveSelectionAvgOrderByAggregateInput
    _max?: EmailActiveSelectionMaxOrderByAggregateInput
    _min?: EmailActiveSelectionMinOrderByAggregateInput
    _sum?: EmailActiveSelectionSumOrderByAggregateInput
  }

  export type EmailActiveSelectionScalarWhereWithAggregatesInput = {
    AND?: EmailActiveSelectionScalarWhereWithAggregatesInput | EmailActiveSelectionScalarWhereWithAggregatesInput[]
    OR?: EmailActiveSelectionScalarWhereWithAggregatesInput[]
    NOT?: EmailActiveSelectionScalarWhereWithAggregatesInput | EmailActiveSelectionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EmailActiveSelection"> | number
    organizationId?: IntWithAggregatesFilter<"EmailActiveSelection"> | number
    userId?: IntWithAggregatesFilter<"EmailActiveSelection"> | number
    accountId?: StringWithAggregatesFilter<"EmailActiveSelection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"EmailActiveSelection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailActiveSelection"> | Date | string
  }

  export type NeedWhereInput = {
    AND?: NeedWhereInput | NeedWhereInput[]
    OR?: NeedWhereInput[]
    NOT?: NeedWhereInput | NeedWhereInput[]
    id?: StringFilter<"Need"> | string
    title?: StringFilter<"Need"> | string
    description?: StringFilter<"Need"> | string
    category?: StringFilter<"Need"> | string
    priority?: StringFilter<"Need"> | string
    budget?: FloatFilter<"Need"> | number
    justification?: StringNullableFilter<"Need"> | string | null
    status?: StringFilter<"Need"> | string
    requesterId?: IntNullableFilter<"Need"> | number | null
    requesterName?: StringNullableFilter<"Need"> | string | null
    organizationId?: IntFilter<"Need"> | number
    createdAt?: DateTimeFilter<"Need"> | Date | string
    updatedAt?: DateTimeFilter<"Need"> | Date | string
    syncId?: StringNullableFilter<"Need"> | string | null
    lastSynced?: DateTimeNullableFilter<"Need"> | Date | string | null
    needsSync?: BoolFilter<"Need"> | boolean
    requester?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    workflow?: NeedWorkflowStepListRelationFilter
    attachments?: NeedAttachmentListRelationFilter
  }

  export type NeedOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    justification?: SortOrderInput | SortOrder
    status?: SortOrder
    requesterId?: SortOrderInput | SortOrder
    requesterName?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    requester?: UserOrderByWithRelationInput
    organization?: OrganizationOrderByWithRelationInput
    workflow?: NeedWorkflowStepOrderByRelationAggregateInput
    attachments?: NeedAttachmentOrderByRelationAggregateInput
  }

  export type NeedWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: NeedWhereInput | NeedWhereInput[]
    OR?: NeedWhereInput[]
    NOT?: NeedWhereInput | NeedWhereInput[]
    title?: StringFilter<"Need"> | string
    description?: StringFilter<"Need"> | string
    category?: StringFilter<"Need"> | string
    priority?: StringFilter<"Need"> | string
    budget?: FloatFilter<"Need"> | number
    justification?: StringNullableFilter<"Need"> | string | null
    status?: StringFilter<"Need"> | string
    requesterId?: IntNullableFilter<"Need"> | number | null
    requesterName?: StringNullableFilter<"Need"> | string | null
    organizationId?: IntFilter<"Need"> | number
    createdAt?: DateTimeFilter<"Need"> | Date | string
    updatedAt?: DateTimeFilter<"Need"> | Date | string
    lastSynced?: DateTimeNullableFilter<"Need"> | Date | string | null
    needsSync?: BoolFilter<"Need"> | boolean
    requester?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    organization?: XOR<OrganizationScalarRelationFilter, OrganizationWhereInput>
    workflow?: NeedWorkflowStepListRelationFilter
    attachments?: NeedAttachmentListRelationFilter
  }, "id" | "syncId">

  export type NeedOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    justification?: SortOrderInput | SortOrder
    status?: SortOrder
    requesterId?: SortOrderInput | SortOrder
    requesterName?: SortOrderInput | SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: NeedCountOrderByAggregateInput
    _avg?: NeedAvgOrderByAggregateInput
    _max?: NeedMaxOrderByAggregateInput
    _min?: NeedMinOrderByAggregateInput
    _sum?: NeedSumOrderByAggregateInput
  }

  export type NeedScalarWhereWithAggregatesInput = {
    AND?: NeedScalarWhereWithAggregatesInput | NeedScalarWhereWithAggregatesInput[]
    OR?: NeedScalarWhereWithAggregatesInput[]
    NOT?: NeedScalarWhereWithAggregatesInput | NeedScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Need"> | string
    title?: StringWithAggregatesFilter<"Need"> | string
    description?: StringWithAggregatesFilter<"Need"> | string
    category?: StringWithAggregatesFilter<"Need"> | string
    priority?: StringWithAggregatesFilter<"Need"> | string
    budget?: FloatWithAggregatesFilter<"Need"> | number
    justification?: StringNullableWithAggregatesFilter<"Need"> | string | null
    status?: StringWithAggregatesFilter<"Need"> | string
    requesterId?: IntNullableWithAggregatesFilter<"Need"> | number | null
    requesterName?: StringNullableWithAggregatesFilter<"Need"> | string | null
    organizationId?: IntWithAggregatesFilter<"Need"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Need"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Need"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"Need"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"Need"> | Date | string | null
    needsSync?: BoolWithAggregatesFilter<"Need"> | boolean
  }

  export type NeedWorkflowStepWhereInput = {
    AND?: NeedWorkflowStepWhereInput | NeedWorkflowStepWhereInput[]
    OR?: NeedWorkflowStepWhereInput[]
    NOT?: NeedWorkflowStepWhereInput | NeedWorkflowStepWhereInput[]
    id?: StringFilter<"NeedWorkflowStep"> | string
    needId?: StringFilter<"NeedWorkflowStep"> | string
    reviewerId?: IntNullableFilter<"NeedWorkflowStep"> | number | null
    reviewerName?: StringFilter<"NeedWorkflowStep"> | string
    reviewerLevel?: IntFilter<"NeedWorkflowStep"> | number
    action?: StringFilter<"NeedWorkflowStep"> | string
    isRequired?: BoolFilter<"NeedWorkflowStep"> | boolean
    isCompleted?: BoolFilter<"NeedWorkflowStep"> | boolean
    comment?: StringNullableFilter<"NeedWorkflowStep"> | string | null
    createdAt?: DateTimeFilter<"NeedWorkflowStep"> | Date | string
    completedAt?: DateTimeNullableFilter<"NeedWorkflowStep"> | Date | string | null
    syncId?: StringNullableFilter<"NeedWorkflowStep"> | string | null
    needsSync?: BoolFilter<"NeedWorkflowStep"> | boolean
    need?: XOR<NeedScalarRelationFilter, NeedWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type NeedWorkflowStepOrderByWithRelationInput = {
    id?: SortOrder
    needId?: SortOrder
    reviewerId?: SortOrderInput | SortOrder
    reviewerName?: SortOrder
    reviewerLevel?: SortOrder
    action?: SortOrder
    isRequired?: SortOrder
    isCompleted?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    need?: NeedOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
  }

  export type NeedWorkflowStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: NeedWorkflowStepWhereInput | NeedWorkflowStepWhereInput[]
    OR?: NeedWorkflowStepWhereInput[]
    NOT?: NeedWorkflowStepWhereInput | NeedWorkflowStepWhereInput[]
    needId?: StringFilter<"NeedWorkflowStep"> | string
    reviewerId?: IntNullableFilter<"NeedWorkflowStep"> | number | null
    reviewerName?: StringFilter<"NeedWorkflowStep"> | string
    reviewerLevel?: IntFilter<"NeedWorkflowStep"> | number
    action?: StringFilter<"NeedWorkflowStep"> | string
    isRequired?: BoolFilter<"NeedWorkflowStep"> | boolean
    isCompleted?: BoolFilter<"NeedWorkflowStep"> | boolean
    comment?: StringNullableFilter<"NeedWorkflowStep"> | string | null
    createdAt?: DateTimeFilter<"NeedWorkflowStep"> | Date | string
    completedAt?: DateTimeNullableFilter<"NeedWorkflowStep"> | Date | string | null
    needsSync?: BoolFilter<"NeedWorkflowStep"> | boolean
    need?: XOR<NeedScalarRelationFilter, NeedWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id" | "syncId">

  export type NeedWorkflowStepOrderByWithAggregationInput = {
    id?: SortOrder
    needId?: SortOrder
    reviewerId?: SortOrderInput | SortOrder
    reviewerName?: SortOrder
    reviewerLevel?: SortOrder
    action?: SortOrder
    isRequired?: SortOrder
    isCompleted?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: NeedWorkflowStepCountOrderByAggregateInput
    _avg?: NeedWorkflowStepAvgOrderByAggregateInput
    _max?: NeedWorkflowStepMaxOrderByAggregateInput
    _min?: NeedWorkflowStepMinOrderByAggregateInput
    _sum?: NeedWorkflowStepSumOrderByAggregateInput
  }

  export type NeedWorkflowStepScalarWhereWithAggregatesInput = {
    AND?: NeedWorkflowStepScalarWhereWithAggregatesInput | NeedWorkflowStepScalarWhereWithAggregatesInput[]
    OR?: NeedWorkflowStepScalarWhereWithAggregatesInput[]
    NOT?: NeedWorkflowStepScalarWhereWithAggregatesInput | NeedWorkflowStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NeedWorkflowStep"> | string
    needId?: StringWithAggregatesFilter<"NeedWorkflowStep"> | string
    reviewerId?: IntNullableWithAggregatesFilter<"NeedWorkflowStep"> | number | null
    reviewerName?: StringWithAggregatesFilter<"NeedWorkflowStep"> | string
    reviewerLevel?: IntWithAggregatesFilter<"NeedWorkflowStep"> | number
    action?: StringWithAggregatesFilter<"NeedWorkflowStep"> | string
    isRequired?: BoolWithAggregatesFilter<"NeedWorkflowStep"> | boolean
    isCompleted?: BoolWithAggregatesFilter<"NeedWorkflowStep"> | boolean
    comment?: StringNullableWithAggregatesFilter<"NeedWorkflowStep"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NeedWorkflowStep"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"NeedWorkflowStep"> | Date | string | null
    syncId?: StringNullableWithAggregatesFilter<"NeedWorkflowStep"> | string | null
    needsSync?: BoolWithAggregatesFilter<"NeedWorkflowStep"> | boolean
  }

  export type NeedAttachmentWhereInput = {
    AND?: NeedAttachmentWhereInput | NeedAttachmentWhereInput[]
    OR?: NeedAttachmentWhereInput[]
    NOT?: NeedAttachmentWhereInput | NeedAttachmentWhereInput[]
    id?: StringFilter<"NeedAttachment"> | string
    needId?: StringFilter<"NeedAttachment"> | string
    fileName?: StringFilter<"NeedAttachment"> | string
    fileSize?: IntFilter<"NeedAttachment"> | number
    fileType?: StringFilter<"NeedAttachment"> | string
    uploadedBy?: StringFilter<"NeedAttachment"> | string
    url?: StringFilter<"NeedAttachment"> | string
    localPath?: StringNullableFilter<"NeedAttachment"> | string | null
    createdAt?: DateTimeFilter<"NeedAttachment"> | Date | string
    syncId?: StringNullableFilter<"NeedAttachment"> | string | null
    needsSync?: BoolFilter<"NeedAttachment"> | boolean
    need?: XOR<NeedScalarRelationFilter, NeedWhereInput>
  }

  export type NeedAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    needId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    uploadedBy?: SortOrder
    url?: SortOrder
    localPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    need?: NeedOrderByWithRelationInput
  }

  export type NeedAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: NeedAttachmentWhereInput | NeedAttachmentWhereInput[]
    OR?: NeedAttachmentWhereInput[]
    NOT?: NeedAttachmentWhereInput | NeedAttachmentWhereInput[]
    needId?: StringFilter<"NeedAttachment"> | string
    fileName?: StringFilter<"NeedAttachment"> | string
    fileSize?: IntFilter<"NeedAttachment"> | number
    fileType?: StringFilter<"NeedAttachment"> | string
    uploadedBy?: StringFilter<"NeedAttachment"> | string
    url?: StringFilter<"NeedAttachment"> | string
    localPath?: StringNullableFilter<"NeedAttachment"> | string | null
    createdAt?: DateTimeFilter<"NeedAttachment"> | Date | string
    needsSync?: BoolFilter<"NeedAttachment"> | boolean
    need?: XOR<NeedScalarRelationFilter, NeedWhereInput>
  }, "id" | "syncId">

  export type NeedAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    needId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    uploadedBy?: SortOrder
    url?: SortOrder
    localPath?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: NeedAttachmentCountOrderByAggregateInput
    _avg?: NeedAttachmentAvgOrderByAggregateInput
    _max?: NeedAttachmentMaxOrderByAggregateInput
    _min?: NeedAttachmentMinOrderByAggregateInput
    _sum?: NeedAttachmentSumOrderByAggregateInput
  }

  export type NeedAttachmentScalarWhereWithAggregatesInput = {
    AND?: NeedAttachmentScalarWhereWithAggregatesInput | NeedAttachmentScalarWhereWithAggregatesInput[]
    OR?: NeedAttachmentScalarWhereWithAggregatesInput[]
    NOT?: NeedAttachmentScalarWhereWithAggregatesInput | NeedAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NeedAttachment"> | string
    needId?: StringWithAggregatesFilter<"NeedAttachment"> | string
    fileName?: StringWithAggregatesFilter<"NeedAttachment"> | string
    fileSize?: IntWithAggregatesFilter<"NeedAttachment"> | number
    fileType?: StringWithAggregatesFilter<"NeedAttachment"> | string
    uploadedBy?: StringWithAggregatesFilter<"NeedAttachment"> | string
    url?: StringWithAggregatesFilter<"NeedAttachment"> | string
    localPath?: StringNullableWithAggregatesFilter<"NeedAttachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NeedAttachment"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"NeedAttachment"> | string | null
    needsSync?: BoolWithAggregatesFilter<"NeedAttachment"> | boolean
  }

  export type InvoiceClientWhereInput = {
    AND?: InvoiceClientWhereInput | InvoiceClientWhereInput[]
    OR?: InvoiceClientWhereInput[]
    NOT?: InvoiceClientWhereInput | InvoiceClientWhereInput[]
    id?: StringFilter<"InvoiceClient"> | string
    company?: StringFilter<"InvoiceClient"> | string
    companyName?: StringFilter<"InvoiceClient"> | string
    contactName?: StringFilter<"InvoiceClient"> | string
    email?: StringNullableFilter<"InvoiceClient"> | string | null
    phone?: StringNullableFilter<"InvoiceClient"> | string | null
    address?: StringNullableFilter<"InvoiceClient"> | string | null
    city?: StringNullableFilter<"InvoiceClient"> | string | null
    country?: StringNullableFilter<"InvoiceClient"> | string | null
    taxNumber?: StringNullableFilter<"InvoiceClient"> | string | null
    notes?: StringNullableFilter<"InvoiceClient"> | string | null
    createdAt?: DateTimeFilter<"InvoiceClient"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceClient"> | Date | string
    syncId?: StringNullableFilter<"InvoiceClient"> | string | null
    lastSynced?: DateTimeNullableFilter<"InvoiceClient"> | Date | string | null
    needsSync?: BoolFilter<"InvoiceClient"> | boolean
    invoices?: InvoiceListRelationFilter
  }

  export type InvoiceClientOrderByWithRelationInput = {
    id?: SortOrder
    company?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    invoices?: InvoiceOrderByRelationAggregateInput
  }

  export type InvoiceClientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: InvoiceClientWhereInput | InvoiceClientWhereInput[]
    OR?: InvoiceClientWhereInput[]
    NOT?: InvoiceClientWhereInput | InvoiceClientWhereInput[]
    company?: StringFilter<"InvoiceClient"> | string
    companyName?: StringFilter<"InvoiceClient"> | string
    contactName?: StringFilter<"InvoiceClient"> | string
    email?: StringNullableFilter<"InvoiceClient"> | string | null
    phone?: StringNullableFilter<"InvoiceClient"> | string | null
    address?: StringNullableFilter<"InvoiceClient"> | string | null
    city?: StringNullableFilter<"InvoiceClient"> | string | null
    country?: StringNullableFilter<"InvoiceClient"> | string | null
    taxNumber?: StringNullableFilter<"InvoiceClient"> | string | null
    notes?: StringNullableFilter<"InvoiceClient"> | string | null
    createdAt?: DateTimeFilter<"InvoiceClient"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceClient"> | Date | string
    lastSynced?: DateTimeNullableFilter<"InvoiceClient"> | Date | string | null
    needsSync?: BoolFilter<"InvoiceClient"> | boolean
    invoices?: InvoiceListRelationFilter
  }, "id" | "syncId">

  export type InvoiceClientOrderByWithAggregationInput = {
    id?: SortOrder
    company?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    taxNumber?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: InvoiceClientCountOrderByAggregateInput
    _max?: InvoiceClientMaxOrderByAggregateInput
    _min?: InvoiceClientMinOrderByAggregateInput
  }

  export type InvoiceClientScalarWhereWithAggregatesInput = {
    AND?: InvoiceClientScalarWhereWithAggregatesInput | InvoiceClientScalarWhereWithAggregatesInput[]
    OR?: InvoiceClientScalarWhereWithAggregatesInput[]
    NOT?: InvoiceClientScalarWhereWithAggregatesInput | InvoiceClientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceClient"> | string
    company?: StringWithAggregatesFilter<"InvoiceClient"> | string
    companyName?: StringWithAggregatesFilter<"InvoiceClient"> | string
    contactName?: StringWithAggregatesFilter<"InvoiceClient"> | string
    email?: StringNullableWithAggregatesFilter<"InvoiceClient"> | string | null
    phone?: StringNullableWithAggregatesFilter<"InvoiceClient"> | string | null
    address?: StringNullableWithAggregatesFilter<"InvoiceClient"> | string | null
    city?: StringNullableWithAggregatesFilter<"InvoiceClient"> | string | null
    country?: StringNullableWithAggregatesFilter<"InvoiceClient"> | string | null
    taxNumber?: StringNullableWithAggregatesFilter<"InvoiceClient"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InvoiceClient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceClient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceClient"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"InvoiceClient"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"InvoiceClient"> | Date | string | null
    needsSync?: BoolWithAggregatesFilter<"InvoiceClient"> | boolean
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    template?: StringFilter<"Invoice"> | string
    company?: StringFilter<"Invoice"> | string
    clientId?: StringFilter<"Invoice"> | string
    clientSnapshot?: StringNullableFilter<"Invoice"> | string | null
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    subtotal?: FloatFilter<"Invoice"> | number
    taxRate?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    serviceType?: StringNullableFilter<"Invoice"> | string | null
    templateCode?: StringNullableFilter<"Invoice"> | string | null
    placementTVAEnabled?: BoolFilter<"Invoice"> | boolean
    chargesTTCMode?: BoolFilter<"Invoice"> | boolean
    placementDeduction?: FloatFilter<"Invoice"> | number
    enablePlacementDeduction?: BoolFilter<"Invoice"> | boolean
    transfertDeduction?: FloatFilter<"Invoice"> | number
    enableTransfertDeduction?: BoolFilter<"Invoice"> | boolean
    projectDescription?: StringNullableFilter<"Invoice"> | string | null
    projectName?: StringNullableFilter<"Invoice"> | string | null
    managementFeeRate?: FloatNullableFilter<"Invoice"> | number | null
    commissionRate?: FloatNullableFilter<"Invoice"> | number | null
    acomptes?: StringNullableFilter<"Invoice"> | string | null
    status?: StringFilter<"Invoice"> | string
    paymentTerms?: StringNullableFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAmount?: FloatFilter<"Invoice"> | number
    notes?: StringNullableFilter<"Invoice"> | string | null
    publicNotes?: StringNullableFilter<"Invoice"> | string | null
    createdBy?: StringFilter<"Invoice"> | string
    createdByInitials?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    syncId?: StringNullableFilter<"Invoice"> | string | null
    lastSynced?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    needsSync?: BoolFilter<"Invoice"> | boolean
    client?: XOR<InvoiceClientScalarRelationFilter, InvoiceClientWhereInput>
    lines?: InvoiceLineListRelationFilter
    sections?: InvoiceSectionListRelationFilter
    payments?: InvoicePaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    template?: SortOrder
    company?: SortOrder
    clientId?: SortOrder
    clientSnapshot?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    serviceType?: SortOrderInput | SortOrder
    templateCode?: SortOrderInput | SortOrder
    placementTVAEnabled?: SortOrder
    chargesTTCMode?: SortOrder
    placementDeduction?: SortOrder
    enablePlacementDeduction?: SortOrder
    transfertDeduction?: SortOrder
    enableTransfertDeduction?: SortOrder
    projectDescription?: SortOrderInput | SortOrder
    projectName?: SortOrderInput | SortOrder
    managementFeeRate?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    acomptes?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    paidAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    publicNotes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdByInitials?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    client?: InvoiceClientOrderByWithRelationInput
    lines?: InvoiceLineOrderByRelationAggregateInput
    sections?: InvoiceSectionOrderByRelationAggregateInput
    payments?: InvoicePaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoiceNumber?: string
    syncId?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    template?: StringFilter<"Invoice"> | string
    company?: StringFilter<"Invoice"> | string
    clientId?: StringFilter<"Invoice"> | string
    clientSnapshot?: StringNullableFilter<"Invoice"> | string | null
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    subtotal?: FloatFilter<"Invoice"> | number
    taxRate?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    serviceType?: StringNullableFilter<"Invoice"> | string | null
    templateCode?: StringNullableFilter<"Invoice"> | string | null
    placementTVAEnabled?: BoolFilter<"Invoice"> | boolean
    chargesTTCMode?: BoolFilter<"Invoice"> | boolean
    placementDeduction?: FloatFilter<"Invoice"> | number
    enablePlacementDeduction?: BoolFilter<"Invoice"> | boolean
    transfertDeduction?: FloatFilter<"Invoice"> | number
    enableTransfertDeduction?: BoolFilter<"Invoice"> | boolean
    projectDescription?: StringNullableFilter<"Invoice"> | string | null
    projectName?: StringNullableFilter<"Invoice"> | string | null
    managementFeeRate?: FloatNullableFilter<"Invoice"> | number | null
    commissionRate?: FloatNullableFilter<"Invoice"> | number | null
    acomptes?: StringNullableFilter<"Invoice"> | string | null
    status?: StringFilter<"Invoice"> | string
    paymentTerms?: StringNullableFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAmount?: FloatFilter<"Invoice"> | number
    notes?: StringNullableFilter<"Invoice"> | string | null
    publicNotes?: StringNullableFilter<"Invoice"> | string | null
    createdBy?: StringFilter<"Invoice"> | string
    createdByInitials?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    lastSynced?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    needsSync?: BoolFilter<"Invoice"> | boolean
    client?: XOR<InvoiceClientScalarRelationFilter, InvoiceClientWhereInput>
    lines?: InvoiceLineListRelationFilter
    sections?: InvoiceSectionListRelationFilter
    payments?: InvoicePaymentListRelationFilter
  }, "id" | "invoiceNumber" | "syncId">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    template?: SortOrder
    company?: SortOrder
    clientId?: SortOrder
    clientSnapshot?: SortOrderInput | SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    serviceType?: SortOrderInput | SortOrder
    templateCode?: SortOrderInput | SortOrder
    placementTVAEnabled?: SortOrder
    chargesTTCMode?: SortOrder
    placementDeduction?: SortOrder
    enablePlacementDeduction?: SortOrder
    transfertDeduction?: SortOrder
    enableTransfertDeduction?: SortOrder
    projectDescription?: SortOrderInput | SortOrder
    projectName?: SortOrderInput | SortOrder
    managementFeeRate?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    acomptes?: SortOrderInput | SortOrder
    status?: SortOrder
    paymentTerms?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    paidAmount?: SortOrder
    notes?: SortOrderInput | SortOrder
    publicNotes?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    createdByInitials?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    invoiceNumber?: StringWithAggregatesFilter<"Invoice"> | string
    template?: StringWithAggregatesFilter<"Invoice"> | string
    company?: StringWithAggregatesFilter<"Invoice"> | string
    clientId?: StringWithAggregatesFilter<"Invoice"> | string
    clientSnapshot?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    issueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    subtotal?: FloatWithAggregatesFilter<"Invoice"> | number
    taxRate?: FloatWithAggregatesFilter<"Invoice"> | number
    taxAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    total?: FloatWithAggregatesFilter<"Invoice"> | number
    serviceType?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    templateCode?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    placementTVAEnabled?: BoolWithAggregatesFilter<"Invoice"> | boolean
    chargesTTCMode?: BoolWithAggregatesFilter<"Invoice"> | boolean
    placementDeduction?: FloatWithAggregatesFilter<"Invoice"> | number
    enablePlacementDeduction?: BoolWithAggregatesFilter<"Invoice"> | boolean
    transfertDeduction?: FloatWithAggregatesFilter<"Invoice"> | number
    enableTransfertDeduction?: BoolWithAggregatesFilter<"Invoice"> | boolean
    projectDescription?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    projectName?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    managementFeeRate?: FloatNullableWithAggregatesFilter<"Invoice"> | number | null
    commissionRate?: FloatNullableWithAggregatesFilter<"Invoice"> | number | null
    acomptes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    status?: StringWithAggregatesFilter<"Invoice"> | string
    paymentTerms?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    paidAmount?: FloatWithAggregatesFilter<"Invoice"> | number
    notes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    publicNotes?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdBy?: StringWithAggregatesFilter<"Invoice"> | string
    createdByInitials?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    needsSync?: BoolWithAggregatesFilter<"Invoice"> | boolean
  }

  export type InvoiceLineWhereInput = {
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    id?: StringFilter<"InvoiceLine"> | string
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    quantity?: FloatFilter<"InvoiceLine"> | number
    unitPrice?: FloatFilter<"InvoiceLine"> | number
    total?: FloatFilter<"InvoiceLine"> | number
    chargesTTC?: FloatNullableFilter<"InvoiceLine"> | number | null
    squareMeters?: FloatNullableFilter<"InvoiceLine"> | number | null
    days?: FloatNullableFilter<"InvoiceLine"> | number | null
    sortOrder?: IntFilter<"InvoiceLine"> | number
    createdAt?: DateTimeFilter<"InvoiceLine"> | Date | string
    syncId?: StringNullableFilter<"InvoiceLine"> | string | null
    needsSync?: BoolFilter<"InvoiceLine"> | boolean
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceLineOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    chargesTTC?: SortOrderInput | SortOrder
    squareMeters?: SortOrderInput | SortOrder
    days?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    quantity?: FloatFilter<"InvoiceLine"> | number
    unitPrice?: FloatFilter<"InvoiceLine"> | number
    total?: FloatFilter<"InvoiceLine"> | number
    chargesTTC?: FloatNullableFilter<"InvoiceLine"> | number | null
    squareMeters?: FloatNullableFilter<"InvoiceLine"> | number | null
    days?: FloatNullableFilter<"InvoiceLine"> | number | null
    sortOrder?: IntFilter<"InvoiceLine"> | number
    createdAt?: DateTimeFilter<"InvoiceLine"> | Date | string
    needsSync?: BoolFilter<"InvoiceLine"> | boolean
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id" | "syncId">

  export type InvoiceLineOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    chargesTTC?: SortOrderInput | SortOrder
    squareMeters?: SortOrderInput | SortOrder
    days?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: InvoiceLineCountOrderByAggregateInput
    _avg?: InvoiceLineAvgOrderByAggregateInput
    _max?: InvoiceLineMaxOrderByAggregateInput
    _min?: InvoiceLineMinOrderByAggregateInput
    _sum?: InvoiceLineSumOrderByAggregateInput
  }

  export type InvoiceLineScalarWhereWithAggregatesInput = {
    AND?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    OR?: InvoiceLineScalarWhereWithAggregatesInput[]
    NOT?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceLine"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceLine"> | string
    description?: StringWithAggregatesFilter<"InvoiceLine"> | string
    quantity?: FloatWithAggregatesFilter<"InvoiceLine"> | number
    unitPrice?: FloatWithAggregatesFilter<"InvoiceLine"> | number
    total?: FloatWithAggregatesFilter<"InvoiceLine"> | number
    chargesTTC?: FloatNullableWithAggregatesFilter<"InvoiceLine"> | number | null
    squareMeters?: FloatNullableWithAggregatesFilter<"InvoiceLine"> | number | null
    days?: FloatNullableWithAggregatesFilter<"InvoiceLine"> | number | null
    sortOrder?: IntWithAggregatesFilter<"InvoiceLine"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceLine"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"InvoiceLine"> | string | null
    needsSync?: BoolWithAggregatesFilter<"InvoiceLine"> | boolean
  }

  export type InvoiceSectionWhereInput = {
    AND?: InvoiceSectionWhereInput | InvoiceSectionWhereInput[]
    OR?: InvoiceSectionWhereInput[]
    NOT?: InvoiceSectionWhereInput | InvoiceSectionWhereInput[]
    id?: StringFilter<"InvoiceSection"> | string
    invoiceId?: StringFilter<"InvoiceSection"> | string
    title?: StringFilter<"InvoiceSection"> | string
    subtotal?: FloatFilter<"InvoiceSection"> | number
    sortOrder?: IntFilter<"InvoiceSection"> | number
    createdAt?: DateTimeFilter<"InvoiceSection"> | Date | string
    syncId?: StringNullableFilter<"InvoiceSection"> | string | null
    needsSync?: BoolFilter<"InvoiceSection"> | boolean
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    lines?: InvoiceSectionLineListRelationFilter
  }

  export type InvoiceSectionOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    title?: SortOrder
    subtotal?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
    lines?: InvoiceSectionLineOrderByRelationAggregateInput
  }

  export type InvoiceSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: InvoiceSectionWhereInput | InvoiceSectionWhereInput[]
    OR?: InvoiceSectionWhereInput[]
    NOT?: InvoiceSectionWhereInput | InvoiceSectionWhereInput[]
    invoiceId?: StringFilter<"InvoiceSection"> | string
    title?: StringFilter<"InvoiceSection"> | string
    subtotal?: FloatFilter<"InvoiceSection"> | number
    sortOrder?: IntFilter<"InvoiceSection"> | number
    createdAt?: DateTimeFilter<"InvoiceSection"> | Date | string
    needsSync?: BoolFilter<"InvoiceSection"> | boolean
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
    lines?: InvoiceSectionLineListRelationFilter
  }, "id" | "syncId">

  export type InvoiceSectionOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    title?: SortOrder
    subtotal?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: InvoiceSectionCountOrderByAggregateInput
    _avg?: InvoiceSectionAvgOrderByAggregateInput
    _max?: InvoiceSectionMaxOrderByAggregateInput
    _min?: InvoiceSectionMinOrderByAggregateInput
    _sum?: InvoiceSectionSumOrderByAggregateInput
  }

  export type InvoiceSectionScalarWhereWithAggregatesInput = {
    AND?: InvoiceSectionScalarWhereWithAggregatesInput | InvoiceSectionScalarWhereWithAggregatesInput[]
    OR?: InvoiceSectionScalarWhereWithAggregatesInput[]
    NOT?: InvoiceSectionScalarWhereWithAggregatesInput | InvoiceSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceSection"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceSection"> | string
    title?: StringWithAggregatesFilter<"InvoiceSection"> | string
    subtotal?: FloatWithAggregatesFilter<"InvoiceSection"> | number
    sortOrder?: IntWithAggregatesFilter<"InvoiceSection"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceSection"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"InvoiceSection"> | string | null
    needsSync?: BoolWithAggregatesFilter<"InvoiceSection"> | boolean
  }

  export type InvoiceSectionLineWhereInput = {
    AND?: InvoiceSectionLineWhereInput | InvoiceSectionLineWhereInput[]
    OR?: InvoiceSectionLineWhereInput[]
    NOT?: InvoiceSectionLineWhereInput | InvoiceSectionLineWhereInput[]
    id?: StringFilter<"InvoiceSectionLine"> | string
    sectionId?: StringFilter<"InvoiceSectionLine"> | string
    description?: StringFilter<"InvoiceSectionLine"> | string
    quantity?: FloatFilter<"InvoiceSectionLine"> | number
    squareMeters?: FloatNullableFilter<"InvoiceSectionLine"> | number | null
    days?: FloatNullableFilter<"InvoiceSectionLine"> | number | null
    unitPrice?: FloatFilter<"InvoiceSectionLine"> | number
    total?: FloatFilter<"InvoiceSectionLine"> | number
    daysImpactPrice?: BoolFilter<"InvoiceSectionLine"> | boolean
    sortOrder?: IntFilter<"InvoiceSectionLine"> | number
    createdAt?: DateTimeFilter<"InvoiceSectionLine"> | Date | string
    syncId?: StringNullableFilter<"InvoiceSectionLine"> | string | null
    needsSync?: BoolFilter<"InvoiceSectionLine"> | boolean
    section?: XOR<InvoiceSectionScalarRelationFilter, InvoiceSectionWhereInput>
  }

  export type InvoiceSectionLineOrderByWithRelationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    squareMeters?: SortOrderInput | SortOrder
    days?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    daysImpactPrice?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    section?: InvoiceSectionOrderByWithRelationInput
  }

  export type InvoiceSectionLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: InvoiceSectionLineWhereInput | InvoiceSectionLineWhereInput[]
    OR?: InvoiceSectionLineWhereInput[]
    NOT?: InvoiceSectionLineWhereInput | InvoiceSectionLineWhereInput[]
    sectionId?: StringFilter<"InvoiceSectionLine"> | string
    description?: StringFilter<"InvoiceSectionLine"> | string
    quantity?: FloatFilter<"InvoiceSectionLine"> | number
    squareMeters?: FloatNullableFilter<"InvoiceSectionLine"> | number | null
    days?: FloatNullableFilter<"InvoiceSectionLine"> | number | null
    unitPrice?: FloatFilter<"InvoiceSectionLine"> | number
    total?: FloatFilter<"InvoiceSectionLine"> | number
    daysImpactPrice?: BoolFilter<"InvoiceSectionLine"> | boolean
    sortOrder?: IntFilter<"InvoiceSectionLine"> | number
    createdAt?: DateTimeFilter<"InvoiceSectionLine"> | Date | string
    needsSync?: BoolFilter<"InvoiceSectionLine"> | boolean
    section?: XOR<InvoiceSectionScalarRelationFilter, InvoiceSectionWhereInput>
  }, "id" | "syncId">

  export type InvoiceSectionLineOrderByWithAggregationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    squareMeters?: SortOrderInput | SortOrder
    days?: SortOrderInput | SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    daysImpactPrice?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: InvoiceSectionLineCountOrderByAggregateInput
    _avg?: InvoiceSectionLineAvgOrderByAggregateInput
    _max?: InvoiceSectionLineMaxOrderByAggregateInput
    _min?: InvoiceSectionLineMinOrderByAggregateInput
    _sum?: InvoiceSectionLineSumOrderByAggregateInput
  }

  export type InvoiceSectionLineScalarWhereWithAggregatesInput = {
    AND?: InvoiceSectionLineScalarWhereWithAggregatesInput | InvoiceSectionLineScalarWhereWithAggregatesInput[]
    OR?: InvoiceSectionLineScalarWhereWithAggregatesInput[]
    NOT?: InvoiceSectionLineScalarWhereWithAggregatesInput | InvoiceSectionLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceSectionLine"> | string
    sectionId?: StringWithAggregatesFilter<"InvoiceSectionLine"> | string
    description?: StringWithAggregatesFilter<"InvoiceSectionLine"> | string
    quantity?: FloatWithAggregatesFilter<"InvoiceSectionLine"> | number
    squareMeters?: FloatNullableWithAggregatesFilter<"InvoiceSectionLine"> | number | null
    days?: FloatNullableWithAggregatesFilter<"InvoiceSectionLine"> | number | null
    unitPrice?: FloatWithAggregatesFilter<"InvoiceSectionLine"> | number
    total?: FloatWithAggregatesFilter<"InvoiceSectionLine"> | number
    daysImpactPrice?: BoolWithAggregatesFilter<"InvoiceSectionLine"> | boolean
    sortOrder?: IntWithAggregatesFilter<"InvoiceSectionLine"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceSectionLine"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"InvoiceSectionLine"> | string | null
    needsSync?: BoolWithAggregatesFilter<"InvoiceSectionLine"> | boolean
  }

  export type InvoicePaymentWhereInput = {
    AND?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    OR?: InvoicePaymentWhereInput[]
    NOT?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    id?: StringFilter<"InvoicePayment"> | string
    invoiceId?: StringFilter<"InvoicePayment"> | string
    amount?: FloatFilter<"InvoicePayment"> | number
    paymentDate?: DateTimeFilter<"InvoicePayment"> | Date | string
    paymentMethod?: StringNullableFilter<"InvoicePayment"> | string | null
    reference?: StringNullableFilter<"InvoicePayment"> | string | null
    notes?: StringNullableFilter<"InvoicePayment"> | string | null
    createdAt?: DateTimeFilter<"InvoicePayment"> | Date | string
    syncId?: StringNullableFilter<"InvoicePayment"> | string | null
    needsSync?: BoolFilter<"InvoicePayment"> | boolean
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type InvoicePaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoicePaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    OR?: InvoicePaymentWhereInput[]
    NOT?: InvoicePaymentWhereInput | InvoicePaymentWhereInput[]
    invoiceId?: StringFilter<"InvoicePayment"> | string
    amount?: FloatFilter<"InvoicePayment"> | number
    paymentDate?: DateTimeFilter<"InvoicePayment"> | Date | string
    paymentMethod?: StringNullableFilter<"InvoicePayment"> | string | null
    reference?: StringNullableFilter<"InvoicePayment"> | string | null
    notes?: StringNullableFilter<"InvoicePayment"> | string | null
    createdAt?: DateTimeFilter<"InvoicePayment"> | Date | string
    needsSync?: BoolFilter<"InvoicePayment"> | boolean
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id" | "syncId">

  export type InvoicePaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: InvoicePaymentCountOrderByAggregateInput
    _avg?: InvoicePaymentAvgOrderByAggregateInput
    _max?: InvoicePaymentMaxOrderByAggregateInput
    _min?: InvoicePaymentMinOrderByAggregateInput
    _sum?: InvoicePaymentSumOrderByAggregateInput
  }

  export type InvoicePaymentScalarWhereWithAggregatesInput = {
    AND?: InvoicePaymentScalarWhereWithAggregatesInput | InvoicePaymentScalarWhereWithAggregatesInput[]
    OR?: InvoicePaymentScalarWhereWithAggregatesInput[]
    NOT?: InvoicePaymentScalarWhereWithAggregatesInput | InvoicePaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoicePayment"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoicePayment"> | string
    amount?: FloatWithAggregatesFilter<"InvoicePayment"> | number
    paymentDate?: DateTimeWithAggregatesFilter<"InvoicePayment"> | Date | string
    paymentMethod?: StringNullableWithAggregatesFilter<"InvoicePayment"> | string | null
    reference?: StringNullableWithAggregatesFilter<"InvoicePayment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InvoicePayment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InvoicePayment"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"InvoicePayment"> | string | null
    needsSync?: BoolWithAggregatesFilter<"InvoicePayment"> | boolean
  }

  export type ExpenseCategoryWhereInput = {
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    id?: StringFilter<"ExpenseCategory"> | string
    company?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    color?: StringNullableFilter<"ExpenseCategory"> | string | null
    icon?: StringNullableFilter<"ExpenseCategory"> | string | null
    isActive?: BoolFilter<"ExpenseCategory"> | boolean
    sortOrder?: IntFilter<"ExpenseCategory"> | number
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    syncId?: StringNullableFilter<"ExpenseCategory"> | string | null
    lastSynced?: DateTimeNullableFilter<"ExpenseCategory"> | Date | string | null
    needsSync?: BoolFilter<"ExpenseCategory"> | boolean
    expenses?: ExpenseListRelationFilter
  }

  export type ExpenseCategoryOrderByWithRelationInput = {
    id?: SortOrder
    company?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    expenses?: ExpenseOrderByRelationAggregateInput
  }

  export type ExpenseCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    company_name?: ExpenseCategoryCompanyNameCompoundUniqueInput
    AND?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    OR?: ExpenseCategoryWhereInput[]
    NOT?: ExpenseCategoryWhereInput | ExpenseCategoryWhereInput[]
    company?: StringFilter<"ExpenseCategory"> | string
    name?: StringFilter<"ExpenseCategory"> | string
    color?: StringNullableFilter<"ExpenseCategory"> | string | null
    icon?: StringNullableFilter<"ExpenseCategory"> | string | null
    isActive?: BoolFilter<"ExpenseCategory"> | boolean
    sortOrder?: IntFilter<"ExpenseCategory"> | number
    createdAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeFilter<"ExpenseCategory"> | Date | string
    lastSynced?: DateTimeNullableFilter<"ExpenseCategory"> | Date | string | null
    needsSync?: BoolFilter<"ExpenseCategory"> | boolean
    expenses?: ExpenseListRelationFilter
  }, "id" | "syncId" | "company_name">

  export type ExpenseCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    company?: SortOrder
    name?: SortOrder
    color?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: ExpenseCategoryCountOrderByAggregateInput
    _avg?: ExpenseCategoryAvgOrderByAggregateInput
    _max?: ExpenseCategoryMaxOrderByAggregateInput
    _min?: ExpenseCategoryMinOrderByAggregateInput
    _sum?: ExpenseCategorySumOrderByAggregateInput
  }

  export type ExpenseCategoryScalarWhereWithAggregatesInput = {
    AND?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    OR?: ExpenseCategoryScalarWhereWithAggregatesInput[]
    NOT?: ExpenseCategoryScalarWhereWithAggregatesInput | ExpenseCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    company?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    name?: StringWithAggregatesFilter<"ExpenseCategory"> | string
    color?: StringNullableWithAggregatesFilter<"ExpenseCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ExpenseCategory"> | string | null
    isActive?: BoolWithAggregatesFilter<"ExpenseCategory"> | boolean
    sortOrder?: IntWithAggregatesFilter<"ExpenseCategory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ExpenseCategory"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"ExpenseCategory"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"ExpenseCategory"> | Date | string | null
    needsSync?: BoolWithAggregatesFilter<"ExpenseCategory"> | boolean
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: StringFilter<"Expense"> | string
    company?: StringFilter<"Expense"> | string
    categoryId?: StringNullableFilter<"Expense"> | string | null
    description?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    paymentMethod?: StringNullableFilter<"Expense"> | string | null
    reference?: StringNullableFilter<"Expense"> | string | null
    vendor?: StringNullableFilter<"Expense"> | string | null
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    localReceiptPath?: StringNullableFilter<"Expense"> | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    createdBy?: StringNullableFilter<"Expense"> | string | null
    createdByName?: StringNullableFilter<"Expense"> | string | null
    isRecurring?: BoolFilter<"Expense"> | boolean
    recurringType?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    syncId?: StringNullableFilter<"Expense"> | string | null
    lastSynced?: DateTimeNullableFilter<"Expense"> | Date | string | null
    needsSync?: BoolFilter<"Expense"> | boolean
    category?: XOR<ExpenseCategoryNullableScalarRelationFilter, ExpenseCategoryWhereInput> | null
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    company?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    description?: SortOrder
    amount?: SortOrder
    expenseDate?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    localReceiptPath?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdByName?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurringType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    category?: ExpenseCategoryOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    company?: StringFilter<"Expense"> | string
    categoryId?: StringNullableFilter<"Expense"> | string | null
    description?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    paymentMethod?: StringNullableFilter<"Expense"> | string | null
    reference?: StringNullableFilter<"Expense"> | string | null
    vendor?: StringNullableFilter<"Expense"> | string | null
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    localReceiptPath?: StringNullableFilter<"Expense"> | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    createdBy?: StringNullableFilter<"Expense"> | string | null
    createdByName?: StringNullableFilter<"Expense"> | string | null
    isRecurring?: BoolFilter<"Expense"> | boolean
    recurringType?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    lastSynced?: DateTimeNullableFilter<"Expense"> | Date | string | null
    needsSync?: BoolFilter<"Expense"> | boolean
    category?: XOR<ExpenseCategoryNullableScalarRelationFilter, ExpenseCategoryWhereInput> | null
  }, "id" | "syncId">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    company?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    description?: SortOrder
    amount?: SortOrder
    expenseDate?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    vendor?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    localReceiptPath?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdByName?: SortOrderInput | SortOrder
    isRecurring?: SortOrder
    recurringType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrderInput | SortOrder
    lastSynced?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Expense"> | string
    company?: StringWithAggregatesFilter<"Expense"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    description?: StringWithAggregatesFilter<"Expense"> | string
    amount?: FloatWithAggregatesFilter<"Expense"> | number
    expenseDate?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    paymentMethod?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    reference?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    vendor?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    localReceiptPath?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    createdByName?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    isRecurring?: BoolWithAggregatesFilter<"Expense"> | boolean
    recurringType?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"Expense"> | string | null
    lastSynced?: DateTimeNullableWithAggregatesFilter<"Expense"> | Date | string | null
    needsSync?: BoolWithAggregatesFilter<"Expense"> | boolean
  }

  export type TreasuryMonthWhereInput = {
    AND?: TreasuryMonthWhereInput | TreasuryMonthWhereInput[]
    OR?: TreasuryMonthWhereInput[]
    NOT?: TreasuryMonthWhereInput | TreasuryMonthWhereInput[]
    id?: StringFilter<"TreasuryMonth"> | string
    company?: StringFilter<"TreasuryMonth"> | string
    year?: IntFilter<"TreasuryMonth"> | number
    month?: IntFilter<"TreasuryMonth"> | number
    totalIncome?: FloatFilter<"TreasuryMonth"> | number
    totalExpenses?: FloatFilter<"TreasuryMonth"> | number
    balance?: FloatFilter<"TreasuryMonth"> | number
    expensesByCategory?: StringNullableFilter<"TreasuryMonth"> | string | null
    lastUpdated?: DateTimeFilter<"TreasuryMonth"> | Date | string
    syncId?: StringNullableFilter<"TreasuryMonth"> | string | null
    needsSync?: BoolFilter<"TreasuryMonth"> | boolean
  }

  export type TreasuryMonthOrderByWithRelationInput = {
    id?: SortOrder
    company?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    balance?: SortOrder
    expensesByCategory?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
  }

  export type TreasuryMonthWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    syncId?: string
    company_year_month?: TreasuryMonthCompanyYearMonthCompoundUniqueInput
    AND?: TreasuryMonthWhereInput | TreasuryMonthWhereInput[]
    OR?: TreasuryMonthWhereInput[]
    NOT?: TreasuryMonthWhereInput | TreasuryMonthWhereInput[]
    company?: StringFilter<"TreasuryMonth"> | string
    year?: IntFilter<"TreasuryMonth"> | number
    month?: IntFilter<"TreasuryMonth"> | number
    totalIncome?: FloatFilter<"TreasuryMonth"> | number
    totalExpenses?: FloatFilter<"TreasuryMonth"> | number
    balance?: FloatFilter<"TreasuryMonth"> | number
    expensesByCategory?: StringNullableFilter<"TreasuryMonth"> | string | null
    lastUpdated?: DateTimeFilter<"TreasuryMonth"> | Date | string
    needsSync?: BoolFilter<"TreasuryMonth"> | boolean
  }, "id" | "syncId" | "company_year_month">

  export type TreasuryMonthOrderByWithAggregationInput = {
    id?: SortOrder
    company?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    balance?: SortOrder
    expensesByCategory?: SortOrderInput | SortOrder
    lastUpdated?: SortOrder
    syncId?: SortOrderInput | SortOrder
    needsSync?: SortOrder
    _count?: TreasuryMonthCountOrderByAggregateInput
    _avg?: TreasuryMonthAvgOrderByAggregateInput
    _max?: TreasuryMonthMaxOrderByAggregateInput
    _min?: TreasuryMonthMinOrderByAggregateInput
    _sum?: TreasuryMonthSumOrderByAggregateInput
  }

  export type TreasuryMonthScalarWhereWithAggregatesInput = {
    AND?: TreasuryMonthScalarWhereWithAggregatesInput | TreasuryMonthScalarWhereWithAggregatesInput[]
    OR?: TreasuryMonthScalarWhereWithAggregatesInput[]
    NOT?: TreasuryMonthScalarWhereWithAggregatesInput | TreasuryMonthScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TreasuryMonth"> | string
    company?: StringWithAggregatesFilter<"TreasuryMonth"> | string
    year?: IntWithAggregatesFilter<"TreasuryMonth"> | number
    month?: IntWithAggregatesFilter<"TreasuryMonth"> | number
    totalIncome?: FloatWithAggregatesFilter<"TreasuryMonth"> | number
    totalExpenses?: FloatWithAggregatesFilter<"TreasuryMonth"> | number
    balance?: FloatWithAggregatesFilter<"TreasuryMonth"> | number
    expensesByCategory?: StringNullableWithAggregatesFilter<"TreasuryMonth"> | string | null
    lastUpdated?: DateTimeWithAggregatesFilter<"TreasuryMonth"> | Date | string
    syncId?: StringNullableWithAggregatesFilter<"TreasuryMonth"> | string | null
    needsSync?: BoolWithAggregatesFilter<"TreasuryMonth"> | boolean
  }

  export type SyncQueueWhereInput = {
    AND?: SyncQueueWhereInput | SyncQueueWhereInput[]
    OR?: SyncQueueWhereInput[]
    NOT?: SyncQueueWhereInput | SyncQueueWhereInput[]
    id?: IntFilter<"SyncQueue"> | number
    tableName?: StringFilter<"SyncQueue"> | string
    recordId?: StringFilter<"SyncQueue"> | string
    action?: StringFilter<"SyncQueue"> | string
    data?: StringFilter<"SyncQueue"> | string
    createdAt?: DateTimeFilter<"SyncQueue"> | Date | string
    syncedAt?: DateTimeNullableFilter<"SyncQueue"> | Date | string | null
    error?: StringNullableFilter<"SyncQueue"> | string | null
    retries?: IntFilter<"SyncQueue"> | number
  }

  export type SyncQueueOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    retries?: SortOrder
  }

  export type SyncQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SyncQueueWhereInput | SyncQueueWhereInput[]
    OR?: SyncQueueWhereInput[]
    NOT?: SyncQueueWhereInput | SyncQueueWhereInput[]
    tableName?: StringFilter<"SyncQueue"> | string
    recordId?: StringFilter<"SyncQueue"> | string
    action?: StringFilter<"SyncQueue"> | string
    data?: StringFilter<"SyncQueue"> | string
    createdAt?: DateTimeFilter<"SyncQueue"> | Date | string
    syncedAt?: DateTimeNullableFilter<"SyncQueue"> | Date | string | null
    error?: StringNullableFilter<"SyncQueue"> | string | null
    retries?: IntFilter<"SyncQueue"> | number
  }, "id">

  export type SyncQueueOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    syncedAt?: SortOrderInput | SortOrder
    error?: SortOrderInput | SortOrder
    retries?: SortOrder
    _count?: SyncQueueCountOrderByAggregateInput
    _avg?: SyncQueueAvgOrderByAggregateInput
    _max?: SyncQueueMaxOrderByAggregateInput
    _min?: SyncQueueMinOrderByAggregateInput
    _sum?: SyncQueueSumOrderByAggregateInput
  }

  export type SyncQueueScalarWhereWithAggregatesInput = {
    AND?: SyncQueueScalarWhereWithAggregatesInput | SyncQueueScalarWhereWithAggregatesInput[]
    OR?: SyncQueueScalarWhereWithAggregatesInput[]
    NOT?: SyncQueueScalarWhereWithAggregatesInput | SyncQueueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SyncQueue"> | number
    tableName?: StringWithAggregatesFilter<"SyncQueue"> | string
    recordId?: StringWithAggregatesFilter<"SyncQueue"> | string
    action?: StringWithAggregatesFilter<"SyncQueue"> | string
    data?: StringWithAggregatesFilter<"SyncQueue"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SyncQueue"> | Date | string
    syncedAt?: DateTimeNullableWithAggregatesFilter<"SyncQueue"> | Date | string | null
    error?: StringNullableWithAggregatesFilter<"SyncQueue"> | string | null
    retries?: IntWithAggregatesFilter<"SyncQueue"> | number
  }

  export type SyncStatusWhereInput = {
    AND?: SyncStatusWhereInput | SyncStatusWhereInput[]
    OR?: SyncStatusWhereInput[]
    NOT?: SyncStatusWhereInput | SyncStatusWhereInput[]
    id?: IntFilter<"SyncStatus"> | number
    lastSyncAt?: DateTimeNullableFilter<"SyncStatus"> | Date | string | null
    lastSyncSuccess?: BoolFilter<"SyncStatus"> | boolean
    pendingChanges?: IntFilter<"SyncStatus"> | number
    serverUrl?: StringNullableFilter<"SyncStatus"> | string | null
  }

  export type SyncStatusOrderByWithRelationInput = {
    id?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    lastSyncSuccess?: SortOrder
    pendingChanges?: SortOrder
    serverUrl?: SortOrderInput | SortOrder
  }

  export type SyncStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SyncStatusWhereInput | SyncStatusWhereInput[]
    OR?: SyncStatusWhereInput[]
    NOT?: SyncStatusWhereInput | SyncStatusWhereInput[]
    lastSyncAt?: DateTimeNullableFilter<"SyncStatus"> | Date | string | null
    lastSyncSuccess?: BoolFilter<"SyncStatus"> | boolean
    pendingChanges?: IntFilter<"SyncStatus"> | number
    serverUrl?: StringNullableFilter<"SyncStatus"> | string | null
  }, "id">

  export type SyncStatusOrderByWithAggregationInput = {
    id?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    lastSyncSuccess?: SortOrder
    pendingChanges?: SortOrder
    serverUrl?: SortOrderInput | SortOrder
    _count?: SyncStatusCountOrderByAggregateInput
    _avg?: SyncStatusAvgOrderByAggregateInput
    _max?: SyncStatusMaxOrderByAggregateInput
    _min?: SyncStatusMinOrderByAggregateInput
    _sum?: SyncStatusSumOrderByAggregateInput
  }

  export type SyncStatusScalarWhereWithAggregatesInput = {
    AND?: SyncStatusScalarWhereWithAggregatesInput | SyncStatusScalarWhereWithAggregatesInput[]
    OR?: SyncStatusScalarWhereWithAggregatesInput[]
    NOT?: SyncStatusScalarWhereWithAggregatesInput | SyncStatusScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SyncStatus"> | number
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"SyncStatus"> | Date | string | null
    lastSyncSuccess?: BoolWithAggregatesFilter<"SyncStatus"> | boolean
    pendingChanges?: IntWithAggregatesFilter<"SyncStatus"> | number
    serverUrl?: StringNullableWithAggregatesFilter<"SyncStatus"> | string | null
  }

  export type OrganizationCreateInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserCreateNestedManyWithoutOrganizationInput
    messages?: MessageCreateNestedManyWithoutOrganizationInput
    tasks?: TaskCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionCreateNestedManyWithoutOrganizationInput
    needs?: NeedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput
    tasks?: TaskUncheckedCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionUncheckedCreateNestedManyWithoutOrganizationInput
    needs?: NeedUncheckedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUncheckedUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUncheckedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationCreateManyInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
  }

  export type OrganizationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OrganizationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserCreateInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateInput = {
    kind?: string
    channel?: string | null
    content: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutMessagesInput
    user?: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: number
    organizationId: number
    userId?: number | null
    kind?: string
    channel?: string | null
    content: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type MessageUpdateInput = {
    kind?: StringFieldUpdateOperationsInput | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutMessagesNestedInput
    user?: UserUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageCreateManyInput = {
    id?: number
    organizationId: number
    userId?: number | null
    kind?: string
    channel?: string | null
    content: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type MessageUpdateManyMutationInput = {
    kind?: StringFieldUpdateOperationsInput | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskCreateInput = {
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutTasksInput
    user?: UserCreateNestedOneWithoutTasksInput
    runs?: TaskRunCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateInput = {
    id?: number
    organizationId: number
    userId?: number | null
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    runs?: TaskRunUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutTasksNestedInput
    user?: UserUpdateOneWithoutTasksNestedInput
    runs?: TaskRunUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    runs?: TaskRunUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskCreateManyInput = {
    id?: number
    organizationId: number
    userId?: number | null
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type TaskUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskRunCreateInput = {
    runType?: string
    result?: string
    message?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    task: TaskCreateNestedOneWithoutRunsInput
  }

  export type TaskRunUncheckedCreateInput = {
    id?: number
    taskId: number
    runType?: string
    result?: string
    message?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type TaskRunUpdateInput = {
    runType?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    task?: TaskUpdateOneRequiredWithoutRunsNestedInput
  }

  export type TaskRunUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    runType?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskRunCreateManyInput = {
    id?: number
    taskId: number
    runType?: string
    result?: string
    message?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type TaskRunUpdateManyMutationInput = {
    runType?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskRunUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taskId?: IntFieldUpdateOperationsInput | number
    runType?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityLogCreateInput = {
    subjectType: string
    subjectId?: number | null
    action: string
    detail?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutActivityLogsInput
    user?: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: number
    organizationId: number
    userId?: number | null
    subjectType: string
    subjectId?: number | null
    action: string
    detail?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type ActivityLogUpdateInput = {
    subjectType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutActivityLogsNestedInput
    user?: UserUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    subjectType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityLogCreateManyInput = {
    id?: number
    organizationId: number
    userId?: number | null
    subjectType: string
    subjectId?: number | null
    action: string
    detail?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type ActivityLogUpdateManyMutationInput = {
    subjectType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    subjectType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequisitionCreateInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    requester?: UserCreateNestedOneWithoutRequisitionsRequestedInput
    organization: OrganizationCreateNestedOneWithoutRequisitionsInput
    workflow?: WorkflowStepCreateNestedManyWithoutRequisitionInput
  }

  export type RequisitionUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    requesterId?: number | null
    organizationId: number
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    workflow?: WorkflowStepUncheckedCreateNestedManyWithoutRequisitionInput
  }

  export type RequisitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    requester?: UserUpdateOneWithoutRequisitionsRequestedNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutRequisitionsNestedInput
    workflow?: WorkflowStepUpdateManyWithoutRequisitionNestedInput
  }

  export type RequisitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    workflow?: WorkflowStepUncheckedUpdateManyWithoutRequisitionNestedInput
  }

  export type RequisitionCreateManyInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    requesterId?: number | null
    organizationId: number
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type RequisitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequisitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepCreateInput = {
    id?: string
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
    requisition: RequisitionCreateNestedOneWithoutWorkflowInput
    reviewer?: UserCreateNestedOneWithoutWorkflowStepsReviewedInput
  }

  export type WorkflowStepUncheckedCreateInput = {
    id?: string
    requisitionId: string
    reviewerId?: number | null
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type WorkflowStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    requisition?: RequisitionUpdateOneRequiredWithoutWorkflowNestedInput
    reviewer?: UserUpdateOneWithoutWorkflowStepsReviewedNestedInput
  }

  export type WorkflowStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requisitionId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepCreateManyInput = {
    id?: string
    requisitionId: string
    reviewerId?: number | null
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type WorkflowStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    requisitionId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MeetingCreateInput = {
    id?: string
    title: string
    notes?: string
    participants?: string | null
    status?: string
    extractedActions?: string | null
    tasksCreated?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutMeetingsInput
    creator?: UserCreateNestedOneWithoutMeetingsCreatedInput
  }

  export type MeetingUncheckedCreateInput = {
    id?: string
    organizationId: number
    creatorId?: number | null
    title: string
    notes?: string
    participants?: string | null
    status?: string
    extractedActions?: string | null
    tasksCreated?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type MeetingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    participants?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    extractedActions?: NullableStringFieldUpdateOperationsInput | string | null
    tasksCreated?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutMeetingsNestedInput
    creator?: UserUpdateOneWithoutMeetingsCreatedNestedInput
  }

  export type MeetingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    participants?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    extractedActions?: NullableStringFieldUpdateOperationsInput | string | null
    tasksCreated?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MeetingCreateManyInput = {
    id?: string
    organizationId: number
    creatorId?: number | null
    title: string
    notes?: string
    participants?: string | null
    status?: string
    extractedActions?: string | null
    tasksCreated?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type MeetingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    participants?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    extractedActions?: NullableStringFieldUpdateOperationsInput | string | null
    tasksCreated?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MeetingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    participants?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    extractedActions?: NullableStringFieldUpdateOperationsInput | string | null
    tasksCreated?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailAccountCreateInput = {
    id?: string
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutEmailAccountsInput
    owner?: UserCreateNestedOneWithoutEmailAccountsInput
    selections?: EmailActiveSelectionCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountUncheckedCreateInput = {
    id?: string
    organizationId: number
    userId?: number | null
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    selections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutEmailAccountsNestedInput
    owner?: UserUpdateOneWithoutEmailAccountsNestedInput
    selections?: EmailActiveSelectionUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    selections?: EmailActiveSelectionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountCreateManyInput = {
    id?: string
    organizationId: number
    userId?: number | null
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type EmailAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailActiveSelectionCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutEmailSelectionsInput
    user: UserCreateNestedOneWithoutEmailSelectionsInput
    account: EmailAccountCreateNestedOneWithoutSelectionsInput
  }

  export type EmailActiveSelectionUncheckedCreateInput = {
    id?: number
    organizationId: number
    userId: number
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailActiveSelectionUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutEmailSelectionsNestedInput
    user?: UserUpdateOneRequiredWithoutEmailSelectionsNestedInput
    account?: EmailAccountUpdateOneRequiredWithoutSelectionsNestedInput
  }

  export type EmailActiveSelectionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailActiveSelectionCreateManyInput = {
    id?: number
    organizationId: number
    userId: number
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailActiveSelectionUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailActiveSelectionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NeedCreateInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    requester?: UserCreateNestedOneWithoutNeedsRequestedInput
    organization: OrganizationCreateNestedOneWithoutNeedsInput
    workflow?: NeedWorkflowStepCreateNestedManyWithoutNeedInput
    attachments?: NeedAttachmentCreateNestedManyWithoutNeedInput
  }

  export type NeedUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterId?: number | null
    requesterName?: string | null
    organizationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    workflow?: NeedWorkflowStepUncheckedCreateNestedManyWithoutNeedInput
    attachments?: NeedAttachmentUncheckedCreateNestedManyWithoutNeedInput
  }

  export type NeedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    requester?: UserUpdateOneWithoutNeedsRequestedNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutNeedsNestedInput
    workflow?: NeedWorkflowStepUpdateManyWithoutNeedNestedInput
    attachments?: NeedAttachmentUpdateManyWithoutNeedNestedInput
  }

  export type NeedUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NeedWorkflowStepUncheckedUpdateManyWithoutNeedNestedInput
    attachments?: NeedAttachmentUncheckedUpdateManyWithoutNeedNestedInput
  }

  export type NeedCreateManyInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterId?: number | null
    requesterName?: string | null
    organizationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type NeedUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedWorkflowStepCreateInput = {
    id?: string
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
    need: NeedCreateNestedOneWithoutWorkflowInput
    reviewer?: UserCreateNestedOneWithoutNeedWorkflowStepsReviewedInput
  }

  export type NeedWorkflowStepUncheckedCreateInput = {
    id?: string
    needId: string
    reviewerId?: number | null
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedWorkflowStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    need?: NeedUpdateOneRequiredWithoutWorkflowNestedInput
    reviewer?: UserUpdateOneWithoutNeedWorkflowStepsReviewedNestedInput
  }

  export type NeedWorkflowStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    needId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedWorkflowStepCreateManyInput = {
    id?: string
    needId: string
    reviewerId?: number | null
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedWorkflowStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedWorkflowStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    needId?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedAttachmentCreateInput = {
    id?: string
    fileName: string
    fileSize: number
    fileType: string
    uploadedBy: string
    url: string
    localPath?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    need: NeedCreateNestedOneWithoutAttachmentsInput
  }

  export type NeedAttachmentUncheckedCreateInput = {
    id?: string
    needId: string
    fileName: string
    fileSize: number
    fileType: string
    uploadedBy: string
    url: string
    localPath?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    localPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    need?: NeedUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type NeedAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    needId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    localPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedAttachmentCreateManyInput = {
    id?: string
    needId: string
    fileName: string
    fileSize: number
    fileType: string
    uploadedBy: string
    url: string
    localPath?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    localPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    needId?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    localPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceClientCreateInput = {
    id?: string
    company: string
    companyName: string
    contactName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    taxNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    invoices?: InvoiceCreateNestedManyWithoutClientInput
  }

  export type InvoiceClientUncheckedCreateInput = {
    id?: string
    company: string
    companyName: string
    contactName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    taxNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
  }

  export type InvoiceClientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
  }

  export type InvoiceClientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
  }

  export type InvoiceClientCreateManyInput = {
    id?: string
    company: string
    companyName: string
    contactName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    taxNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type InvoiceClientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceClientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceCreateInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    client: InvoiceClientCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    sections?: InvoiceSectionCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientId: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    sections?: InvoiceSectionUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    client?: InvoiceClientUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    sections?: InvoiceSectionUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    sections?: InvoiceSectionUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientId: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineCreateInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice?: number
    total?: number
    chargesTTC?: number | null
    squareMeters?: number | null
    days?: number | null
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    invoice: InvoiceCreateNestedOneWithoutLinesInput
  }

  export type InvoiceLineUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    quantity?: number
    unitPrice?: number
    total?: number
    chargesTTC?: number | null
    squareMeters?: number | null
    days?: number | null
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    chargesTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
  }

  export type InvoiceLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    chargesTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    quantity?: number
    unitPrice?: number
    total?: number
    chargesTTC?: number | null
    squareMeters?: number | null
    days?: number | null
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    chargesTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    chargesTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceSectionCreateInput = {
    id?: string
    title: string
    subtotal?: number
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    invoice: InvoiceCreateNestedOneWithoutSectionsInput
    lines?: InvoiceSectionLineCreateNestedManyWithoutSectionInput
  }

  export type InvoiceSectionUncheckedCreateInput = {
    id?: string
    invoiceId: string
    title: string
    subtotal?: number
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    lines?: InvoiceSectionLineUncheckedCreateNestedManyWithoutSectionInput
  }

  export type InvoiceSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    invoice?: InvoiceUpdateOneRequiredWithoutSectionsNestedInput
    lines?: InvoiceSectionLineUpdateManyWithoutSectionNestedInput
  }

  export type InvoiceSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceSectionLineUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type InvoiceSectionCreateManyInput = {
    id?: string
    invoiceId: string
    title: string
    subtotal?: number
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceSectionLineCreateInput = {
    id?: string
    description: string
    quantity?: number
    squareMeters?: number | null
    days?: number | null
    unitPrice?: number
    total?: number
    daysImpactPrice?: boolean
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    section: InvoiceSectionCreateNestedOneWithoutLinesInput
  }

  export type InvoiceSectionLineUncheckedCreateInput = {
    id?: string
    sectionId: string
    description: string
    quantity?: number
    squareMeters?: number | null
    days?: number | null
    unitPrice?: number
    total?: number
    daysImpactPrice?: boolean
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceSectionLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    daysImpactPrice?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    section?: InvoiceSectionUpdateOneRequiredWithoutLinesNestedInput
  }

  export type InvoiceSectionLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    daysImpactPrice?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceSectionLineCreateManyInput = {
    id?: string
    sectionId: string
    description: string
    quantity?: number
    squareMeters?: number | null
    days?: number | null
    unitPrice?: number
    total?: number
    daysImpactPrice?: boolean
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceSectionLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    daysImpactPrice?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceSectionLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    daysImpactPrice?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoicePaymentCreateInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type InvoicePaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoicePaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type InvoicePaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoicePaymentCreateManyInput = {
    id?: string
    invoiceId: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoicePaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoicePaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExpenseCategoryCreateInput = {
    id?: string
    company: string
    name: string
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    expenses?: ExpenseCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUncheckedCreateInput = {
    id?: string
    company: string
    name: string
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    expenses?: ExpenseUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type ExpenseCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    expenses?: ExpenseUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    expenses?: ExpenseUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type ExpenseCategoryCreateManyInput = {
    id?: string
    company: string
    name: string
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type ExpenseCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExpenseCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExpenseCreateInput = {
    id?: string
    company: string
    description: string
    amount: number
    expenseDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    vendor?: string | null
    receiptUrl?: string | null
    localReceiptPath?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    isRecurring?: boolean
    recurringType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    category?: ExpenseCategoryCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: string
    company: string
    categoryId?: string | null
    description: string
    amount: number
    expenseDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    vendor?: string | null
    receiptUrl?: string | null
    localReceiptPath?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    isRecurring?: boolean
    recurringType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type ExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localReceiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    category?: ExpenseCategoryUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localReceiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExpenseCreateManyInput = {
    id?: string
    company: string
    categoryId?: string | null
    description: string
    amount: number
    expenseDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    vendor?: string | null
    receiptUrl?: string | null
    localReceiptPath?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    isRecurring?: boolean
    recurringType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type ExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localReceiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localReceiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreasuryMonthCreateInput = {
    id?: string
    company: string
    year: number
    month: number
    totalIncome?: number
    totalExpenses?: number
    balance?: number
    expensesByCategory?: string | null
    lastUpdated?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type TreasuryMonthUncheckedCreateInput = {
    id?: string
    company: string
    year: number
    month: number
    totalIncome?: number
    totalExpenses?: number
    balance?: number
    expensesByCategory?: string | null
    lastUpdated?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type TreasuryMonthUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    expensesByCategory?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreasuryMonthUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    expensesByCategory?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreasuryMonthCreateManyInput = {
    id?: string
    company: string
    year: number
    month: number
    totalIncome?: number
    totalExpenses?: number
    balance?: number
    expensesByCategory?: string | null
    lastUpdated?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type TreasuryMonthUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    expensesByCategory?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TreasuryMonthUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    month?: IntFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    balance?: FloatFieldUpdateOperationsInput | number
    expensesByCategory?: NullableStringFieldUpdateOperationsInput | string | null
    lastUpdated?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SyncQueueCreateInput = {
    tableName: string
    recordId: string
    action: string
    data: string
    createdAt?: Date | string
    syncedAt?: Date | string | null
    error?: string | null
    retries?: number
  }

  export type SyncQueueUncheckedCreateInput = {
    id?: number
    tableName: string
    recordId: string
    action: string
    data: string
    createdAt?: Date | string
    syncedAt?: Date | string | null
    error?: string | null
    retries?: number
  }

  export type SyncQueueUpdateInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
  }

  export type SyncQueueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
  }

  export type SyncQueueCreateManyInput = {
    id?: number
    tableName: string
    recordId: string
    action: string
    data: string
    createdAt?: Date | string
    syncedAt?: Date | string | null
    error?: string | null
    retries?: number
  }

  export type SyncQueueUpdateManyMutationInput = {
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
  }

  export type SyncQueueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    retries?: IntFieldUpdateOperationsInput | number
  }

  export type SyncStatusCreateInput = {
    lastSyncAt?: Date | string | null
    lastSyncSuccess?: boolean
    pendingChanges?: number
    serverUrl?: string | null
  }

  export type SyncStatusUncheckedCreateInput = {
    id?: number
    lastSyncAt?: Date | string | null
    lastSyncSuccess?: boolean
    pendingChanges?: number
    serverUrl?: string | null
  }

  export type SyncStatusUpdateInput = {
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncSuccess?: BoolFieldUpdateOperationsInput | boolean
    pendingChanges?: IntFieldUpdateOperationsInput | number
    serverUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncStatusUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncSuccess?: BoolFieldUpdateOperationsInput | boolean
    pendingChanges?: IntFieldUpdateOperationsInput | number
    serverUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncStatusCreateManyInput = {
    id?: number
    lastSyncAt?: Date | string | null
    lastSyncSuccess?: boolean
    pendingChanges?: number
    serverUrl?: string | null
  }

  export type SyncStatusUpdateManyMutationInput = {
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncSuccess?: BoolFieldUpdateOperationsInput | boolean
    pendingChanges?: IntFieldUpdateOperationsInput | number
    serverUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SyncStatusUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSyncSuccess?: BoolFieldUpdateOperationsInput | boolean
    pendingChanges?: IntFieldUpdateOperationsInput | number
    serverUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type RequisitionListRelationFilter = {
    every?: RequisitionWhereInput
    some?: RequisitionWhereInput
    none?: RequisitionWhereInput
  }

  export type NeedListRelationFilter = {
    every?: NeedWhereInput
    some?: NeedWhereInput
    none?: NeedWhereInput
  }

  export type MeetingListRelationFilter = {
    every?: MeetingWhereInput
    some?: MeetingWhereInput
    none?: MeetingWhereInput
  }

  export type EmailAccountListRelationFilter = {
    every?: EmailAccountWhereInput
    some?: EmailAccountWhereInput
    none?: EmailAccountWhereInput
  }

  export type EmailActiveSelectionListRelationFilter = {
    every?: EmailActiveSelectionWhereInput
    some?: EmailActiveSelectionWhereInput
    none?: EmailActiveSelectionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RequisitionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NeedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailActiveSelectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganizationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
  }

  export type OrganizationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrganizationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
  }

  export type OrganizationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
  }

  export type OrganizationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type OrganizationScalarRelationFilter = {
    is?: OrganizationWhereInput
    isNot?: OrganizationWhereInput
  }

  export type WorkflowStepListRelationFilter = {
    every?: WorkflowStepWhereInput
    some?: WorkflowStepWhereInput
    none?: WorkflowStepWhereInput
  }

  export type NeedWorkflowStepListRelationFilter = {
    every?: NeedWorkflowStepWhereInput
    some?: NeedWorkflowStepWhereInput
    none?: NeedWorkflowStepWhereInput
  }

  export type WorkflowStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NeedWorkflowStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    externalId?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    name?: SortOrder
    pinHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    externalId?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    name?: SortOrder
    pinHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    externalId?: SortOrder
    email?: SortOrder
    displayName?: SortOrder
    name?: SortOrder
    pinHash?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    kind?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    kind?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    kind?: SortOrder
    channel?: SortOrder
    content?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type TaskRunListRelationFilter = {
    every?: TaskRunWhereInput
    some?: TaskRunWhereInput
    none?: TaskRunWhereInput
  }

  export type TaskRunOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type TaskAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    dueAt?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type TaskSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
  }

  export type TaskScalarRelationFilter = {
    is?: TaskWhereInput
    isNot?: TaskWhereInput
  }

  export type TaskRunCountOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    runType?: SortOrder
    result?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type TaskRunAvgOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
  }

  export type TaskRunMaxOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    runType?: SortOrder
    result?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type TaskRunMinOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
    runType?: SortOrder
    result?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type TaskRunSumOrderByAggregateInput = {
    id?: SortOrder
    taskId?: SortOrder
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    subjectType?: SortOrder
    subjectId?: SortOrder
    action?: SortOrder
    detail?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    subjectId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    subjectType?: SortOrder
    subjectId?: SortOrder
    action?: SortOrder
    detail?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    subjectType?: SortOrder
    subjectId?: SortOrder
    action?: SortOrder
    detail?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    subjectId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type RequisitionCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    justification?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    organizationId?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type RequisitionAvgOrderByAggregateInput = {
    budget?: SortOrder
    requesterId?: SortOrder
    organizationId?: SortOrder
  }

  export type RequisitionMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    justification?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    organizationId?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type RequisitionMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    justification?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    organizationId?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type RequisitionSumOrderByAggregateInput = {
    budget?: SortOrder
    requesterId?: SortOrder
    organizationId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type RequisitionScalarRelationFilter = {
    is?: RequisitionWhereInput
    isNot?: RequisitionWhereInput
  }

  export type WorkflowStepCountOrderByAggregateInput = {
    id?: SortOrder
    requisitionId?: SortOrder
    reviewerId?: SortOrder
    reviewerName?: SortOrder
    reviewerLevel?: SortOrder
    action?: SortOrder
    isRequired?: SortOrder
    isCompleted?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type WorkflowStepAvgOrderByAggregateInput = {
    reviewerId?: SortOrder
    reviewerLevel?: SortOrder
  }

  export type WorkflowStepMaxOrderByAggregateInput = {
    id?: SortOrder
    requisitionId?: SortOrder
    reviewerId?: SortOrder
    reviewerName?: SortOrder
    reviewerLevel?: SortOrder
    action?: SortOrder
    isRequired?: SortOrder
    isCompleted?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type WorkflowStepMinOrderByAggregateInput = {
    id?: SortOrder
    requisitionId?: SortOrder
    reviewerId?: SortOrder
    reviewerName?: SortOrder
    reviewerLevel?: SortOrder
    action?: SortOrder
    isRequired?: SortOrder
    isCompleted?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type WorkflowStepSumOrderByAggregateInput = {
    reviewerId?: SortOrder
    reviewerLevel?: SortOrder
  }

  export type MeetingCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    participants?: SortOrder
    status?: SortOrder
    extractedActions?: SortOrder
    tasksCreated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type MeetingAvgOrderByAggregateInput = {
    organizationId?: SortOrder
    creatorId?: SortOrder
  }

  export type MeetingMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    participants?: SortOrder
    status?: SortOrder
    extractedActions?: SortOrder
    tasksCreated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type MeetingMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    creatorId?: SortOrder
    title?: SortOrder
    notes?: SortOrder
    participants?: SortOrder
    status?: SortOrder
    extractedActions?: SortOrder
    tasksCreated?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type MeetingSumOrderByAggregateInput = {
    organizationId?: SortOrder
    creatorId?: SortOrder
  }

  export type EmailAccountCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    providerId?: SortOrder
    providerName?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    isConnected?: SortOrder
    unreadCount?: SortOrder
    connectedAt?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type EmailAccountAvgOrderByAggregateInput = {
    organizationId?: SortOrder
    userId?: SortOrder
    unreadCount?: SortOrder
  }

  export type EmailAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    providerId?: SortOrder
    providerName?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    isConnected?: SortOrder
    unreadCount?: SortOrder
    connectedAt?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type EmailAccountMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    providerId?: SortOrder
    providerName?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    isConnected?: SortOrder
    unreadCount?: SortOrder
    connectedAt?: SortOrder
    lastSync?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type EmailAccountSumOrderByAggregateInput = {
    organizationId?: SortOrder
    userId?: SortOrder
    unreadCount?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type EmailAccountScalarRelationFilter = {
    is?: EmailAccountWhereInput
    isNot?: EmailAccountWhereInput
  }

  export type EmailActiveSelectionOrganizationIdUserIdCompoundUniqueInput = {
    organizationId: number
    userId: number
  }

  export type EmailActiveSelectionCountOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailActiveSelectionAvgOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
  }

  export type EmailActiveSelectionMaxOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailActiveSelectionMinOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
    accountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailActiveSelectionSumOrderByAggregateInput = {
    id?: SortOrder
    organizationId?: SortOrder
    userId?: SortOrder
  }

  export type NeedAttachmentListRelationFilter = {
    every?: NeedAttachmentWhereInput
    some?: NeedAttachmentWhereInput
    none?: NeedAttachmentWhereInput
  }

  export type NeedAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NeedCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    justification?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    requesterName?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type NeedAvgOrderByAggregateInput = {
    budget?: SortOrder
    requesterId?: SortOrder
    organizationId?: SortOrder
  }

  export type NeedMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    justification?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    requesterName?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type NeedMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    budget?: SortOrder
    justification?: SortOrder
    status?: SortOrder
    requesterId?: SortOrder
    requesterName?: SortOrder
    organizationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type NeedSumOrderByAggregateInput = {
    budget?: SortOrder
    requesterId?: SortOrder
    organizationId?: SortOrder
  }

  export type NeedScalarRelationFilter = {
    is?: NeedWhereInput
    isNot?: NeedWhereInput
  }

  export type NeedWorkflowStepCountOrderByAggregateInput = {
    id?: SortOrder
    needId?: SortOrder
    reviewerId?: SortOrder
    reviewerName?: SortOrder
    reviewerLevel?: SortOrder
    action?: SortOrder
    isRequired?: SortOrder
    isCompleted?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type NeedWorkflowStepAvgOrderByAggregateInput = {
    reviewerId?: SortOrder
    reviewerLevel?: SortOrder
  }

  export type NeedWorkflowStepMaxOrderByAggregateInput = {
    id?: SortOrder
    needId?: SortOrder
    reviewerId?: SortOrder
    reviewerName?: SortOrder
    reviewerLevel?: SortOrder
    action?: SortOrder
    isRequired?: SortOrder
    isCompleted?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type NeedWorkflowStepMinOrderByAggregateInput = {
    id?: SortOrder
    needId?: SortOrder
    reviewerId?: SortOrder
    reviewerName?: SortOrder
    reviewerLevel?: SortOrder
    action?: SortOrder
    isRequired?: SortOrder
    isCompleted?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type NeedWorkflowStepSumOrderByAggregateInput = {
    reviewerId?: SortOrder
    reviewerLevel?: SortOrder
  }

  export type NeedAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    needId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    uploadedBy?: SortOrder
    url?: SortOrder
    localPath?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type NeedAttachmentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type NeedAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    needId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    uploadedBy?: SortOrder
    url?: SortOrder
    localPath?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type NeedAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    needId?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    fileType?: SortOrder
    uploadedBy?: SortOrder
    url?: SortOrder
    localPath?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type NeedAttachmentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceClientCountOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    taxNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceClientMaxOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    taxNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceClientMinOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    companyName?: SortOrder
    contactName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    taxNumber?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type InvoiceClientScalarRelationFilter = {
    is?: InvoiceClientWhereInput
    isNot?: InvoiceClientWhereInput
  }

  export type InvoiceLineListRelationFilter = {
    every?: InvoiceLineWhereInput
    some?: InvoiceLineWhereInput
    none?: InvoiceLineWhereInput
  }

  export type InvoiceSectionListRelationFilter = {
    every?: InvoiceSectionWhereInput
    some?: InvoiceSectionWhereInput
    none?: InvoiceSectionWhereInput
  }

  export type InvoicePaymentListRelationFilter = {
    every?: InvoicePaymentWhereInput
    some?: InvoicePaymentWhereInput
    none?: InvoicePaymentWhereInput
  }

  export type InvoiceLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoicePaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    template?: SortOrder
    company?: SortOrder
    clientId?: SortOrder
    clientSnapshot?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    serviceType?: SortOrder
    templateCode?: SortOrder
    placementTVAEnabled?: SortOrder
    chargesTTCMode?: SortOrder
    placementDeduction?: SortOrder
    enablePlacementDeduction?: SortOrder
    transfertDeduction?: SortOrder
    enableTransfertDeduction?: SortOrder
    projectDescription?: SortOrder
    projectName?: SortOrder
    managementFeeRate?: SortOrder
    commissionRate?: SortOrder
    acomptes?: SortOrder
    status?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    paidAt?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrder
    publicNotes?: SortOrder
    createdBy?: SortOrder
    createdByInitials?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    placementDeduction?: SortOrder
    transfertDeduction?: SortOrder
    managementFeeRate?: SortOrder
    commissionRate?: SortOrder
    paidAmount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    template?: SortOrder
    company?: SortOrder
    clientId?: SortOrder
    clientSnapshot?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    serviceType?: SortOrder
    templateCode?: SortOrder
    placementTVAEnabled?: SortOrder
    chargesTTCMode?: SortOrder
    placementDeduction?: SortOrder
    enablePlacementDeduction?: SortOrder
    transfertDeduction?: SortOrder
    enableTransfertDeduction?: SortOrder
    projectDescription?: SortOrder
    projectName?: SortOrder
    managementFeeRate?: SortOrder
    commissionRate?: SortOrder
    acomptes?: SortOrder
    status?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    paidAt?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrder
    publicNotes?: SortOrder
    createdBy?: SortOrder
    createdByInitials?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceNumber?: SortOrder
    template?: SortOrder
    company?: SortOrder
    clientId?: SortOrder
    clientSnapshot?: SortOrder
    issueDate?: SortOrder
    dueDate?: SortOrder
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    serviceType?: SortOrder
    templateCode?: SortOrder
    placementTVAEnabled?: SortOrder
    chargesTTCMode?: SortOrder
    placementDeduction?: SortOrder
    enablePlacementDeduction?: SortOrder
    transfertDeduction?: SortOrder
    enableTransfertDeduction?: SortOrder
    projectDescription?: SortOrder
    projectName?: SortOrder
    managementFeeRate?: SortOrder
    commissionRate?: SortOrder
    acomptes?: SortOrder
    status?: SortOrder
    paymentTerms?: SortOrder
    paymentMethod?: SortOrder
    paidAt?: SortOrder
    paidAmount?: SortOrder
    notes?: SortOrder
    publicNotes?: SortOrder
    createdBy?: SortOrder
    createdByInitials?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    subtotal?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    total?: SortOrder
    placementDeduction?: SortOrder
    transfertDeduction?: SortOrder
    managementFeeRate?: SortOrder
    commissionRate?: SortOrder
    paidAmount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceLineCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    chargesTTC?: SortOrder
    squareMeters?: SortOrder
    days?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceLineAvgOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    chargesTTC?: SortOrder
    squareMeters?: SortOrder
    days?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceLineMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    chargesTTC?: SortOrder
    squareMeters?: SortOrder
    days?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceLineMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    chargesTTC?: SortOrder
    squareMeters?: SortOrder
    days?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceLineSumOrderByAggregateInput = {
    quantity?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    chargesTTC?: SortOrder
    squareMeters?: SortOrder
    days?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceSectionLineListRelationFilter = {
    every?: InvoiceSectionLineWhereInput
    some?: InvoiceSectionLineWhereInput
    none?: InvoiceSectionLineWhereInput
  }

  export type InvoiceSectionLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceSectionCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    title?: SortOrder
    subtotal?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceSectionAvgOrderByAggregateInput = {
    subtotal?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    title?: SortOrder
    subtotal?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceSectionMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    title?: SortOrder
    subtotal?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceSectionSumOrderByAggregateInput = {
    subtotal?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceSectionScalarRelationFilter = {
    is?: InvoiceSectionWhereInput
    isNot?: InvoiceSectionWhereInput
  }

  export type InvoiceSectionLineCountOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    squareMeters?: SortOrder
    days?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    daysImpactPrice?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceSectionLineAvgOrderByAggregateInput = {
    quantity?: SortOrder
    squareMeters?: SortOrder
    days?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoiceSectionLineMaxOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    squareMeters?: SortOrder
    days?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    daysImpactPrice?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceSectionLineMinOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    description?: SortOrder
    quantity?: SortOrder
    squareMeters?: SortOrder
    days?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    daysImpactPrice?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoiceSectionLineSumOrderByAggregateInput = {
    quantity?: SortOrder
    squareMeters?: SortOrder
    days?: SortOrder
    unitPrice?: SortOrder
    total?: SortOrder
    sortOrder?: SortOrder
  }

  export type InvoicePaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoicePaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoicePaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoicePaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    amount?: SortOrder
    paymentDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type InvoicePaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExpenseCategoryCompanyNameCompoundUniqueInput = {
    company: string
    name: string
  }

  export type ExpenseCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    name?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type ExpenseCategoryAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ExpenseCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    name?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type ExpenseCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    name?: SortOrder
    color?: SortOrder
    icon?: SortOrder
    isActive?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type ExpenseCategorySumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ExpenseCategoryNullableScalarRelationFilter = {
    is?: ExpenseCategoryWhereInput | null
    isNot?: ExpenseCategoryWhereInput | null
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    expenseDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    vendor?: SortOrder
    receiptUrl?: SortOrder
    localReceiptPath?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdByName?: SortOrder
    isRecurring?: SortOrder
    recurringType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    expenseDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    vendor?: SortOrder
    receiptUrl?: SortOrder
    localReceiptPath?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdByName?: SortOrder
    isRecurring?: SortOrder
    recurringType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    categoryId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    expenseDate?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    vendor?: SortOrder
    receiptUrl?: SortOrder
    localReceiptPath?: SortOrder
    notes?: SortOrder
    createdBy?: SortOrder
    createdByName?: SortOrder
    isRecurring?: SortOrder
    recurringType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    syncId?: SortOrder
    lastSynced?: SortOrder
    needsSync?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TreasuryMonthCompanyYearMonthCompoundUniqueInput = {
    company: string
    year: number
    month: number
  }

  export type TreasuryMonthCountOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    balance?: SortOrder
    expensesByCategory?: SortOrder
    lastUpdated?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type TreasuryMonthAvgOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    balance?: SortOrder
  }

  export type TreasuryMonthMaxOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    balance?: SortOrder
    expensesByCategory?: SortOrder
    lastUpdated?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type TreasuryMonthMinOrderByAggregateInput = {
    id?: SortOrder
    company?: SortOrder
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    balance?: SortOrder
    expensesByCategory?: SortOrder
    lastUpdated?: SortOrder
    syncId?: SortOrder
    needsSync?: SortOrder
  }

  export type TreasuryMonthSumOrderByAggregateInput = {
    year?: SortOrder
    month?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    balance?: SortOrder
  }

  export type SyncQueueCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    syncedAt?: SortOrder
    error?: SortOrder
    retries?: SortOrder
  }

  export type SyncQueueAvgOrderByAggregateInput = {
    id?: SortOrder
    retries?: SortOrder
  }

  export type SyncQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    syncedAt?: SortOrder
    error?: SortOrder
    retries?: SortOrder
  }

  export type SyncQueueMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    action?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    syncedAt?: SortOrder
    error?: SortOrder
    retries?: SortOrder
  }

  export type SyncQueueSumOrderByAggregateInput = {
    id?: SortOrder
    retries?: SortOrder
  }

  export type SyncStatusCountOrderByAggregateInput = {
    id?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncSuccess?: SortOrder
    pendingChanges?: SortOrder
    serverUrl?: SortOrder
  }

  export type SyncStatusAvgOrderByAggregateInput = {
    id?: SortOrder
    pendingChanges?: SortOrder
  }

  export type SyncStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncSuccess?: SortOrder
    pendingChanges?: SortOrder
    serverUrl?: SortOrder
  }

  export type SyncStatusMinOrderByAggregateInput = {
    id?: SortOrder
    lastSyncAt?: SortOrder
    lastSyncSuccess?: SortOrder
    pendingChanges?: SortOrder
    serverUrl?: SortOrder
  }

  export type SyncStatusSumOrderByAggregateInput = {
    id?: SortOrder
    pendingChanges?: SortOrder
  }

  export type UserCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MessageCreateWithoutOrganizationInput, MessageUncheckedCreateWithoutOrganizationInput> | MessageCreateWithoutOrganizationInput[] | MessageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutOrganizationInput | MessageCreateOrConnectWithoutOrganizationInput[]
    createMany?: MessageCreateManyOrganizationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TaskCreateWithoutOrganizationInput, TaskUncheckedCreateWithoutOrganizationInput> | TaskCreateWithoutOrganizationInput[] | TaskUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutOrganizationInput | TaskCreateOrConnectWithoutOrganizationInput[]
    createMany?: TaskCreateManyOrganizationInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ActivityLogCreateWithoutOrganizationInput, ActivityLogUncheckedCreateWithoutOrganizationInput> | ActivityLogCreateWithoutOrganizationInput[] | ActivityLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOrganizationInput | ActivityLogCreateOrConnectWithoutOrganizationInput[]
    createMany?: ActivityLogCreateManyOrganizationInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type RequisitionCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<RequisitionCreateWithoutOrganizationInput, RequisitionUncheckedCreateWithoutOrganizationInput> | RequisitionCreateWithoutOrganizationInput[] | RequisitionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: RequisitionCreateOrConnectWithoutOrganizationInput | RequisitionCreateOrConnectWithoutOrganizationInput[]
    createMany?: RequisitionCreateManyOrganizationInputEnvelope
    connect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
  }

  export type NeedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NeedCreateWithoutOrganizationInput, NeedUncheckedCreateWithoutOrganizationInput> | NeedCreateWithoutOrganizationInput[] | NeedUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NeedCreateOrConnectWithoutOrganizationInput | NeedCreateOrConnectWithoutOrganizationInput[]
    createMany?: NeedCreateManyOrganizationInputEnvelope
    connect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MeetingCreateWithoutOrganizationInput, MeetingUncheckedCreateWithoutOrganizationInput> | MeetingCreateWithoutOrganizationInput[] | MeetingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutOrganizationInput | MeetingCreateOrConnectWithoutOrganizationInput[]
    createMany?: MeetingCreateManyOrganizationInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type EmailAccountCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EmailAccountCreateWithoutOrganizationInput, EmailAccountUncheckedCreateWithoutOrganizationInput> | EmailAccountCreateWithoutOrganizationInput[] | EmailAccountUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOrganizationInput | EmailAccountCreateOrConnectWithoutOrganizationInput[]
    createMany?: EmailAccountCreateManyOrganizationInputEnvelope
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
  }

  export type EmailActiveSelectionCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutOrganizationInput, EmailActiveSelectionUncheckedCreateWithoutOrganizationInput> | EmailActiveSelectionCreateWithoutOrganizationInput[] | EmailActiveSelectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutOrganizationInput | EmailActiveSelectionCreateOrConnectWithoutOrganizationInput[]
    createMany?: EmailActiveSelectionCreateManyOrganizationInputEnvelope
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MessageCreateWithoutOrganizationInput, MessageUncheckedCreateWithoutOrganizationInput> | MessageCreateWithoutOrganizationInput[] | MessageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutOrganizationInput | MessageCreateOrConnectWithoutOrganizationInput[]
    createMany?: MessageCreateManyOrganizationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<TaskCreateWithoutOrganizationInput, TaskUncheckedCreateWithoutOrganizationInput> | TaskCreateWithoutOrganizationInput[] | TaskUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutOrganizationInput | TaskCreateOrConnectWithoutOrganizationInput[]
    createMany?: TaskCreateManyOrganizationInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<ActivityLogCreateWithoutOrganizationInput, ActivityLogUncheckedCreateWithoutOrganizationInput> | ActivityLogCreateWithoutOrganizationInput[] | ActivityLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOrganizationInput | ActivityLogCreateOrConnectWithoutOrganizationInput[]
    createMany?: ActivityLogCreateManyOrganizationInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type RequisitionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<RequisitionCreateWithoutOrganizationInput, RequisitionUncheckedCreateWithoutOrganizationInput> | RequisitionCreateWithoutOrganizationInput[] | RequisitionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: RequisitionCreateOrConnectWithoutOrganizationInput | RequisitionCreateOrConnectWithoutOrganizationInput[]
    createMany?: RequisitionCreateManyOrganizationInputEnvelope
    connect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
  }

  export type NeedUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<NeedCreateWithoutOrganizationInput, NeedUncheckedCreateWithoutOrganizationInput> | NeedCreateWithoutOrganizationInput[] | NeedUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NeedCreateOrConnectWithoutOrganizationInput | NeedCreateOrConnectWithoutOrganizationInput[]
    createMany?: NeedCreateManyOrganizationInputEnvelope
    connect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<MeetingCreateWithoutOrganizationInput, MeetingUncheckedCreateWithoutOrganizationInput> | MeetingCreateWithoutOrganizationInput[] | MeetingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutOrganizationInput | MeetingCreateOrConnectWithoutOrganizationInput[]
    createMany?: MeetingCreateManyOrganizationInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type EmailAccountUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EmailAccountCreateWithoutOrganizationInput, EmailAccountUncheckedCreateWithoutOrganizationInput> | EmailAccountCreateWithoutOrganizationInput[] | EmailAccountUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOrganizationInput | EmailAccountCreateOrConnectWithoutOrganizationInput[]
    createMany?: EmailAccountCreateManyOrganizationInputEnvelope
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
  }

  export type EmailActiveSelectionUncheckedCreateNestedManyWithoutOrganizationInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutOrganizationInput, EmailActiveSelectionUncheckedCreateWithoutOrganizationInput> | EmailActiveSelectionCreateWithoutOrganizationInput[] | EmailActiveSelectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutOrganizationInput | EmailActiveSelectionCreateOrConnectWithoutOrganizationInput[]
    createMany?: EmailActiveSelectionCreateManyOrganizationInputEnvelope
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MessageCreateWithoutOrganizationInput, MessageUncheckedCreateWithoutOrganizationInput> | MessageCreateWithoutOrganizationInput[] | MessageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutOrganizationInput | MessageCreateOrConnectWithoutOrganizationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutOrganizationInput | MessageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MessageCreateManyOrganizationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutOrganizationInput | MessageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutOrganizationInput | MessageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TaskCreateWithoutOrganizationInput, TaskUncheckedCreateWithoutOrganizationInput> | TaskCreateWithoutOrganizationInput[] | TaskUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutOrganizationInput | TaskCreateOrConnectWithoutOrganizationInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutOrganizationInput | TaskUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TaskCreateManyOrganizationInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutOrganizationInput | TaskUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutOrganizationInput | TaskUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ActivityLogCreateWithoutOrganizationInput, ActivityLogUncheckedCreateWithoutOrganizationInput> | ActivityLogCreateWithoutOrganizationInput[] | ActivityLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOrganizationInput | ActivityLogCreateOrConnectWithoutOrganizationInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutOrganizationInput | ActivityLogUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ActivityLogCreateManyOrganizationInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutOrganizationInput | ActivityLogUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutOrganizationInput | ActivityLogUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type RequisitionUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<RequisitionCreateWithoutOrganizationInput, RequisitionUncheckedCreateWithoutOrganizationInput> | RequisitionCreateWithoutOrganizationInput[] | RequisitionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: RequisitionCreateOrConnectWithoutOrganizationInput | RequisitionCreateOrConnectWithoutOrganizationInput[]
    upsert?: RequisitionUpsertWithWhereUniqueWithoutOrganizationInput | RequisitionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: RequisitionCreateManyOrganizationInputEnvelope
    set?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    disconnect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    delete?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    connect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    update?: RequisitionUpdateWithWhereUniqueWithoutOrganizationInput | RequisitionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: RequisitionUpdateManyWithWhereWithoutOrganizationInput | RequisitionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: RequisitionScalarWhereInput | RequisitionScalarWhereInput[]
  }

  export type NeedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NeedCreateWithoutOrganizationInput, NeedUncheckedCreateWithoutOrganizationInput> | NeedCreateWithoutOrganizationInput[] | NeedUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NeedCreateOrConnectWithoutOrganizationInput | NeedCreateOrConnectWithoutOrganizationInput[]
    upsert?: NeedUpsertWithWhereUniqueWithoutOrganizationInput | NeedUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NeedCreateManyOrganizationInputEnvelope
    set?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    disconnect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    delete?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    connect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    update?: NeedUpdateWithWhereUniqueWithoutOrganizationInput | NeedUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NeedUpdateManyWithWhereWithoutOrganizationInput | NeedUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NeedScalarWhereInput | NeedScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MeetingCreateWithoutOrganizationInput, MeetingUncheckedCreateWithoutOrganizationInput> | MeetingCreateWithoutOrganizationInput[] | MeetingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutOrganizationInput | MeetingCreateOrConnectWithoutOrganizationInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutOrganizationInput | MeetingUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MeetingCreateManyOrganizationInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutOrganizationInput | MeetingUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutOrganizationInput | MeetingUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type EmailAccountUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EmailAccountCreateWithoutOrganizationInput, EmailAccountUncheckedCreateWithoutOrganizationInput> | EmailAccountCreateWithoutOrganizationInput[] | EmailAccountUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOrganizationInput | EmailAccountCreateOrConnectWithoutOrganizationInput[]
    upsert?: EmailAccountUpsertWithWhereUniqueWithoutOrganizationInput | EmailAccountUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EmailAccountCreateManyOrganizationInputEnvelope
    set?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    disconnect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    delete?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    update?: EmailAccountUpdateWithWhereUniqueWithoutOrganizationInput | EmailAccountUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EmailAccountUpdateManyWithWhereWithoutOrganizationInput | EmailAccountUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
  }

  export type EmailActiveSelectionUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutOrganizationInput, EmailActiveSelectionUncheckedCreateWithoutOrganizationInput> | EmailActiveSelectionCreateWithoutOrganizationInput[] | EmailActiveSelectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutOrganizationInput | EmailActiveSelectionCreateOrConnectWithoutOrganizationInput[]
    upsert?: EmailActiveSelectionUpsertWithWhereUniqueWithoutOrganizationInput | EmailActiveSelectionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EmailActiveSelectionCreateManyOrganizationInputEnvelope
    set?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    disconnect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    delete?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    update?: EmailActiveSelectionUpdateWithWhereUniqueWithoutOrganizationInput | EmailActiveSelectionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EmailActiveSelectionUpdateManyWithWhereWithoutOrganizationInput | EmailActiveSelectionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EmailActiveSelectionScalarWhereInput | EmailActiveSelectionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput> | UserCreateWithoutOrganizationInput[] | UserUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: UserCreateOrConnectWithoutOrganizationInput | UserCreateOrConnectWithoutOrganizationInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutOrganizationInput | UserUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: UserCreateManyOrganizationInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutOrganizationInput | UserUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: UserUpdateManyWithWhereWithoutOrganizationInput | UserUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MessageCreateWithoutOrganizationInput, MessageUncheckedCreateWithoutOrganizationInput> | MessageCreateWithoutOrganizationInput[] | MessageUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutOrganizationInput | MessageCreateOrConnectWithoutOrganizationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutOrganizationInput | MessageUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MessageCreateManyOrganizationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutOrganizationInput | MessageUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutOrganizationInput | MessageUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<TaskCreateWithoutOrganizationInput, TaskUncheckedCreateWithoutOrganizationInput> | TaskCreateWithoutOrganizationInput[] | TaskUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutOrganizationInput | TaskCreateOrConnectWithoutOrganizationInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutOrganizationInput | TaskUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: TaskCreateManyOrganizationInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutOrganizationInput | TaskUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutOrganizationInput | TaskUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<ActivityLogCreateWithoutOrganizationInput, ActivityLogUncheckedCreateWithoutOrganizationInput> | ActivityLogCreateWithoutOrganizationInput[] | ActivityLogUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutOrganizationInput | ActivityLogCreateOrConnectWithoutOrganizationInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutOrganizationInput | ActivityLogUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: ActivityLogCreateManyOrganizationInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutOrganizationInput | ActivityLogUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutOrganizationInput | ActivityLogUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type RequisitionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<RequisitionCreateWithoutOrganizationInput, RequisitionUncheckedCreateWithoutOrganizationInput> | RequisitionCreateWithoutOrganizationInput[] | RequisitionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: RequisitionCreateOrConnectWithoutOrganizationInput | RequisitionCreateOrConnectWithoutOrganizationInput[]
    upsert?: RequisitionUpsertWithWhereUniqueWithoutOrganizationInput | RequisitionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: RequisitionCreateManyOrganizationInputEnvelope
    set?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    disconnect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    delete?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    connect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    update?: RequisitionUpdateWithWhereUniqueWithoutOrganizationInput | RequisitionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: RequisitionUpdateManyWithWhereWithoutOrganizationInput | RequisitionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: RequisitionScalarWhereInput | RequisitionScalarWhereInput[]
  }

  export type NeedUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<NeedCreateWithoutOrganizationInput, NeedUncheckedCreateWithoutOrganizationInput> | NeedCreateWithoutOrganizationInput[] | NeedUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: NeedCreateOrConnectWithoutOrganizationInput | NeedCreateOrConnectWithoutOrganizationInput[]
    upsert?: NeedUpsertWithWhereUniqueWithoutOrganizationInput | NeedUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: NeedCreateManyOrganizationInputEnvelope
    set?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    disconnect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    delete?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    connect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    update?: NeedUpdateWithWhereUniqueWithoutOrganizationInput | NeedUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: NeedUpdateManyWithWhereWithoutOrganizationInput | NeedUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: NeedScalarWhereInput | NeedScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<MeetingCreateWithoutOrganizationInput, MeetingUncheckedCreateWithoutOrganizationInput> | MeetingCreateWithoutOrganizationInput[] | MeetingUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutOrganizationInput | MeetingCreateOrConnectWithoutOrganizationInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutOrganizationInput | MeetingUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: MeetingCreateManyOrganizationInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutOrganizationInput | MeetingUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutOrganizationInput | MeetingUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type EmailAccountUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EmailAccountCreateWithoutOrganizationInput, EmailAccountUncheckedCreateWithoutOrganizationInput> | EmailAccountCreateWithoutOrganizationInput[] | EmailAccountUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOrganizationInput | EmailAccountCreateOrConnectWithoutOrganizationInput[]
    upsert?: EmailAccountUpsertWithWhereUniqueWithoutOrganizationInput | EmailAccountUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EmailAccountCreateManyOrganizationInputEnvelope
    set?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    disconnect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    delete?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    update?: EmailAccountUpdateWithWhereUniqueWithoutOrganizationInput | EmailAccountUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EmailAccountUpdateManyWithWhereWithoutOrganizationInput | EmailAccountUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
  }

  export type EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationNestedInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutOrganizationInput, EmailActiveSelectionUncheckedCreateWithoutOrganizationInput> | EmailActiveSelectionCreateWithoutOrganizationInput[] | EmailActiveSelectionUncheckedCreateWithoutOrganizationInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutOrganizationInput | EmailActiveSelectionCreateOrConnectWithoutOrganizationInput[]
    upsert?: EmailActiveSelectionUpsertWithWhereUniqueWithoutOrganizationInput | EmailActiveSelectionUpsertWithWhereUniqueWithoutOrganizationInput[]
    createMany?: EmailActiveSelectionCreateManyOrganizationInputEnvelope
    set?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    disconnect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    delete?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    update?: EmailActiveSelectionUpdateWithWhereUniqueWithoutOrganizationInput | EmailActiveSelectionUpdateWithWhereUniqueWithoutOrganizationInput[]
    updateMany?: EmailActiveSelectionUpdateManyWithWhereWithoutOrganizationInput | EmailActiveSelectionUpdateManyWithWhereWithoutOrganizationInput[]
    deleteMany?: EmailActiveSelectionScalarWhereInput | EmailActiveSelectionScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutUsersInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TaskCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type RequisitionCreateNestedManyWithoutRequesterInput = {
    create?: XOR<RequisitionCreateWithoutRequesterInput, RequisitionUncheckedCreateWithoutRequesterInput> | RequisitionCreateWithoutRequesterInput[] | RequisitionUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequisitionCreateOrConnectWithoutRequesterInput | RequisitionCreateOrConnectWithoutRequesterInput[]
    createMany?: RequisitionCreateManyRequesterInputEnvelope
    connect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
  }

  export type WorkflowStepCreateNestedManyWithoutReviewerInput = {
    create?: XOR<WorkflowStepCreateWithoutReviewerInput, WorkflowStepUncheckedCreateWithoutReviewerInput> | WorkflowStepCreateWithoutReviewerInput[] | WorkflowStepUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutReviewerInput | WorkflowStepCreateOrConnectWithoutReviewerInput[]
    createMany?: WorkflowStepCreateManyReviewerInputEnvelope
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
  }

  export type NeedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<NeedCreateWithoutRequesterInput, NeedUncheckedCreateWithoutRequesterInput> | NeedCreateWithoutRequesterInput[] | NeedUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: NeedCreateOrConnectWithoutRequesterInput | NeedCreateOrConnectWithoutRequesterInput[]
    createMany?: NeedCreateManyRequesterInputEnvelope
    connect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
  }

  export type NeedWorkflowStepCreateNestedManyWithoutReviewerInput = {
    create?: XOR<NeedWorkflowStepCreateWithoutReviewerInput, NeedWorkflowStepUncheckedCreateWithoutReviewerInput> | NeedWorkflowStepCreateWithoutReviewerInput[] | NeedWorkflowStepUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: NeedWorkflowStepCreateOrConnectWithoutReviewerInput | NeedWorkflowStepCreateOrConnectWithoutReviewerInput[]
    createMany?: NeedWorkflowStepCreateManyReviewerInputEnvelope
    connect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
  }

  export type MeetingCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type EmailAccountCreateNestedManyWithoutOwnerInput = {
    create?: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput> | EmailAccountCreateWithoutOwnerInput[] | EmailAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOwnerInput | EmailAccountCreateOrConnectWithoutOwnerInput[]
    createMany?: EmailAccountCreateManyOwnerInputEnvelope
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
  }

  export type EmailActiveSelectionCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutUserInput, EmailActiveSelectionUncheckedCreateWithoutUserInput> | EmailActiveSelectionCreateWithoutUserInput[] | EmailActiveSelectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutUserInput | EmailActiveSelectionCreateOrConnectWithoutUserInput[]
    createMany?: EmailActiveSelectionCreateManyUserInputEnvelope
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type RequisitionUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<RequisitionCreateWithoutRequesterInput, RequisitionUncheckedCreateWithoutRequesterInput> | RequisitionCreateWithoutRequesterInput[] | RequisitionUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequisitionCreateOrConnectWithoutRequesterInput | RequisitionCreateOrConnectWithoutRequesterInput[]
    createMany?: RequisitionCreateManyRequesterInputEnvelope
    connect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
  }

  export type WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<WorkflowStepCreateWithoutReviewerInput, WorkflowStepUncheckedCreateWithoutReviewerInput> | WorkflowStepCreateWithoutReviewerInput[] | WorkflowStepUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutReviewerInput | WorkflowStepCreateOrConnectWithoutReviewerInput[]
    createMany?: WorkflowStepCreateManyReviewerInputEnvelope
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
  }

  export type NeedUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<NeedCreateWithoutRequesterInput, NeedUncheckedCreateWithoutRequesterInput> | NeedCreateWithoutRequesterInput[] | NeedUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: NeedCreateOrConnectWithoutRequesterInput | NeedCreateOrConnectWithoutRequesterInput[]
    createMany?: NeedCreateManyRequesterInputEnvelope
    connect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
  }

  export type NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<NeedWorkflowStepCreateWithoutReviewerInput, NeedWorkflowStepUncheckedCreateWithoutReviewerInput> | NeedWorkflowStepCreateWithoutReviewerInput[] | NeedWorkflowStepUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: NeedWorkflowStepCreateOrConnectWithoutReviewerInput | NeedWorkflowStepCreateOrConnectWithoutReviewerInput[]
    createMany?: NeedWorkflowStepCreateManyReviewerInputEnvelope
    connect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
  }

  export type MeetingUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
  }

  export type EmailAccountUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput> | EmailAccountCreateWithoutOwnerInput[] | EmailAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOwnerInput | EmailAccountCreateOrConnectWithoutOwnerInput[]
    createMany?: EmailAccountCreateManyOwnerInputEnvelope
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
  }

  export type EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutUserInput, EmailActiveSelectionUncheckedCreateWithoutUserInput> | EmailActiveSelectionCreateWithoutUserInput[] | EmailActiveSelectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutUserInput | EmailActiveSelectionCreateOrConnectWithoutUserInput[]
    createMany?: EmailActiveSelectionCreateManyUserInputEnvelope
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutUsersInput
    upsert?: OrganizationUpsertWithoutUsersInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutUsersInput, OrganizationUpdateWithoutUsersInput>, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type MessageUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TaskUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type RequisitionUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<RequisitionCreateWithoutRequesterInput, RequisitionUncheckedCreateWithoutRequesterInput> | RequisitionCreateWithoutRequesterInput[] | RequisitionUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequisitionCreateOrConnectWithoutRequesterInput | RequisitionCreateOrConnectWithoutRequesterInput[]
    upsert?: RequisitionUpsertWithWhereUniqueWithoutRequesterInput | RequisitionUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: RequisitionCreateManyRequesterInputEnvelope
    set?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    disconnect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    delete?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    connect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    update?: RequisitionUpdateWithWhereUniqueWithoutRequesterInput | RequisitionUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: RequisitionUpdateManyWithWhereWithoutRequesterInput | RequisitionUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: RequisitionScalarWhereInput | RequisitionScalarWhereInput[]
  }

  export type WorkflowStepUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutReviewerInput, WorkflowStepUncheckedCreateWithoutReviewerInput> | WorkflowStepCreateWithoutReviewerInput[] | WorkflowStepUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutReviewerInput | WorkflowStepCreateOrConnectWithoutReviewerInput[]
    upsert?: WorkflowStepUpsertWithWhereUniqueWithoutReviewerInput | WorkflowStepUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: WorkflowStepCreateManyReviewerInputEnvelope
    set?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    disconnect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    delete?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    update?: WorkflowStepUpdateWithWhereUniqueWithoutReviewerInput | WorkflowStepUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: WorkflowStepUpdateManyWithWhereWithoutReviewerInput | WorkflowStepUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
  }

  export type NeedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<NeedCreateWithoutRequesterInput, NeedUncheckedCreateWithoutRequesterInput> | NeedCreateWithoutRequesterInput[] | NeedUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: NeedCreateOrConnectWithoutRequesterInput | NeedCreateOrConnectWithoutRequesterInput[]
    upsert?: NeedUpsertWithWhereUniqueWithoutRequesterInput | NeedUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: NeedCreateManyRequesterInputEnvelope
    set?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    disconnect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    delete?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    connect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    update?: NeedUpdateWithWhereUniqueWithoutRequesterInput | NeedUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: NeedUpdateManyWithWhereWithoutRequesterInput | NeedUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: NeedScalarWhereInput | NeedScalarWhereInput[]
  }

  export type NeedWorkflowStepUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<NeedWorkflowStepCreateWithoutReviewerInput, NeedWorkflowStepUncheckedCreateWithoutReviewerInput> | NeedWorkflowStepCreateWithoutReviewerInput[] | NeedWorkflowStepUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: NeedWorkflowStepCreateOrConnectWithoutReviewerInput | NeedWorkflowStepCreateOrConnectWithoutReviewerInput[]
    upsert?: NeedWorkflowStepUpsertWithWhereUniqueWithoutReviewerInput | NeedWorkflowStepUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: NeedWorkflowStepCreateManyReviewerInputEnvelope
    set?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    disconnect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    delete?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    connect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    update?: NeedWorkflowStepUpdateWithWhereUniqueWithoutReviewerInput | NeedWorkflowStepUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: NeedWorkflowStepUpdateManyWithWhereWithoutReviewerInput | NeedWorkflowStepUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: NeedWorkflowStepScalarWhereInput | NeedWorkflowStepScalarWhereInput[]
  }

  export type MeetingUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutCreatorInput | MeetingUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutCreatorInput | MeetingUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutCreatorInput | MeetingUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type EmailAccountUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput> | EmailAccountCreateWithoutOwnerInput[] | EmailAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOwnerInput | EmailAccountCreateOrConnectWithoutOwnerInput[]
    upsert?: EmailAccountUpsertWithWhereUniqueWithoutOwnerInput | EmailAccountUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: EmailAccountCreateManyOwnerInputEnvelope
    set?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    disconnect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    delete?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    update?: EmailAccountUpdateWithWhereUniqueWithoutOwnerInput | EmailAccountUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: EmailAccountUpdateManyWithWhereWithoutOwnerInput | EmailAccountUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
  }

  export type EmailActiveSelectionUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutUserInput, EmailActiveSelectionUncheckedCreateWithoutUserInput> | EmailActiveSelectionCreateWithoutUserInput[] | EmailActiveSelectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutUserInput | EmailActiveSelectionCreateOrConnectWithoutUserInput[]
    upsert?: EmailActiveSelectionUpsertWithWhereUniqueWithoutUserInput | EmailActiveSelectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailActiveSelectionCreateManyUserInputEnvelope
    set?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    disconnect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    delete?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    update?: EmailActiveSelectionUpdateWithWhereUniqueWithoutUserInput | EmailActiveSelectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailActiveSelectionUpdateManyWithWhereWithoutUserInput | EmailActiveSelectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailActiveSelectionScalarWhereInput | EmailActiveSelectionScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput> | MessageCreateWithoutUserInput[] | MessageUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutUserInput | MessageCreateOrConnectWithoutUserInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutUserInput | MessageUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageCreateManyUserInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutUserInput | MessageUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutUserInput | MessageUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput> | TaskCreateWithoutUserInput[] | TaskUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutUserInput | TaskCreateOrConnectWithoutUserInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutUserInput | TaskUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TaskCreateManyUserInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutUserInput | TaskUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutUserInput | TaskUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type RequisitionUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<RequisitionCreateWithoutRequesterInput, RequisitionUncheckedCreateWithoutRequesterInput> | RequisitionCreateWithoutRequesterInput[] | RequisitionUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: RequisitionCreateOrConnectWithoutRequesterInput | RequisitionCreateOrConnectWithoutRequesterInput[]
    upsert?: RequisitionUpsertWithWhereUniqueWithoutRequesterInput | RequisitionUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: RequisitionCreateManyRequesterInputEnvelope
    set?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    disconnect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    delete?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    connect?: RequisitionWhereUniqueInput | RequisitionWhereUniqueInput[]
    update?: RequisitionUpdateWithWhereUniqueWithoutRequesterInput | RequisitionUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: RequisitionUpdateManyWithWhereWithoutRequesterInput | RequisitionUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: RequisitionScalarWhereInput | RequisitionScalarWhereInput[]
  }

  export type WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutReviewerInput, WorkflowStepUncheckedCreateWithoutReviewerInput> | WorkflowStepCreateWithoutReviewerInput[] | WorkflowStepUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutReviewerInput | WorkflowStepCreateOrConnectWithoutReviewerInput[]
    upsert?: WorkflowStepUpsertWithWhereUniqueWithoutReviewerInput | WorkflowStepUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: WorkflowStepCreateManyReviewerInputEnvelope
    set?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    disconnect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    delete?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    update?: WorkflowStepUpdateWithWhereUniqueWithoutReviewerInput | WorkflowStepUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: WorkflowStepUpdateManyWithWhereWithoutReviewerInput | WorkflowStepUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
  }

  export type NeedUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<NeedCreateWithoutRequesterInput, NeedUncheckedCreateWithoutRequesterInput> | NeedCreateWithoutRequesterInput[] | NeedUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: NeedCreateOrConnectWithoutRequesterInput | NeedCreateOrConnectWithoutRequesterInput[]
    upsert?: NeedUpsertWithWhereUniqueWithoutRequesterInput | NeedUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: NeedCreateManyRequesterInputEnvelope
    set?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    disconnect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    delete?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    connect?: NeedWhereUniqueInput | NeedWhereUniqueInput[]
    update?: NeedUpdateWithWhereUniqueWithoutRequesterInput | NeedUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: NeedUpdateManyWithWhereWithoutRequesterInput | NeedUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: NeedScalarWhereInput | NeedScalarWhereInput[]
  }

  export type NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<NeedWorkflowStepCreateWithoutReviewerInput, NeedWorkflowStepUncheckedCreateWithoutReviewerInput> | NeedWorkflowStepCreateWithoutReviewerInput[] | NeedWorkflowStepUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: NeedWorkflowStepCreateOrConnectWithoutReviewerInput | NeedWorkflowStepCreateOrConnectWithoutReviewerInput[]
    upsert?: NeedWorkflowStepUpsertWithWhereUniqueWithoutReviewerInput | NeedWorkflowStepUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: NeedWorkflowStepCreateManyReviewerInputEnvelope
    set?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    disconnect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    delete?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    connect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    update?: NeedWorkflowStepUpdateWithWhereUniqueWithoutReviewerInput | NeedWorkflowStepUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: NeedWorkflowStepUpdateManyWithWhereWithoutReviewerInput | NeedWorkflowStepUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: NeedWorkflowStepScalarWhereInput | NeedWorkflowStepScalarWhereInput[]
  }

  export type MeetingUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput> | MeetingCreateWithoutCreatorInput[] | MeetingUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: MeetingCreateOrConnectWithoutCreatorInput | MeetingCreateOrConnectWithoutCreatorInput[]
    upsert?: MeetingUpsertWithWhereUniqueWithoutCreatorInput | MeetingUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: MeetingCreateManyCreatorInputEnvelope
    set?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    disconnect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    delete?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    connect?: MeetingWhereUniqueInput | MeetingWhereUniqueInput[]
    update?: MeetingUpdateWithWhereUniqueWithoutCreatorInput | MeetingUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: MeetingUpdateManyWithWhereWithoutCreatorInput | MeetingUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
  }

  export type EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput> | EmailAccountCreateWithoutOwnerInput[] | EmailAccountUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: EmailAccountCreateOrConnectWithoutOwnerInput | EmailAccountCreateOrConnectWithoutOwnerInput[]
    upsert?: EmailAccountUpsertWithWhereUniqueWithoutOwnerInput | EmailAccountUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: EmailAccountCreateManyOwnerInputEnvelope
    set?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    disconnect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    delete?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    connect?: EmailAccountWhereUniqueInput | EmailAccountWhereUniqueInput[]
    update?: EmailAccountUpdateWithWhereUniqueWithoutOwnerInput | EmailAccountUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: EmailAccountUpdateManyWithWhereWithoutOwnerInput | EmailAccountUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
  }

  export type EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutUserInput, EmailActiveSelectionUncheckedCreateWithoutUserInput> | EmailActiveSelectionCreateWithoutUserInput[] | EmailActiveSelectionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutUserInput | EmailActiveSelectionCreateOrConnectWithoutUserInput[]
    upsert?: EmailActiveSelectionUpsertWithWhereUniqueWithoutUserInput | EmailActiveSelectionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailActiveSelectionCreateManyUserInputEnvelope
    set?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    disconnect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    delete?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    update?: EmailActiveSelectionUpdateWithWhereUniqueWithoutUserInput | EmailActiveSelectionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailActiveSelectionUpdateManyWithWhereWithoutUserInput | EmailActiveSelectionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailActiveSelectionScalarWhereInput | EmailActiveSelectionScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<OrganizationCreateWithoutMessagesInput, OrganizationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMessagesInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type OrganizationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<OrganizationCreateWithoutMessagesInput, OrganizationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMessagesInput
    upsert?: OrganizationUpsertWithoutMessagesInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMessagesInput, OrganizationUpdateWithoutMessagesInput>, OrganizationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type OrganizationCreateNestedOneWithoutTasksInput = {
    create?: XOR<OrganizationCreateWithoutTasksInput, OrganizationUncheckedCreateWithoutTasksInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTasksInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type TaskRunCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskRunCreateWithoutTaskInput, TaskRunUncheckedCreateWithoutTaskInput> | TaskRunCreateWithoutTaskInput[] | TaskRunUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskRunCreateOrConnectWithoutTaskInput | TaskRunCreateOrConnectWithoutTaskInput[]
    createMany?: TaskRunCreateManyTaskInputEnvelope
    connect?: TaskRunWhereUniqueInput | TaskRunWhereUniqueInput[]
  }

  export type TaskRunUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<TaskRunCreateWithoutTaskInput, TaskRunUncheckedCreateWithoutTaskInput> | TaskRunCreateWithoutTaskInput[] | TaskRunUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskRunCreateOrConnectWithoutTaskInput | TaskRunCreateOrConnectWithoutTaskInput[]
    createMany?: TaskRunCreateManyTaskInputEnvelope
    connect?: TaskRunWhereUniqueInput | TaskRunWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<OrganizationCreateWithoutTasksInput, OrganizationUncheckedCreateWithoutTasksInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutTasksInput
    upsert?: OrganizationUpsertWithoutTasksInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutTasksInput, OrganizationUpdateWithoutTasksInput>, OrganizationUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type TaskRunUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskRunCreateWithoutTaskInput, TaskRunUncheckedCreateWithoutTaskInput> | TaskRunCreateWithoutTaskInput[] | TaskRunUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskRunCreateOrConnectWithoutTaskInput | TaskRunCreateOrConnectWithoutTaskInput[]
    upsert?: TaskRunUpsertWithWhereUniqueWithoutTaskInput | TaskRunUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskRunCreateManyTaskInputEnvelope
    set?: TaskRunWhereUniqueInput | TaskRunWhereUniqueInput[]
    disconnect?: TaskRunWhereUniqueInput | TaskRunWhereUniqueInput[]
    delete?: TaskRunWhereUniqueInput | TaskRunWhereUniqueInput[]
    connect?: TaskRunWhereUniqueInput | TaskRunWhereUniqueInput[]
    update?: TaskRunUpdateWithWhereUniqueWithoutTaskInput | TaskRunUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskRunUpdateManyWithWhereWithoutTaskInput | TaskRunUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskRunScalarWhereInput | TaskRunScalarWhereInput[]
  }

  export type TaskRunUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<TaskRunCreateWithoutTaskInput, TaskRunUncheckedCreateWithoutTaskInput> | TaskRunCreateWithoutTaskInput[] | TaskRunUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: TaskRunCreateOrConnectWithoutTaskInput | TaskRunCreateOrConnectWithoutTaskInput[]
    upsert?: TaskRunUpsertWithWhereUniqueWithoutTaskInput | TaskRunUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: TaskRunCreateManyTaskInputEnvelope
    set?: TaskRunWhereUniqueInput | TaskRunWhereUniqueInput[]
    disconnect?: TaskRunWhereUniqueInput | TaskRunWhereUniqueInput[]
    delete?: TaskRunWhereUniqueInput | TaskRunWhereUniqueInput[]
    connect?: TaskRunWhereUniqueInput | TaskRunWhereUniqueInput[]
    update?: TaskRunUpdateWithWhereUniqueWithoutTaskInput | TaskRunUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: TaskRunUpdateManyWithWhereWithoutTaskInput | TaskRunUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: TaskRunScalarWhereInput | TaskRunScalarWhereInput[]
  }

  export type TaskCreateNestedOneWithoutRunsInput = {
    create?: XOR<TaskCreateWithoutRunsInput, TaskUncheckedCreateWithoutRunsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutRunsInput
    connect?: TaskWhereUniqueInput
  }

  export type TaskUpdateOneRequiredWithoutRunsNestedInput = {
    create?: XOR<TaskCreateWithoutRunsInput, TaskUncheckedCreateWithoutRunsInput>
    connectOrCreate?: TaskCreateOrConnectWithoutRunsInput
    upsert?: TaskUpsertWithoutRunsInput
    connect?: TaskWhereUniqueInput
    update?: XOR<XOR<TaskUpdateToOneWithWhereWithoutRunsInput, TaskUpdateWithoutRunsInput>, TaskUncheckedUpdateWithoutRunsInput>
  }

  export type OrganizationCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<OrganizationCreateWithoutActivityLogsInput, OrganizationUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutActivityLogsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<OrganizationCreateWithoutActivityLogsInput, OrganizationUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutActivityLogsInput
    upsert?: OrganizationUpsertWithoutActivityLogsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutActivityLogsInput, OrganizationUpdateWithoutActivityLogsInput>, OrganizationUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserCreateNestedOneWithoutRequisitionsRequestedInput = {
    create?: XOR<UserCreateWithoutRequisitionsRequestedInput, UserUncheckedCreateWithoutRequisitionsRequestedInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequisitionsRequestedInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutRequisitionsInput = {
    create?: XOR<OrganizationCreateWithoutRequisitionsInput, OrganizationUncheckedCreateWithoutRequisitionsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutRequisitionsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type WorkflowStepCreateNestedManyWithoutRequisitionInput = {
    create?: XOR<WorkflowStepCreateWithoutRequisitionInput, WorkflowStepUncheckedCreateWithoutRequisitionInput> | WorkflowStepCreateWithoutRequisitionInput[] | WorkflowStepUncheckedCreateWithoutRequisitionInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutRequisitionInput | WorkflowStepCreateOrConnectWithoutRequisitionInput[]
    createMany?: WorkflowStepCreateManyRequisitionInputEnvelope
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
  }

  export type WorkflowStepUncheckedCreateNestedManyWithoutRequisitionInput = {
    create?: XOR<WorkflowStepCreateWithoutRequisitionInput, WorkflowStepUncheckedCreateWithoutRequisitionInput> | WorkflowStepCreateWithoutRequisitionInput[] | WorkflowStepUncheckedCreateWithoutRequisitionInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutRequisitionInput | WorkflowStepCreateOrConnectWithoutRequisitionInput[]
    createMany?: WorkflowStepCreateManyRequisitionInputEnvelope
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutRequisitionsRequestedNestedInput = {
    create?: XOR<UserCreateWithoutRequisitionsRequestedInput, UserUncheckedCreateWithoutRequisitionsRequestedInput>
    connectOrCreate?: UserCreateOrConnectWithoutRequisitionsRequestedInput
    upsert?: UserUpsertWithoutRequisitionsRequestedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRequisitionsRequestedInput, UserUpdateWithoutRequisitionsRequestedInput>, UserUncheckedUpdateWithoutRequisitionsRequestedInput>
  }

  export type OrganizationUpdateOneRequiredWithoutRequisitionsNestedInput = {
    create?: XOR<OrganizationCreateWithoutRequisitionsInput, OrganizationUncheckedCreateWithoutRequisitionsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutRequisitionsInput
    upsert?: OrganizationUpsertWithoutRequisitionsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutRequisitionsInput, OrganizationUpdateWithoutRequisitionsInput>, OrganizationUncheckedUpdateWithoutRequisitionsInput>
  }

  export type WorkflowStepUpdateManyWithoutRequisitionNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutRequisitionInput, WorkflowStepUncheckedCreateWithoutRequisitionInput> | WorkflowStepCreateWithoutRequisitionInput[] | WorkflowStepUncheckedCreateWithoutRequisitionInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutRequisitionInput | WorkflowStepCreateOrConnectWithoutRequisitionInput[]
    upsert?: WorkflowStepUpsertWithWhereUniqueWithoutRequisitionInput | WorkflowStepUpsertWithWhereUniqueWithoutRequisitionInput[]
    createMany?: WorkflowStepCreateManyRequisitionInputEnvelope
    set?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    disconnect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    delete?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    update?: WorkflowStepUpdateWithWhereUniqueWithoutRequisitionInput | WorkflowStepUpdateWithWhereUniqueWithoutRequisitionInput[]
    updateMany?: WorkflowStepUpdateManyWithWhereWithoutRequisitionInput | WorkflowStepUpdateManyWithWhereWithoutRequisitionInput[]
    deleteMany?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
  }

  export type WorkflowStepUncheckedUpdateManyWithoutRequisitionNestedInput = {
    create?: XOR<WorkflowStepCreateWithoutRequisitionInput, WorkflowStepUncheckedCreateWithoutRequisitionInput> | WorkflowStepCreateWithoutRequisitionInput[] | WorkflowStepUncheckedCreateWithoutRequisitionInput[]
    connectOrCreate?: WorkflowStepCreateOrConnectWithoutRequisitionInput | WorkflowStepCreateOrConnectWithoutRequisitionInput[]
    upsert?: WorkflowStepUpsertWithWhereUniqueWithoutRequisitionInput | WorkflowStepUpsertWithWhereUniqueWithoutRequisitionInput[]
    createMany?: WorkflowStepCreateManyRequisitionInputEnvelope
    set?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    disconnect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    delete?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    connect?: WorkflowStepWhereUniqueInput | WorkflowStepWhereUniqueInput[]
    update?: WorkflowStepUpdateWithWhereUniqueWithoutRequisitionInput | WorkflowStepUpdateWithWhereUniqueWithoutRequisitionInput[]
    updateMany?: WorkflowStepUpdateManyWithWhereWithoutRequisitionInput | WorkflowStepUpdateManyWithWhereWithoutRequisitionInput[]
    deleteMany?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
  }

  export type RequisitionCreateNestedOneWithoutWorkflowInput = {
    create?: XOR<RequisitionCreateWithoutWorkflowInput, RequisitionUncheckedCreateWithoutWorkflowInput>
    connectOrCreate?: RequisitionCreateOrConnectWithoutWorkflowInput
    connect?: RequisitionWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutWorkflowStepsReviewedInput = {
    create?: XOR<UserCreateWithoutWorkflowStepsReviewedInput, UserUncheckedCreateWithoutWorkflowStepsReviewedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowStepsReviewedInput
    connect?: UserWhereUniqueInput
  }

  export type RequisitionUpdateOneRequiredWithoutWorkflowNestedInput = {
    create?: XOR<RequisitionCreateWithoutWorkflowInput, RequisitionUncheckedCreateWithoutWorkflowInput>
    connectOrCreate?: RequisitionCreateOrConnectWithoutWorkflowInput
    upsert?: RequisitionUpsertWithoutWorkflowInput
    connect?: RequisitionWhereUniqueInput
    update?: XOR<XOR<RequisitionUpdateToOneWithWhereWithoutWorkflowInput, RequisitionUpdateWithoutWorkflowInput>, RequisitionUncheckedUpdateWithoutWorkflowInput>
  }

  export type UserUpdateOneWithoutWorkflowStepsReviewedNestedInput = {
    create?: XOR<UserCreateWithoutWorkflowStepsReviewedInput, UserUncheckedCreateWithoutWorkflowStepsReviewedInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkflowStepsReviewedInput
    upsert?: UserUpsertWithoutWorkflowStepsReviewedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkflowStepsReviewedInput, UserUpdateWithoutWorkflowStepsReviewedInput>, UserUncheckedUpdateWithoutWorkflowStepsReviewedInput>
  }

  export type OrganizationCreateNestedOneWithoutMeetingsInput = {
    create?: XOR<OrganizationCreateWithoutMeetingsInput, OrganizationUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMeetingsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMeetingsCreatedInput = {
    create?: XOR<UserCreateWithoutMeetingsCreatedInput, UserUncheckedCreateWithoutMeetingsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutMeetingsNestedInput = {
    create?: XOR<OrganizationCreateWithoutMeetingsInput, OrganizationUncheckedCreateWithoutMeetingsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutMeetingsInput
    upsert?: OrganizationUpsertWithoutMeetingsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutMeetingsInput, OrganizationUpdateWithoutMeetingsInput>, OrganizationUncheckedUpdateWithoutMeetingsInput>
  }

  export type UserUpdateOneWithoutMeetingsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutMeetingsCreatedInput, UserUncheckedCreateWithoutMeetingsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeetingsCreatedInput
    upsert?: UserUpsertWithoutMeetingsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMeetingsCreatedInput, UserUpdateWithoutMeetingsCreatedInput>, UserUncheckedUpdateWithoutMeetingsCreatedInput>
  }

  export type OrganizationCreateNestedOneWithoutEmailAccountsInput = {
    create?: XOR<OrganizationCreateWithoutEmailAccountsInput, OrganizationUncheckedCreateWithoutEmailAccountsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEmailAccountsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmailAccountsInput = {
    create?: XOR<UserCreateWithoutEmailAccountsInput, UserUncheckedCreateWithoutEmailAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type EmailActiveSelectionCreateNestedManyWithoutAccountInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutAccountInput, EmailActiveSelectionUncheckedCreateWithoutAccountInput> | EmailActiveSelectionCreateWithoutAccountInput[] | EmailActiveSelectionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutAccountInput | EmailActiveSelectionCreateOrConnectWithoutAccountInput[]
    createMany?: EmailActiveSelectionCreateManyAccountInputEnvelope
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
  }

  export type EmailActiveSelectionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutAccountInput, EmailActiveSelectionUncheckedCreateWithoutAccountInput> | EmailActiveSelectionCreateWithoutAccountInput[] | EmailActiveSelectionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutAccountInput | EmailActiveSelectionCreateOrConnectWithoutAccountInput[]
    createMany?: EmailActiveSelectionCreateManyAccountInputEnvelope
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
  }

  export type OrganizationUpdateOneRequiredWithoutEmailAccountsNestedInput = {
    create?: XOR<OrganizationCreateWithoutEmailAccountsInput, OrganizationUncheckedCreateWithoutEmailAccountsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEmailAccountsInput
    upsert?: OrganizationUpsertWithoutEmailAccountsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutEmailAccountsInput, OrganizationUpdateWithoutEmailAccountsInput>, OrganizationUncheckedUpdateWithoutEmailAccountsInput>
  }

  export type UserUpdateOneWithoutEmailAccountsNestedInput = {
    create?: XOR<UserCreateWithoutEmailAccountsInput, UserUncheckedCreateWithoutEmailAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailAccountsInput
    upsert?: UserUpsertWithoutEmailAccountsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailAccountsInput, UserUpdateWithoutEmailAccountsInput>, UserUncheckedUpdateWithoutEmailAccountsInput>
  }

  export type EmailActiveSelectionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutAccountInput, EmailActiveSelectionUncheckedCreateWithoutAccountInput> | EmailActiveSelectionCreateWithoutAccountInput[] | EmailActiveSelectionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutAccountInput | EmailActiveSelectionCreateOrConnectWithoutAccountInput[]
    upsert?: EmailActiveSelectionUpsertWithWhereUniqueWithoutAccountInput | EmailActiveSelectionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EmailActiveSelectionCreateManyAccountInputEnvelope
    set?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    disconnect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    delete?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    update?: EmailActiveSelectionUpdateWithWhereUniqueWithoutAccountInput | EmailActiveSelectionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EmailActiveSelectionUpdateManyWithWhereWithoutAccountInput | EmailActiveSelectionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EmailActiveSelectionScalarWhereInput | EmailActiveSelectionScalarWhereInput[]
  }

  export type EmailActiveSelectionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<EmailActiveSelectionCreateWithoutAccountInput, EmailActiveSelectionUncheckedCreateWithoutAccountInput> | EmailActiveSelectionCreateWithoutAccountInput[] | EmailActiveSelectionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: EmailActiveSelectionCreateOrConnectWithoutAccountInput | EmailActiveSelectionCreateOrConnectWithoutAccountInput[]
    upsert?: EmailActiveSelectionUpsertWithWhereUniqueWithoutAccountInput | EmailActiveSelectionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: EmailActiveSelectionCreateManyAccountInputEnvelope
    set?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    disconnect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    delete?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    connect?: EmailActiveSelectionWhereUniqueInput | EmailActiveSelectionWhereUniqueInput[]
    update?: EmailActiveSelectionUpdateWithWhereUniqueWithoutAccountInput | EmailActiveSelectionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: EmailActiveSelectionUpdateManyWithWhereWithoutAccountInput | EmailActiveSelectionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: EmailActiveSelectionScalarWhereInput | EmailActiveSelectionScalarWhereInput[]
  }

  export type OrganizationCreateNestedOneWithoutEmailSelectionsInput = {
    create?: XOR<OrganizationCreateWithoutEmailSelectionsInput, OrganizationUncheckedCreateWithoutEmailSelectionsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEmailSelectionsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmailSelectionsInput = {
    create?: XOR<UserCreateWithoutEmailSelectionsInput, UserUncheckedCreateWithoutEmailSelectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailSelectionsInput
    connect?: UserWhereUniqueInput
  }

  export type EmailAccountCreateNestedOneWithoutSelectionsInput = {
    create?: XOR<EmailAccountCreateWithoutSelectionsInput, EmailAccountUncheckedCreateWithoutSelectionsInput>
    connectOrCreate?: EmailAccountCreateOrConnectWithoutSelectionsInput
    connect?: EmailAccountWhereUniqueInput
  }

  export type OrganizationUpdateOneRequiredWithoutEmailSelectionsNestedInput = {
    create?: XOR<OrganizationCreateWithoutEmailSelectionsInput, OrganizationUncheckedCreateWithoutEmailSelectionsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutEmailSelectionsInput
    upsert?: OrganizationUpsertWithoutEmailSelectionsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutEmailSelectionsInput, OrganizationUpdateWithoutEmailSelectionsInput>, OrganizationUncheckedUpdateWithoutEmailSelectionsInput>
  }

  export type UserUpdateOneRequiredWithoutEmailSelectionsNestedInput = {
    create?: XOR<UserCreateWithoutEmailSelectionsInput, UserUncheckedCreateWithoutEmailSelectionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailSelectionsInput
    upsert?: UserUpsertWithoutEmailSelectionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailSelectionsInput, UserUpdateWithoutEmailSelectionsInput>, UserUncheckedUpdateWithoutEmailSelectionsInput>
  }

  export type EmailAccountUpdateOneRequiredWithoutSelectionsNestedInput = {
    create?: XOR<EmailAccountCreateWithoutSelectionsInput, EmailAccountUncheckedCreateWithoutSelectionsInput>
    connectOrCreate?: EmailAccountCreateOrConnectWithoutSelectionsInput
    upsert?: EmailAccountUpsertWithoutSelectionsInput
    connect?: EmailAccountWhereUniqueInput
    update?: XOR<XOR<EmailAccountUpdateToOneWithWhereWithoutSelectionsInput, EmailAccountUpdateWithoutSelectionsInput>, EmailAccountUncheckedUpdateWithoutSelectionsInput>
  }

  export type UserCreateNestedOneWithoutNeedsRequestedInput = {
    create?: XOR<UserCreateWithoutNeedsRequestedInput, UserUncheckedCreateWithoutNeedsRequestedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNeedsRequestedInput
    connect?: UserWhereUniqueInput
  }

  export type OrganizationCreateNestedOneWithoutNeedsInput = {
    create?: XOR<OrganizationCreateWithoutNeedsInput, OrganizationUncheckedCreateWithoutNeedsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNeedsInput
    connect?: OrganizationWhereUniqueInput
  }

  export type NeedWorkflowStepCreateNestedManyWithoutNeedInput = {
    create?: XOR<NeedWorkflowStepCreateWithoutNeedInput, NeedWorkflowStepUncheckedCreateWithoutNeedInput> | NeedWorkflowStepCreateWithoutNeedInput[] | NeedWorkflowStepUncheckedCreateWithoutNeedInput[]
    connectOrCreate?: NeedWorkflowStepCreateOrConnectWithoutNeedInput | NeedWorkflowStepCreateOrConnectWithoutNeedInput[]
    createMany?: NeedWorkflowStepCreateManyNeedInputEnvelope
    connect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
  }

  export type NeedAttachmentCreateNestedManyWithoutNeedInput = {
    create?: XOR<NeedAttachmentCreateWithoutNeedInput, NeedAttachmentUncheckedCreateWithoutNeedInput> | NeedAttachmentCreateWithoutNeedInput[] | NeedAttachmentUncheckedCreateWithoutNeedInput[]
    connectOrCreate?: NeedAttachmentCreateOrConnectWithoutNeedInput | NeedAttachmentCreateOrConnectWithoutNeedInput[]
    createMany?: NeedAttachmentCreateManyNeedInputEnvelope
    connect?: NeedAttachmentWhereUniqueInput | NeedAttachmentWhereUniqueInput[]
  }

  export type NeedWorkflowStepUncheckedCreateNestedManyWithoutNeedInput = {
    create?: XOR<NeedWorkflowStepCreateWithoutNeedInput, NeedWorkflowStepUncheckedCreateWithoutNeedInput> | NeedWorkflowStepCreateWithoutNeedInput[] | NeedWorkflowStepUncheckedCreateWithoutNeedInput[]
    connectOrCreate?: NeedWorkflowStepCreateOrConnectWithoutNeedInput | NeedWorkflowStepCreateOrConnectWithoutNeedInput[]
    createMany?: NeedWorkflowStepCreateManyNeedInputEnvelope
    connect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
  }

  export type NeedAttachmentUncheckedCreateNestedManyWithoutNeedInput = {
    create?: XOR<NeedAttachmentCreateWithoutNeedInput, NeedAttachmentUncheckedCreateWithoutNeedInput> | NeedAttachmentCreateWithoutNeedInput[] | NeedAttachmentUncheckedCreateWithoutNeedInput[]
    connectOrCreate?: NeedAttachmentCreateOrConnectWithoutNeedInput | NeedAttachmentCreateOrConnectWithoutNeedInput[]
    createMany?: NeedAttachmentCreateManyNeedInputEnvelope
    connect?: NeedAttachmentWhereUniqueInput | NeedAttachmentWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutNeedsRequestedNestedInput = {
    create?: XOR<UserCreateWithoutNeedsRequestedInput, UserUncheckedCreateWithoutNeedsRequestedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNeedsRequestedInput
    upsert?: UserUpsertWithoutNeedsRequestedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNeedsRequestedInput, UserUpdateWithoutNeedsRequestedInput>, UserUncheckedUpdateWithoutNeedsRequestedInput>
  }

  export type OrganizationUpdateOneRequiredWithoutNeedsNestedInput = {
    create?: XOR<OrganizationCreateWithoutNeedsInput, OrganizationUncheckedCreateWithoutNeedsInput>
    connectOrCreate?: OrganizationCreateOrConnectWithoutNeedsInput
    upsert?: OrganizationUpsertWithoutNeedsInput
    connect?: OrganizationWhereUniqueInput
    update?: XOR<XOR<OrganizationUpdateToOneWithWhereWithoutNeedsInput, OrganizationUpdateWithoutNeedsInput>, OrganizationUncheckedUpdateWithoutNeedsInput>
  }

  export type NeedWorkflowStepUpdateManyWithoutNeedNestedInput = {
    create?: XOR<NeedWorkflowStepCreateWithoutNeedInput, NeedWorkflowStepUncheckedCreateWithoutNeedInput> | NeedWorkflowStepCreateWithoutNeedInput[] | NeedWorkflowStepUncheckedCreateWithoutNeedInput[]
    connectOrCreate?: NeedWorkflowStepCreateOrConnectWithoutNeedInput | NeedWorkflowStepCreateOrConnectWithoutNeedInput[]
    upsert?: NeedWorkflowStepUpsertWithWhereUniqueWithoutNeedInput | NeedWorkflowStepUpsertWithWhereUniqueWithoutNeedInput[]
    createMany?: NeedWorkflowStepCreateManyNeedInputEnvelope
    set?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    disconnect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    delete?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    connect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    update?: NeedWorkflowStepUpdateWithWhereUniqueWithoutNeedInput | NeedWorkflowStepUpdateWithWhereUniqueWithoutNeedInput[]
    updateMany?: NeedWorkflowStepUpdateManyWithWhereWithoutNeedInput | NeedWorkflowStepUpdateManyWithWhereWithoutNeedInput[]
    deleteMany?: NeedWorkflowStepScalarWhereInput | NeedWorkflowStepScalarWhereInput[]
  }

  export type NeedAttachmentUpdateManyWithoutNeedNestedInput = {
    create?: XOR<NeedAttachmentCreateWithoutNeedInput, NeedAttachmentUncheckedCreateWithoutNeedInput> | NeedAttachmentCreateWithoutNeedInput[] | NeedAttachmentUncheckedCreateWithoutNeedInput[]
    connectOrCreate?: NeedAttachmentCreateOrConnectWithoutNeedInput | NeedAttachmentCreateOrConnectWithoutNeedInput[]
    upsert?: NeedAttachmentUpsertWithWhereUniqueWithoutNeedInput | NeedAttachmentUpsertWithWhereUniqueWithoutNeedInput[]
    createMany?: NeedAttachmentCreateManyNeedInputEnvelope
    set?: NeedAttachmentWhereUniqueInput | NeedAttachmentWhereUniqueInput[]
    disconnect?: NeedAttachmentWhereUniqueInput | NeedAttachmentWhereUniqueInput[]
    delete?: NeedAttachmentWhereUniqueInput | NeedAttachmentWhereUniqueInput[]
    connect?: NeedAttachmentWhereUniqueInput | NeedAttachmentWhereUniqueInput[]
    update?: NeedAttachmentUpdateWithWhereUniqueWithoutNeedInput | NeedAttachmentUpdateWithWhereUniqueWithoutNeedInput[]
    updateMany?: NeedAttachmentUpdateManyWithWhereWithoutNeedInput | NeedAttachmentUpdateManyWithWhereWithoutNeedInput[]
    deleteMany?: NeedAttachmentScalarWhereInput | NeedAttachmentScalarWhereInput[]
  }

  export type NeedWorkflowStepUncheckedUpdateManyWithoutNeedNestedInput = {
    create?: XOR<NeedWorkflowStepCreateWithoutNeedInput, NeedWorkflowStepUncheckedCreateWithoutNeedInput> | NeedWorkflowStepCreateWithoutNeedInput[] | NeedWorkflowStepUncheckedCreateWithoutNeedInput[]
    connectOrCreate?: NeedWorkflowStepCreateOrConnectWithoutNeedInput | NeedWorkflowStepCreateOrConnectWithoutNeedInput[]
    upsert?: NeedWorkflowStepUpsertWithWhereUniqueWithoutNeedInput | NeedWorkflowStepUpsertWithWhereUniqueWithoutNeedInput[]
    createMany?: NeedWorkflowStepCreateManyNeedInputEnvelope
    set?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    disconnect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    delete?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    connect?: NeedWorkflowStepWhereUniqueInput | NeedWorkflowStepWhereUniqueInput[]
    update?: NeedWorkflowStepUpdateWithWhereUniqueWithoutNeedInput | NeedWorkflowStepUpdateWithWhereUniqueWithoutNeedInput[]
    updateMany?: NeedWorkflowStepUpdateManyWithWhereWithoutNeedInput | NeedWorkflowStepUpdateManyWithWhereWithoutNeedInput[]
    deleteMany?: NeedWorkflowStepScalarWhereInput | NeedWorkflowStepScalarWhereInput[]
  }

  export type NeedAttachmentUncheckedUpdateManyWithoutNeedNestedInput = {
    create?: XOR<NeedAttachmentCreateWithoutNeedInput, NeedAttachmentUncheckedCreateWithoutNeedInput> | NeedAttachmentCreateWithoutNeedInput[] | NeedAttachmentUncheckedCreateWithoutNeedInput[]
    connectOrCreate?: NeedAttachmentCreateOrConnectWithoutNeedInput | NeedAttachmentCreateOrConnectWithoutNeedInput[]
    upsert?: NeedAttachmentUpsertWithWhereUniqueWithoutNeedInput | NeedAttachmentUpsertWithWhereUniqueWithoutNeedInput[]
    createMany?: NeedAttachmentCreateManyNeedInputEnvelope
    set?: NeedAttachmentWhereUniqueInput | NeedAttachmentWhereUniqueInput[]
    disconnect?: NeedAttachmentWhereUniqueInput | NeedAttachmentWhereUniqueInput[]
    delete?: NeedAttachmentWhereUniqueInput | NeedAttachmentWhereUniqueInput[]
    connect?: NeedAttachmentWhereUniqueInput | NeedAttachmentWhereUniqueInput[]
    update?: NeedAttachmentUpdateWithWhereUniqueWithoutNeedInput | NeedAttachmentUpdateWithWhereUniqueWithoutNeedInput[]
    updateMany?: NeedAttachmentUpdateManyWithWhereWithoutNeedInput | NeedAttachmentUpdateManyWithWhereWithoutNeedInput[]
    deleteMany?: NeedAttachmentScalarWhereInput | NeedAttachmentScalarWhereInput[]
  }

  export type NeedCreateNestedOneWithoutWorkflowInput = {
    create?: XOR<NeedCreateWithoutWorkflowInput, NeedUncheckedCreateWithoutWorkflowInput>
    connectOrCreate?: NeedCreateOrConnectWithoutWorkflowInput
    connect?: NeedWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNeedWorkflowStepsReviewedInput = {
    create?: XOR<UserCreateWithoutNeedWorkflowStepsReviewedInput, UserUncheckedCreateWithoutNeedWorkflowStepsReviewedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNeedWorkflowStepsReviewedInput
    connect?: UserWhereUniqueInput
  }

  export type NeedUpdateOneRequiredWithoutWorkflowNestedInput = {
    create?: XOR<NeedCreateWithoutWorkflowInput, NeedUncheckedCreateWithoutWorkflowInput>
    connectOrCreate?: NeedCreateOrConnectWithoutWorkflowInput
    upsert?: NeedUpsertWithoutWorkflowInput
    connect?: NeedWhereUniqueInput
    update?: XOR<XOR<NeedUpdateToOneWithWhereWithoutWorkflowInput, NeedUpdateWithoutWorkflowInput>, NeedUncheckedUpdateWithoutWorkflowInput>
  }

  export type UserUpdateOneWithoutNeedWorkflowStepsReviewedNestedInput = {
    create?: XOR<UserCreateWithoutNeedWorkflowStepsReviewedInput, UserUncheckedCreateWithoutNeedWorkflowStepsReviewedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNeedWorkflowStepsReviewedInput
    upsert?: UserUpsertWithoutNeedWorkflowStepsReviewedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNeedWorkflowStepsReviewedInput, UserUpdateWithoutNeedWorkflowStepsReviewedInput>, UserUncheckedUpdateWithoutNeedWorkflowStepsReviewedInput>
  }

  export type NeedCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<NeedCreateWithoutAttachmentsInput, NeedUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: NeedCreateOrConnectWithoutAttachmentsInput
    connect?: NeedWhereUniqueInput
  }

  export type NeedUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<NeedCreateWithoutAttachmentsInput, NeedUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: NeedCreateOrConnectWithoutAttachmentsInput
    upsert?: NeedUpsertWithoutAttachmentsInput
    connect?: NeedWhereUniqueInput
    update?: XOR<XOR<NeedUpdateToOneWithWhereWithoutAttachmentsInput, NeedUpdateWithoutAttachmentsInput>, NeedUncheckedUpdateWithoutAttachmentsInput>
  }

  export type InvoiceCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InvoiceUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InvoiceClientCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<InvoiceClientCreateWithoutInvoicesInput, InvoiceClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: InvoiceClientCreateOrConnectWithoutInvoicesInput
    connect?: InvoiceClientWhereUniqueInput
  }

  export type InvoiceLineCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type InvoiceSectionCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceSectionCreateWithoutInvoiceInput, InvoiceSectionUncheckedCreateWithoutInvoiceInput> | InvoiceSectionCreateWithoutInvoiceInput[] | InvoiceSectionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceSectionCreateOrConnectWithoutInvoiceInput | InvoiceSectionCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceSectionCreateManyInvoiceInputEnvelope
    connect?: InvoiceSectionWhereUniqueInput | InvoiceSectionWhereUniqueInput[]
  }

  export type InvoicePaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type InvoiceSectionUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceSectionCreateWithoutInvoiceInput, InvoiceSectionUncheckedCreateWithoutInvoiceInput> | InvoiceSectionCreateWithoutInvoiceInput[] | InvoiceSectionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceSectionCreateOrConnectWithoutInvoiceInput | InvoiceSectionCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceSectionCreateManyInvoiceInputEnvelope
    connect?: InvoiceSectionWhereUniqueInput | InvoiceSectionWhereUniqueInput[]
  }

  export type InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InvoiceClientUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<InvoiceClientCreateWithoutInvoicesInput, InvoiceClientUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: InvoiceClientCreateOrConnectWithoutInvoicesInput
    upsert?: InvoiceClientUpsertWithoutInvoicesInput
    connect?: InvoiceClientWhereUniqueInput
    update?: XOR<XOR<InvoiceClientUpdateToOneWithWhereWithoutInvoicesInput, InvoiceClientUpdateWithoutInvoicesInput>, InvoiceClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceLineUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type InvoiceSectionUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceSectionCreateWithoutInvoiceInput, InvoiceSectionUncheckedCreateWithoutInvoiceInput> | InvoiceSectionCreateWithoutInvoiceInput[] | InvoiceSectionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceSectionCreateOrConnectWithoutInvoiceInput | InvoiceSectionCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceSectionUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceSectionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceSectionCreateManyInvoiceInputEnvelope
    set?: InvoiceSectionWhereUniqueInput | InvoiceSectionWhereUniqueInput[]
    disconnect?: InvoiceSectionWhereUniqueInput | InvoiceSectionWhereUniqueInput[]
    delete?: InvoiceSectionWhereUniqueInput | InvoiceSectionWhereUniqueInput[]
    connect?: InvoiceSectionWhereUniqueInput | InvoiceSectionWhereUniqueInput[]
    update?: InvoiceSectionUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceSectionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceSectionUpdateManyWithWhereWithoutInvoiceInput | InvoiceSectionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceSectionScalarWhereInput | InvoiceSectionScalarWhereInput[]
  }

  export type InvoicePaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    set?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    disconnect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    delete?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    update?: InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput | InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type InvoiceSectionUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceSectionCreateWithoutInvoiceInput, InvoiceSectionUncheckedCreateWithoutInvoiceInput> | InvoiceSectionCreateWithoutInvoiceInput[] | InvoiceSectionUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceSectionCreateOrConnectWithoutInvoiceInput | InvoiceSectionCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceSectionUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceSectionUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceSectionCreateManyInvoiceInputEnvelope
    set?: InvoiceSectionWhereUniqueInput | InvoiceSectionWhereUniqueInput[]
    disconnect?: InvoiceSectionWhereUniqueInput | InvoiceSectionWhereUniqueInput[]
    delete?: InvoiceSectionWhereUniqueInput | InvoiceSectionWhereUniqueInput[]
    connect?: InvoiceSectionWhereUniqueInput | InvoiceSectionWhereUniqueInput[]
    update?: InvoiceSectionUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceSectionUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceSectionUpdateManyWithWhereWithoutInvoiceInput | InvoiceSectionUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceSectionScalarWhereInput | InvoiceSectionScalarWhereInput[]
  }

  export type InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput> | InvoicePaymentCreateWithoutInvoiceInput[] | InvoicePaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoicePaymentCreateOrConnectWithoutInvoiceInput | InvoicePaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoicePaymentCreateManyInvoiceInputEnvelope
    set?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    disconnect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    delete?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    connect?: InvoicePaymentWhereUniqueInput | InvoicePaymentWhereUniqueInput[]
    update?: InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput | InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput | InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutLinesInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    upsert?: InvoiceUpsertWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLinesInput, InvoiceUpdateWithoutLinesInput>, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceCreateNestedOneWithoutSectionsInput = {
    create?: XOR<InvoiceCreateWithoutSectionsInput, InvoiceUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutSectionsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceSectionLineCreateNestedManyWithoutSectionInput = {
    create?: XOR<InvoiceSectionLineCreateWithoutSectionInput, InvoiceSectionLineUncheckedCreateWithoutSectionInput> | InvoiceSectionLineCreateWithoutSectionInput[] | InvoiceSectionLineUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: InvoiceSectionLineCreateOrConnectWithoutSectionInput | InvoiceSectionLineCreateOrConnectWithoutSectionInput[]
    createMany?: InvoiceSectionLineCreateManySectionInputEnvelope
    connect?: InvoiceSectionLineWhereUniqueInput | InvoiceSectionLineWhereUniqueInput[]
  }

  export type InvoiceSectionLineUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<InvoiceSectionLineCreateWithoutSectionInput, InvoiceSectionLineUncheckedCreateWithoutSectionInput> | InvoiceSectionLineCreateWithoutSectionInput[] | InvoiceSectionLineUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: InvoiceSectionLineCreateOrConnectWithoutSectionInput | InvoiceSectionLineCreateOrConnectWithoutSectionInput[]
    createMany?: InvoiceSectionLineCreateManySectionInputEnvelope
    connect?: InvoiceSectionLineWhereUniqueInput | InvoiceSectionLineWhereUniqueInput[]
  }

  export type InvoiceUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<InvoiceCreateWithoutSectionsInput, InvoiceUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutSectionsInput
    upsert?: InvoiceUpsertWithoutSectionsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutSectionsInput, InvoiceUpdateWithoutSectionsInput>, InvoiceUncheckedUpdateWithoutSectionsInput>
  }

  export type InvoiceSectionLineUpdateManyWithoutSectionNestedInput = {
    create?: XOR<InvoiceSectionLineCreateWithoutSectionInput, InvoiceSectionLineUncheckedCreateWithoutSectionInput> | InvoiceSectionLineCreateWithoutSectionInput[] | InvoiceSectionLineUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: InvoiceSectionLineCreateOrConnectWithoutSectionInput | InvoiceSectionLineCreateOrConnectWithoutSectionInput[]
    upsert?: InvoiceSectionLineUpsertWithWhereUniqueWithoutSectionInput | InvoiceSectionLineUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: InvoiceSectionLineCreateManySectionInputEnvelope
    set?: InvoiceSectionLineWhereUniqueInput | InvoiceSectionLineWhereUniqueInput[]
    disconnect?: InvoiceSectionLineWhereUniqueInput | InvoiceSectionLineWhereUniqueInput[]
    delete?: InvoiceSectionLineWhereUniqueInput | InvoiceSectionLineWhereUniqueInput[]
    connect?: InvoiceSectionLineWhereUniqueInput | InvoiceSectionLineWhereUniqueInput[]
    update?: InvoiceSectionLineUpdateWithWhereUniqueWithoutSectionInput | InvoiceSectionLineUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: InvoiceSectionLineUpdateManyWithWhereWithoutSectionInput | InvoiceSectionLineUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: InvoiceSectionLineScalarWhereInput | InvoiceSectionLineScalarWhereInput[]
  }

  export type InvoiceSectionLineUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<InvoiceSectionLineCreateWithoutSectionInput, InvoiceSectionLineUncheckedCreateWithoutSectionInput> | InvoiceSectionLineCreateWithoutSectionInput[] | InvoiceSectionLineUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: InvoiceSectionLineCreateOrConnectWithoutSectionInput | InvoiceSectionLineCreateOrConnectWithoutSectionInput[]
    upsert?: InvoiceSectionLineUpsertWithWhereUniqueWithoutSectionInput | InvoiceSectionLineUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: InvoiceSectionLineCreateManySectionInputEnvelope
    set?: InvoiceSectionLineWhereUniqueInput | InvoiceSectionLineWhereUniqueInput[]
    disconnect?: InvoiceSectionLineWhereUniqueInput | InvoiceSectionLineWhereUniqueInput[]
    delete?: InvoiceSectionLineWhereUniqueInput | InvoiceSectionLineWhereUniqueInput[]
    connect?: InvoiceSectionLineWhereUniqueInput | InvoiceSectionLineWhereUniqueInput[]
    update?: InvoiceSectionLineUpdateWithWhereUniqueWithoutSectionInput | InvoiceSectionLineUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: InvoiceSectionLineUpdateManyWithWhereWithoutSectionInput | InvoiceSectionLineUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: InvoiceSectionLineScalarWhereInput | InvoiceSectionLineScalarWhereInput[]
  }

  export type InvoiceSectionCreateNestedOneWithoutLinesInput = {
    create?: XOR<InvoiceSectionCreateWithoutLinesInput, InvoiceSectionUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceSectionCreateOrConnectWithoutLinesInput
    connect?: InvoiceSectionWhereUniqueInput
  }

  export type InvoiceSectionUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<InvoiceSectionCreateWithoutLinesInput, InvoiceSectionUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceSectionCreateOrConnectWithoutLinesInput
    upsert?: InvoiceSectionUpsertWithoutLinesInput
    connect?: InvoiceSectionWhereUniqueInput
    update?: XOR<XOR<InvoiceSectionUpdateToOneWithWhereWithoutLinesInput, InvoiceSectionUpdateWithoutLinesInput>, InvoiceSectionUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type ExpenseCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ExpenseUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCategoryInput | ExpenseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCategoryInput | ExpenseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCategoryInput | ExpenseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput> | ExpenseCreateWithoutCategoryInput[] | ExpenseUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutCategoryInput | ExpenseCreateOrConnectWithoutCategoryInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutCategoryInput | ExpenseUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: ExpenseCreateManyCategoryInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutCategoryInput | ExpenseUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutCategoryInput | ExpenseUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ExpenseCategoryCreateNestedOneWithoutExpensesInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpensesInput
    connect?: ExpenseCategoryWhereUniqueInput
  }

  export type ExpenseCategoryUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ExpenseCategoryCreateOrConnectWithoutExpensesInput
    upsert?: ExpenseCategoryUpsertWithoutExpensesInput
    disconnect?: ExpenseCategoryWhereInput | boolean
    delete?: ExpenseCategoryWhereInput | boolean
    connect?: ExpenseCategoryWhereUniqueInput
    update?: XOR<XOR<ExpenseCategoryUpdateToOneWithWhereWithoutExpensesInput, ExpenseCategoryUpdateWithoutExpensesInput>, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutOrganizationInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOrganizationInput = {
    id?: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserCreateManyOrganizationInputEnvelope = {
    data: UserCreateManyOrganizationInput | UserCreateManyOrganizationInput[]
  }

  export type MessageCreateWithoutOrganizationInput = {
    kind?: string
    channel?: string | null
    content: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    user?: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutOrganizationInput = {
    id?: number
    userId?: number | null
    kind?: string
    channel?: string | null
    content: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type MessageCreateOrConnectWithoutOrganizationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutOrganizationInput, MessageUncheckedCreateWithoutOrganizationInput>
  }

  export type MessageCreateManyOrganizationInputEnvelope = {
    data: MessageCreateManyOrganizationInput | MessageCreateManyOrganizationInput[]
  }

  export type TaskCreateWithoutOrganizationInput = {
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    user?: UserCreateNestedOneWithoutTasksInput
    runs?: TaskRunCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutOrganizationInput = {
    id?: number
    userId?: number | null
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    runs?: TaskRunUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutOrganizationInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutOrganizationInput, TaskUncheckedCreateWithoutOrganizationInput>
  }

  export type TaskCreateManyOrganizationInputEnvelope = {
    data: TaskCreateManyOrganizationInput | TaskCreateManyOrganizationInput[]
  }

  export type ActivityLogCreateWithoutOrganizationInput = {
    subjectType: string
    subjectId?: number | null
    action: string
    detail?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    user?: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateWithoutOrganizationInput = {
    id?: number
    userId?: number | null
    subjectType: string
    subjectId?: number | null
    action: string
    detail?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type ActivityLogCreateOrConnectWithoutOrganizationInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutOrganizationInput, ActivityLogUncheckedCreateWithoutOrganizationInput>
  }

  export type ActivityLogCreateManyOrganizationInputEnvelope = {
    data: ActivityLogCreateManyOrganizationInput | ActivityLogCreateManyOrganizationInput[]
  }

  export type RequisitionCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    requester?: UserCreateNestedOneWithoutRequisitionsRequestedInput
    workflow?: WorkflowStepCreateNestedManyWithoutRequisitionInput
  }

  export type RequisitionUncheckedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    requesterId?: number | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    workflow?: WorkflowStepUncheckedCreateNestedManyWithoutRequisitionInput
  }

  export type RequisitionCreateOrConnectWithoutOrganizationInput = {
    where: RequisitionWhereUniqueInput
    create: XOR<RequisitionCreateWithoutOrganizationInput, RequisitionUncheckedCreateWithoutOrganizationInput>
  }

  export type RequisitionCreateManyOrganizationInputEnvelope = {
    data: RequisitionCreateManyOrganizationInput | RequisitionCreateManyOrganizationInput[]
  }

  export type NeedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    requester?: UserCreateNestedOneWithoutNeedsRequestedInput
    workflow?: NeedWorkflowStepCreateNestedManyWithoutNeedInput
    attachments?: NeedAttachmentCreateNestedManyWithoutNeedInput
  }

  export type NeedUncheckedCreateWithoutOrganizationInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterId?: number | null
    requesterName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    workflow?: NeedWorkflowStepUncheckedCreateNestedManyWithoutNeedInput
    attachments?: NeedAttachmentUncheckedCreateNestedManyWithoutNeedInput
  }

  export type NeedCreateOrConnectWithoutOrganizationInput = {
    where: NeedWhereUniqueInput
    create: XOR<NeedCreateWithoutOrganizationInput, NeedUncheckedCreateWithoutOrganizationInput>
  }

  export type NeedCreateManyOrganizationInputEnvelope = {
    data: NeedCreateManyOrganizationInput | NeedCreateManyOrganizationInput[]
  }

  export type MeetingCreateWithoutOrganizationInput = {
    id?: string
    title: string
    notes?: string
    participants?: string | null
    status?: string
    extractedActions?: string | null
    tasksCreated?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    creator?: UserCreateNestedOneWithoutMeetingsCreatedInput
  }

  export type MeetingUncheckedCreateWithoutOrganizationInput = {
    id?: string
    creatorId?: number | null
    title: string
    notes?: string
    participants?: string | null
    status?: string
    extractedActions?: string | null
    tasksCreated?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type MeetingCreateOrConnectWithoutOrganizationInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutOrganizationInput, MeetingUncheckedCreateWithoutOrganizationInput>
  }

  export type MeetingCreateManyOrganizationInputEnvelope = {
    data: MeetingCreateManyOrganizationInput | MeetingCreateManyOrganizationInput[]
  }

  export type EmailAccountCreateWithoutOrganizationInput = {
    id?: string
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    owner?: UserCreateNestedOneWithoutEmailAccountsInput
    selections?: EmailActiveSelectionCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountUncheckedCreateWithoutOrganizationInput = {
    id?: string
    userId?: number | null
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    selections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountCreateOrConnectWithoutOrganizationInput = {
    where: EmailAccountWhereUniqueInput
    create: XOR<EmailAccountCreateWithoutOrganizationInput, EmailAccountUncheckedCreateWithoutOrganizationInput>
  }

  export type EmailAccountCreateManyOrganizationInputEnvelope = {
    data: EmailAccountCreateManyOrganizationInput | EmailAccountCreateManyOrganizationInput[]
  }

  export type EmailActiveSelectionCreateWithoutOrganizationInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailSelectionsInput
    account: EmailAccountCreateNestedOneWithoutSelectionsInput
  }

  export type EmailActiveSelectionUncheckedCreateWithoutOrganizationInput = {
    id?: number
    userId: number
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailActiveSelectionCreateOrConnectWithoutOrganizationInput = {
    where: EmailActiveSelectionWhereUniqueInput
    create: XOR<EmailActiveSelectionCreateWithoutOrganizationInput, EmailActiveSelectionUncheckedCreateWithoutOrganizationInput>
  }

  export type EmailActiveSelectionCreateManyOrganizationInputEnvelope = {
    data: EmailActiveSelectionCreateManyOrganizationInput | EmailActiveSelectionCreateManyOrganizationInput[]
  }

  export type UserUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
    create: XOR<UserCreateWithoutOrganizationInput, UserUncheckedCreateWithoutOrganizationInput>
  }

  export type UserUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutOrganizationInput, UserUncheckedUpdateWithoutOrganizationInput>
  }

  export type UserUpdateManyWithWhereWithoutOrganizationInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: IntFilter<"User"> | number
    organizationId?: IntFilter<"User"> | number
    externalId?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    displayName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    pinHash?: StringNullableFilter<"User"> | string | null
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    syncId?: StringNullableFilter<"User"> | string | null
    lastSynced?: DateTimeNullableFilter<"User"> | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutOrganizationInput, MessageUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MessageCreateWithoutOrganizationInput, MessageUncheckedCreateWithoutOrganizationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutOrganizationInput, MessageUncheckedUpdateWithoutOrganizationInput>
  }

  export type MessageUpdateManyWithWhereWithoutOrganizationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: IntFilter<"Message"> | number
    organizationId?: IntFilter<"Message"> | number
    userId?: IntNullableFilter<"Message"> | number | null
    kind?: StringFilter<"Message"> | string
    channel?: StringNullableFilter<"Message"> | string | null
    content?: StringFilter<"Message"> | string
    metadata?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    syncId?: StringNullableFilter<"Message"> | string | null
    lastSynced?: DateTimeNullableFilter<"Message"> | Date | string | null
    needsSync?: BoolFilter<"Message"> | boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutOrganizationInput, TaskUncheckedUpdateWithoutOrganizationInput>
    create: XOR<TaskCreateWithoutOrganizationInput, TaskUncheckedCreateWithoutOrganizationInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutOrganizationInput, TaskUncheckedUpdateWithoutOrganizationInput>
  }

  export type TaskUpdateManyWithWhereWithoutOrganizationInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: IntFilter<"Task"> | number
    organizationId?: IntFilter<"Task"> | number
    userId?: IntNullableFilter<"Task"> | number | null
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: StringFilter<"Task"> | string
    dueAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    metadata?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    syncId?: StringNullableFilter<"Task"> | string | null
    lastSynced?: DateTimeNullableFilter<"Task"> | Date | string | null
    needsSync?: BoolFilter<"Task"> | boolean
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutOrganizationInput, ActivityLogUncheckedUpdateWithoutOrganizationInput>
    create: XOR<ActivityLogCreateWithoutOrganizationInput, ActivityLogUncheckedCreateWithoutOrganizationInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutOrganizationInput, ActivityLogUncheckedUpdateWithoutOrganizationInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutOrganizationInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: IntFilter<"ActivityLog"> | number
    organizationId?: IntFilter<"ActivityLog"> | number
    userId?: IntNullableFilter<"ActivityLog"> | number | null
    subjectType?: StringFilter<"ActivityLog"> | string
    subjectId?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringFilter<"ActivityLog"> | string
    detail?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    syncId?: StringNullableFilter<"ActivityLog"> | string | null
    needsSync?: BoolFilter<"ActivityLog"> | boolean
  }

  export type RequisitionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: RequisitionWhereUniqueInput
    update: XOR<RequisitionUpdateWithoutOrganizationInput, RequisitionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<RequisitionCreateWithoutOrganizationInput, RequisitionUncheckedCreateWithoutOrganizationInput>
  }

  export type RequisitionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: RequisitionWhereUniqueInput
    data: XOR<RequisitionUpdateWithoutOrganizationInput, RequisitionUncheckedUpdateWithoutOrganizationInput>
  }

  export type RequisitionUpdateManyWithWhereWithoutOrganizationInput = {
    where: RequisitionScalarWhereInput
    data: XOR<RequisitionUpdateManyMutationInput, RequisitionUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type RequisitionScalarWhereInput = {
    AND?: RequisitionScalarWhereInput | RequisitionScalarWhereInput[]
    OR?: RequisitionScalarWhereInput[]
    NOT?: RequisitionScalarWhereInput | RequisitionScalarWhereInput[]
    id?: StringFilter<"Requisition"> | string
    title?: StringFilter<"Requisition"> | string
    description?: StringFilter<"Requisition"> | string
    category?: StringFilter<"Requisition"> | string
    priority?: StringFilter<"Requisition"> | string
    budget?: FloatFilter<"Requisition"> | number
    justification?: StringFilter<"Requisition"> | string
    status?: StringFilter<"Requisition"> | string
    requesterId?: IntNullableFilter<"Requisition"> | number | null
    organizationId?: IntFilter<"Requisition"> | number
    approvedAt?: DateTimeNullableFilter<"Requisition"> | Date | string | null
    createdAt?: DateTimeFilter<"Requisition"> | Date | string
    updatedAt?: DateTimeFilter<"Requisition"> | Date | string
    syncId?: StringNullableFilter<"Requisition"> | string | null
    lastSynced?: DateTimeNullableFilter<"Requisition"> | Date | string | null
    needsSync?: BoolFilter<"Requisition"> | boolean
  }

  export type NeedUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: NeedWhereUniqueInput
    update: XOR<NeedUpdateWithoutOrganizationInput, NeedUncheckedUpdateWithoutOrganizationInput>
    create: XOR<NeedCreateWithoutOrganizationInput, NeedUncheckedCreateWithoutOrganizationInput>
  }

  export type NeedUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: NeedWhereUniqueInput
    data: XOR<NeedUpdateWithoutOrganizationInput, NeedUncheckedUpdateWithoutOrganizationInput>
  }

  export type NeedUpdateManyWithWhereWithoutOrganizationInput = {
    where: NeedScalarWhereInput
    data: XOR<NeedUpdateManyMutationInput, NeedUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type NeedScalarWhereInput = {
    AND?: NeedScalarWhereInput | NeedScalarWhereInput[]
    OR?: NeedScalarWhereInput[]
    NOT?: NeedScalarWhereInput | NeedScalarWhereInput[]
    id?: StringFilter<"Need"> | string
    title?: StringFilter<"Need"> | string
    description?: StringFilter<"Need"> | string
    category?: StringFilter<"Need"> | string
    priority?: StringFilter<"Need"> | string
    budget?: FloatFilter<"Need"> | number
    justification?: StringNullableFilter<"Need"> | string | null
    status?: StringFilter<"Need"> | string
    requesterId?: IntNullableFilter<"Need"> | number | null
    requesterName?: StringNullableFilter<"Need"> | string | null
    organizationId?: IntFilter<"Need"> | number
    createdAt?: DateTimeFilter<"Need"> | Date | string
    updatedAt?: DateTimeFilter<"Need"> | Date | string
    syncId?: StringNullableFilter<"Need"> | string | null
    lastSynced?: DateTimeNullableFilter<"Need"> | Date | string | null
    needsSync?: BoolFilter<"Need"> | boolean
  }

  export type MeetingUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutOrganizationInput, MeetingUncheckedUpdateWithoutOrganizationInput>
    create: XOR<MeetingCreateWithoutOrganizationInput, MeetingUncheckedCreateWithoutOrganizationInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutOrganizationInput, MeetingUncheckedUpdateWithoutOrganizationInput>
  }

  export type MeetingUpdateManyWithWhereWithoutOrganizationInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type MeetingScalarWhereInput = {
    AND?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    OR?: MeetingScalarWhereInput[]
    NOT?: MeetingScalarWhereInput | MeetingScalarWhereInput[]
    id?: StringFilter<"Meeting"> | string
    organizationId?: IntFilter<"Meeting"> | number
    creatorId?: IntNullableFilter<"Meeting"> | number | null
    title?: StringFilter<"Meeting"> | string
    notes?: StringFilter<"Meeting"> | string
    participants?: StringNullableFilter<"Meeting"> | string | null
    status?: StringFilter<"Meeting"> | string
    extractedActions?: StringNullableFilter<"Meeting"> | string | null
    tasksCreated?: StringNullableFilter<"Meeting"> | string | null
    createdAt?: DateTimeFilter<"Meeting"> | Date | string
    updatedAt?: DateTimeFilter<"Meeting"> | Date | string
    syncId?: StringNullableFilter<"Meeting"> | string | null
    lastSynced?: DateTimeNullableFilter<"Meeting"> | Date | string | null
    needsSync?: BoolFilter<"Meeting"> | boolean
  }

  export type EmailAccountUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: EmailAccountWhereUniqueInput
    update: XOR<EmailAccountUpdateWithoutOrganizationInput, EmailAccountUncheckedUpdateWithoutOrganizationInput>
    create: XOR<EmailAccountCreateWithoutOrganizationInput, EmailAccountUncheckedCreateWithoutOrganizationInput>
  }

  export type EmailAccountUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: EmailAccountWhereUniqueInput
    data: XOR<EmailAccountUpdateWithoutOrganizationInput, EmailAccountUncheckedUpdateWithoutOrganizationInput>
  }

  export type EmailAccountUpdateManyWithWhereWithoutOrganizationInput = {
    where: EmailAccountScalarWhereInput
    data: XOR<EmailAccountUpdateManyMutationInput, EmailAccountUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type EmailAccountScalarWhereInput = {
    AND?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
    OR?: EmailAccountScalarWhereInput[]
    NOT?: EmailAccountScalarWhereInput | EmailAccountScalarWhereInput[]
    id?: StringFilter<"EmailAccount"> | string
    organizationId?: IntFilter<"EmailAccount"> | number
    userId?: IntNullableFilter<"EmailAccount"> | number | null
    email?: StringFilter<"EmailAccount"> | string
    providerId?: StringFilter<"EmailAccount"> | string
    providerName?: StringNullableFilter<"EmailAccount"> | string | null
    provider?: StringNullableFilter<"EmailAccount"> | string | null
    credentials?: StringNullableFilter<"EmailAccount"> | string | null
    isConnected?: BoolFilter<"EmailAccount"> | boolean
    unreadCount?: IntFilter<"EmailAccount"> | number
    connectedAt?: DateTimeNullableFilter<"EmailAccount"> | Date | string | null
    lastSync?: DateTimeNullableFilter<"EmailAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"EmailAccount"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAccount"> | Date | string
    syncId?: StringNullableFilter<"EmailAccount"> | string | null
    needsSync?: BoolFilter<"EmailAccount"> | boolean
  }

  export type EmailActiveSelectionUpsertWithWhereUniqueWithoutOrganizationInput = {
    where: EmailActiveSelectionWhereUniqueInput
    update: XOR<EmailActiveSelectionUpdateWithoutOrganizationInput, EmailActiveSelectionUncheckedUpdateWithoutOrganizationInput>
    create: XOR<EmailActiveSelectionCreateWithoutOrganizationInput, EmailActiveSelectionUncheckedCreateWithoutOrganizationInput>
  }

  export type EmailActiveSelectionUpdateWithWhereUniqueWithoutOrganizationInput = {
    where: EmailActiveSelectionWhereUniqueInput
    data: XOR<EmailActiveSelectionUpdateWithoutOrganizationInput, EmailActiveSelectionUncheckedUpdateWithoutOrganizationInput>
  }

  export type EmailActiveSelectionUpdateManyWithWhereWithoutOrganizationInput = {
    where: EmailActiveSelectionScalarWhereInput
    data: XOR<EmailActiveSelectionUpdateManyMutationInput, EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationInput>
  }

  export type EmailActiveSelectionScalarWhereInput = {
    AND?: EmailActiveSelectionScalarWhereInput | EmailActiveSelectionScalarWhereInput[]
    OR?: EmailActiveSelectionScalarWhereInput[]
    NOT?: EmailActiveSelectionScalarWhereInput | EmailActiveSelectionScalarWhereInput[]
    id?: IntFilter<"EmailActiveSelection"> | number
    organizationId?: IntFilter<"EmailActiveSelection"> | number
    userId?: IntFilter<"EmailActiveSelection"> | number
    accountId?: StringFilter<"EmailActiveSelection"> | string
    createdAt?: DateTimeFilter<"EmailActiveSelection"> | Date | string
    updatedAt?: DateTimeFilter<"EmailActiveSelection"> | Date | string
  }

  export type OrganizationCreateWithoutUsersInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageCreateNestedManyWithoutOrganizationInput
    tasks?: TaskCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionCreateNestedManyWithoutOrganizationInput
    needs?: NeedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutUsersInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput
    tasks?: TaskUncheckedCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionUncheckedCreateNestedManyWithoutOrganizationInput
    needs?: NeedUncheckedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutUsersInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
  }

  export type MessageCreateWithoutUserInput = {
    kind?: string
    channel?: string | null
    content: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutUserInput = {
    id?: number
    organizationId: number
    kind?: string
    channel?: string | null
    content: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type MessageCreateOrConnectWithoutUserInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateManyUserInputEnvelope = {
    data: MessageCreateManyUserInput | MessageCreateManyUserInput[]
  }

  export type TaskCreateWithoutUserInput = {
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutTasksInput
    runs?: TaskRunCreateNestedManyWithoutTaskInput
  }

  export type TaskUncheckedCreateWithoutUserInput = {
    id?: number
    organizationId: number
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    runs?: TaskRunUncheckedCreateNestedManyWithoutTaskInput
  }

  export type TaskCreateOrConnectWithoutUserInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskCreateManyUserInputEnvelope = {
    data: TaskCreateManyUserInput | TaskCreateManyUserInput[]
  }

  export type ActivityLogCreateWithoutUserInput = {
    subjectType: string
    subjectId?: number | null
    action: string
    detail?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: number
    organizationId: number
    subjectType: string
    subjectId?: number | null
    action: string
    detail?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
  }

  export type RequisitionCreateWithoutRequesterInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutRequisitionsInput
    workflow?: WorkflowStepCreateNestedManyWithoutRequisitionInput
  }

  export type RequisitionUncheckedCreateWithoutRequesterInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    organizationId: number
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    workflow?: WorkflowStepUncheckedCreateNestedManyWithoutRequisitionInput
  }

  export type RequisitionCreateOrConnectWithoutRequesterInput = {
    where: RequisitionWhereUniqueInput
    create: XOR<RequisitionCreateWithoutRequesterInput, RequisitionUncheckedCreateWithoutRequesterInput>
  }

  export type RequisitionCreateManyRequesterInputEnvelope = {
    data: RequisitionCreateManyRequesterInput | RequisitionCreateManyRequesterInput[]
  }

  export type WorkflowStepCreateWithoutReviewerInput = {
    id?: string
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
    requisition: RequisitionCreateNestedOneWithoutWorkflowInput
  }

  export type WorkflowStepUncheckedCreateWithoutReviewerInput = {
    id?: string
    requisitionId: string
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type WorkflowStepCreateOrConnectWithoutReviewerInput = {
    where: WorkflowStepWhereUniqueInput
    create: XOR<WorkflowStepCreateWithoutReviewerInput, WorkflowStepUncheckedCreateWithoutReviewerInput>
  }

  export type WorkflowStepCreateManyReviewerInputEnvelope = {
    data: WorkflowStepCreateManyReviewerInput | WorkflowStepCreateManyReviewerInput[]
  }

  export type NeedCreateWithoutRequesterInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutNeedsInput
    workflow?: NeedWorkflowStepCreateNestedManyWithoutNeedInput
    attachments?: NeedAttachmentCreateNestedManyWithoutNeedInput
  }

  export type NeedUncheckedCreateWithoutRequesterInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterName?: string | null
    organizationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    workflow?: NeedWorkflowStepUncheckedCreateNestedManyWithoutNeedInput
    attachments?: NeedAttachmentUncheckedCreateNestedManyWithoutNeedInput
  }

  export type NeedCreateOrConnectWithoutRequesterInput = {
    where: NeedWhereUniqueInput
    create: XOR<NeedCreateWithoutRequesterInput, NeedUncheckedCreateWithoutRequesterInput>
  }

  export type NeedCreateManyRequesterInputEnvelope = {
    data: NeedCreateManyRequesterInput | NeedCreateManyRequesterInput[]
  }

  export type NeedWorkflowStepCreateWithoutReviewerInput = {
    id?: string
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
    need: NeedCreateNestedOneWithoutWorkflowInput
  }

  export type NeedWorkflowStepUncheckedCreateWithoutReviewerInput = {
    id?: string
    needId: string
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedWorkflowStepCreateOrConnectWithoutReviewerInput = {
    where: NeedWorkflowStepWhereUniqueInput
    create: XOR<NeedWorkflowStepCreateWithoutReviewerInput, NeedWorkflowStepUncheckedCreateWithoutReviewerInput>
  }

  export type NeedWorkflowStepCreateManyReviewerInputEnvelope = {
    data: NeedWorkflowStepCreateManyReviewerInput | NeedWorkflowStepCreateManyReviewerInput[]
  }

  export type MeetingCreateWithoutCreatorInput = {
    id?: string
    title: string
    notes?: string
    participants?: string | null
    status?: string
    extractedActions?: string | null
    tasksCreated?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutMeetingsInput
  }

  export type MeetingUncheckedCreateWithoutCreatorInput = {
    id?: string
    organizationId: number
    title: string
    notes?: string
    participants?: string | null
    status?: string
    extractedActions?: string | null
    tasksCreated?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type MeetingCreateOrConnectWithoutCreatorInput = {
    where: MeetingWhereUniqueInput
    create: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput>
  }

  export type MeetingCreateManyCreatorInputEnvelope = {
    data: MeetingCreateManyCreatorInput | MeetingCreateManyCreatorInput[]
  }

  export type EmailAccountCreateWithoutOwnerInput = {
    id?: string
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutEmailAccountsInput
    selections?: EmailActiveSelectionCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountUncheckedCreateWithoutOwnerInput = {
    id?: string
    organizationId: number
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    selections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type EmailAccountCreateOrConnectWithoutOwnerInput = {
    where: EmailAccountWhereUniqueInput
    create: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput>
  }

  export type EmailAccountCreateManyOwnerInputEnvelope = {
    data: EmailAccountCreateManyOwnerInput | EmailAccountCreateManyOwnerInput[]
  }

  export type EmailActiveSelectionCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutEmailSelectionsInput
    account: EmailAccountCreateNestedOneWithoutSelectionsInput
  }

  export type EmailActiveSelectionUncheckedCreateWithoutUserInput = {
    id?: number
    organizationId: number
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailActiveSelectionCreateOrConnectWithoutUserInput = {
    where: EmailActiveSelectionWhereUniqueInput
    create: XOR<EmailActiveSelectionCreateWithoutUserInput, EmailActiveSelectionUncheckedCreateWithoutUserInput>
  }

  export type EmailActiveSelectionCreateManyUserInputEnvelope = {
    data: EmailActiveSelectionCreateManyUserInput | EmailActiveSelectionCreateManyUserInput[]
  }

  export type OrganizationUpsertWithoutUsersInput = {
    update: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
    create: XOR<OrganizationCreateWithoutUsersInput, OrganizationUncheckedCreateWithoutUsersInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutUsersInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutUsersInput, OrganizationUncheckedUpdateWithoutUsersInput>
  }

  export type OrganizationUpdateWithoutUsersInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUncheckedUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUncheckedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
    create: XOR<MessageCreateWithoutUserInput, MessageUncheckedCreateWithoutUserInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutUserInput, MessageUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithWhereWithoutUserInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutUserInput>
  }

  export type TaskUpsertWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
    create: XOR<TaskCreateWithoutUserInput, TaskUncheckedCreateWithoutUserInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutUserInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutUserInput, TaskUncheckedUpdateWithoutUserInput>
  }

  export type TaskUpdateManyWithWhereWithoutUserInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type RequisitionUpsertWithWhereUniqueWithoutRequesterInput = {
    where: RequisitionWhereUniqueInput
    update: XOR<RequisitionUpdateWithoutRequesterInput, RequisitionUncheckedUpdateWithoutRequesterInput>
    create: XOR<RequisitionCreateWithoutRequesterInput, RequisitionUncheckedCreateWithoutRequesterInput>
  }

  export type RequisitionUpdateWithWhereUniqueWithoutRequesterInput = {
    where: RequisitionWhereUniqueInput
    data: XOR<RequisitionUpdateWithoutRequesterInput, RequisitionUncheckedUpdateWithoutRequesterInput>
  }

  export type RequisitionUpdateManyWithWhereWithoutRequesterInput = {
    where: RequisitionScalarWhereInput
    data: XOR<RequisitionUpdateManyMutationInput, RequisitionUncheckedUpdateManyWithoutRequesterInput>
  }

  export type WorkflowStepUpsertWithWhereUniqueWithoutReviewerInput = {
    where: WorkflowStepWhereUniqueInput
    update: XOR<WorkflowStepUpdateWithoutReviewerInput, WorkflowStepUncheckedUpdateWithoutReviewerInput>
    create: XOR<WorkflowStepCreateWithoutReviewerInput, WorkflowStepUncheckedCreateWithoutReviewerInput>
  }

  export type WorkflowStepUpdateWithWhereUniqueWithoutReviewerInput = {
    where: WorkflowStepWhereUniqueInput
    data: XOR<WorkflowStepUpdateWithoutReviewerInput, WorkflowStepUncheckedUpdateWithoutReviewerInput>
  }

  export type WorkflowStepUpdateManyWithWhereWithoutReviewerInput = {
    where: WorkflowStepScalarWhereInput
    data: XOR<WorkflowStepUpdateManyMutationInput, WorkflowStepUncheckedUpdateManyWithoutReviewerInput>
  }

  export type WorkflowStepScalarWhereInput = {
    AND?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
    OR?: WorkflowStepScalarWhereInput[]
    NOT?: WorkflowStepScalarWhereInput | WorkflowStepScalarWhereInput[]
    id?: StringFilter<"WorkflowStep"> | string
    requisitionId?: StringFilter<"WorkflowStep"> | string
    reviewerId?: IntNullableFilter<"WorkflowStep"> | number | null
    reviewerName?: StringFilter<"WorkflowStep"> | string
    reviewerLevel?: IntFilter<"WorkflowStep"> | number
    action?: StringFilter<"WorkflowStep"> | string
    isRequired?: BoolFilter<"WorkflowStep"> | boolean
    isCompleted?: BoolFilter<"WorkflowStep"> | boolean
    comment?: StringNullableFilter<"WorkflowStep"> | string | null
    createdAt?: DateTimeFilter<"WorkflowStep"> | Date | string
    completedAt?: DateTimeNullableFilter<"WorkflowStep"> | Date | string | null
    syncId?: StringNullableFilter<"WorkflowStep"> | string | null
    needsSync?: BoolFilter<"WorkflowStep"> | boolean
  }

  export type NeedUpsertWithWhereUniqueWithoutRequesterInput = {
    where: NeedWhereUniqueInput
    update: XOR<NeedUpdateWithoutRequesterInput, NeedUncheckedUpdateWithoutRequesterInput>
    create: XOR<NeedCreateWithoutRequesterInput, NeedUncheckedCreateWithoutRequesterInput>
  }

  export type NeedUpdateWithWhereUniqueWithoutRequesterInput = {
    where: NeedWhereUniqueInput
    data: XOR<NeedUpdateWithoutRequesterInput, NeedUncheckedUpdateWithoutRequesterInput>
  }

  export type NeedUpdateManyWithWhereWithoutRequesterInput = {
    where: NeedScalarWhereInput
    data: XOR<NeedUpdateManyMutationInput, NeedUncheckedUpdateManyWithoutRequesterInput>
  }

  export type NeedWorkflowStepUpsertWithWhereUniqueWithoutReviewerInput = {
    where: NeedWorkflowStepWhereUniqueInput
    update: XOR<NeedWorkflowStepUpdateWithoutReviewerInput, NeedWorkflowStepUncheckedUpdateWithoutReviewerInput>
    create: XOR<NeedWorkflowStepCreateWithoutReviewerInput, NeedWorkflowStepUncheckedCreateWithoutReviewerInput>
  }

  export type NeedWorkflowStepUpdateWithWhereUniqueWithoutReviewerInput = {
    where: NeedWorkflowStepWhereUniqueInput
    data: XOR<NeedWorkflowStepUpdateWithoutReviewerInput, NeedWorkflowStepUncheckedUpdateWithoutReviewerInput>
  }

  export type NeedWorkflowStepUpdateManyWithWhereWithoutReviewerInput = {
    where: NeedWorkflowStepScalarWhereInput
    data: XOR<NeedWorkflowStepUpdateManyMutationInput, NeedWorkflowStepUncheckedUpdateManyWithoutReviewerInput>
  }

  export type NeedWorkflowStepScalarWhereInput = {
    AND?: NeedWorkflowStepScalarWhereInput | NeedWorkflowStepScalarWhereInput[]
    OR?: NeedWorkflowStepScalarWhereInput[]
    NOT?: NeedWorkflowStepScalarWhereInput | NeedWorkflowStepScalarWhereInput[]
    id?: StringFilter<"NeedWorkflowStep"> | string
    needId?: StringFilter<"NeedWorkflowStep"> | string
    reviewerId?: IntNullableFilter<"NeedWorkflowStep"> | number | null
    reviewerName?: StringFilter<"NeedWorkflowStep"> | string
    reviewerLevel?: IntFilter<"NeedWorkflowStep"> | number
    action?: StringFilter<"NeedWorkflowStep"> | string
    isRequired?: BoolFilter<"NeedWorkflowStep"> | boolean
    isCompleted?: BoolFilter<"NeedWorkflowStep"> | boolean
    comment?: StringNullableFilter<"NeedWorkflowStep"> | string | null
    createdAt?: DateTimeFilter<"NeedWorkflowStep"> | Date | string
    completedAt?: DateTimeNullableFilter<"NeedWorkflowStep"> | Date | string | null
    syncId?: StringNullableFilter<"NeedWorkflowStep"> | string | null
    needsSync?: BoolFilter<"NeedWorkflowStep"> | boolean
  }

  export type MeetingUpsertWithWhereUniqueWithoutCreatorInput = {
    where: MeetingWhereUniqueInput
    update: XOR<MeetingUpdateWithoutCreatorInput, MeetingUncheckedUpdateWithoutCreatorInput>
    create: XOR<MeetingCreateWithoutCreatorInput, MeetingUncheckedCreateWithoutCreatorInput>
  }

  export type MeetingUpdateWithWhereUniqueWithoutCreatorInput = {
    where: MeetingWhereUniqueInput
    data: XOR<MeetingUpdateWithoutCreatorInput, MeetingUncheckedUpdateWithoutCreatorInput>
  }

  export type MeetingUpdateManyWithWhereWithoutCreatorInput = {
    where: MeetingScalarWhereInput
    data: XOR<MeetingUpdateManyMutationInput, MeetingUncheckedUpdateManyWithoutCreatorInput>
  }

  export type EmailAccountUpsertWithWhereUniqueWithoutOwnerInput = {
    where: EmailAccountWhereUniqueInput
    update: XOR<EmailAccountUpdateWithoutOwnerInput, EmailAccountUncheckedUpdateWithoutOwnerInput>
    create: XOR<EmailAccountCreateWithoutOwnerInput, EmailAccountUncheckedCreateWithoutOwnerInput>
  }

  export type EmailAccountUpdateWithWhereUniqueWithoutOwnerInput = {
    where: EmailAccountWhereUniqueInput
    data: XOR<EmailAccountUpdateWithoutOwnerInput, EmailAccountUncheckedUpdateWithoutOwnerInput>
  }

  export type EmailAccountUpdateManyWithWhereWithoutOwnerInput = {
    where: EmailAccountScalarWhereInput
    data: XOR<EmailAccountUpdateManyMutationInput, EmailAccountUncheckedUpdateManyWithoutOwnerInput>
  }

  export type EmailActiveSelectionUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailActiveSelectionWhereUniqueInput
    update: XOR<EmailActiveSelectionUpdateWithoutUserInput, EmailActiveSelectionUncheckedUpdateWithoutUserInput>
    create: XOR<EmailActiveSelectionCreateWithoutUserInput, EmailActiveSelectionUncheckedCreateWithoutUserInput>
  }

  export type EmailActiveSelectionUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailActiveSelectionWhereUniqueInput
    data: XOR<EmailActiveSelectionUpdateWithoutUserInput, EmailActiveSelectionUncheckedUpdateWithoutUserInput>
  }

  export type EmailActiveSelectionUpdateManyWithWhereWithoutUserInput = {
    where: EmailActiveSelectionScalarWhereInput
    data: XOR<EmailActiveSelectionUpdateManyMutationInput, EmailActiveSelectionUncheckedUpdateManyWithoutUserInput>
  }

  export type OrganizationCreateWithoutMessagesInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserCreateNestedManyWithoutOrganizationInput
    tasks?: TaskCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionCreateNestedManyWithoutOrganizationInput
    needs?: NeedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMessagesInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    tasks?: TaskUncheckedCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionUncheckedCreateNestedManyWithoutOrganizationInput
    needs?: NeedUncheckedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMessagesInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMessagesInput, OrganizationUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type OrganizationUpsertWithoutMessagesInput = {
    update: XOR<OrganizationUpdateWithoutMessagesInput, OrganizationUncheckedUpdateWithoutMessagesInput>
    create: XOR<OrganizationCreateWithoutMessagesInput, OrganizationUncheckedCreateWithoutMessagesInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMessagesInput, OrganizationUncheckedUpdateWithoutMessagesInput>
  }

  export type OrganizationUpdateWithoutMessagesInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUncheckedUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUncheckedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutTasksInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserCreateNestedManyWithoutOrganizationInput
    messages?: MessageCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionCreateNestedManyWithoutOrganizationInput
    needs?: NeedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutTasksInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionUncheckedCreateNestedManyWithoutOrganizationInput
    needs?: NeedUncheckedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutTasksInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutTasksInput, OrganizationUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutTasksInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type TaskRunCreateWithoutTaskInput = {
    runType?: string
    result?: string
    message?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type TaskRunUncheckedCreateWithoutTaskInput = {
    id?: number
    runType?: string
    result?: string
    message?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type TaskRunCreateOrConnectWithoutTaskInput = {
    where: TaskRunWhereUniqueInput
    create: XOR<TaskRunCreateWithoutTaskInput, TaskRunUncheckedCreateWithoutTaskInput>
  }

  export type TaskRunCreateManyTaskInputEnvelope = {
    data: TaskRunCreateManyTaskInput | TaskRunCreateManyTaskInput[]
  }

  export type OrganizationUpsertWithoutTasksInput = {
    update: XOR<OrganizationUpdateWithoutTasksInput, OrganizationUncheckedUpdateWithoutTasksInput>
    create: XOR<OrganizationCreateWithoutTasksInput, OrganizationUncheckedCreateWithoutTasksInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutTasksInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutTasksInput, OrganizationUncheckedUpdateWithoutTasksInput>
  }

  export type OrganizationUpdateWithoutTasksInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUncheckedUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUncheckedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TaskRunUpsertWithWhereUniqueWithoutTaskInput = {
    where: TaskRunWhereUniqueInput
    update: XOR<TaskRunUpdateWithoutTaskInput, TaskRunUncheckedUpdateWithoutTaskInput>
    create: XOR<TaskRunCreateWithoutTaskInput, TaskRunUncheckedCreateWithoutTaskInput>
  }

  export type TaskRunUpdateWithWhereUniqueWithoutTaskInput = {
    where: TaskRunWhereUniqueInput
    data: XOR<TaskRunUpdateWithoutTaskInput, TaskRunUncheckedUpdateWithoutTaskInput>
  }

  export type TaskRunUpdateManyWithWhereWithoutTaskInput = {
    where: TaskRunScalarWhereInput
    data: XOR<TaskRunUpdateManyMutationInput, TaskRunUncheckedUpdateManyWithoutTaskInput>
  }

  export type TaskRunScalarWhereInput = {
    AND?: TaskRunScalarWhereInput | TaskRunScalarWhereInput[]
    OR?: TaskRunScalarWhereInput[]
    NOT?: TaskRunScalarWhereInput | TaskRunScalarWhereInput[]
    id?: IntFilter<"TaskRun"> | number
    taskId?: IntFilter<"TaskRun"> | number
    runType?: StringFilter<"TaskRun"> | string
    result?: StringFilter<"TaskRun"> | string
    message?: StringNullableFilter<"TaskRun"> | string | null
    createdAt?: DateTimeFilter<"TaskRun"> | Date | string
    syncId?: StringNullableFilter<"TaskRun"> | string | null
    needsSync?: BoolFilter<"TaskRun"> | boolean
  }

  export type TaskCreateWithoutRunsInput = {
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutTasksInput
    user?: UserCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutRunsInput = {
    id?: number
    organizationId: number
    userId?: number | null
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type TaskCreateOrConnectWithoutRunsInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutRunsInput, TaskUncheckedCreateWithoutRunsInput>
  }

  export type TaskUpsertWithoutRunsInput = {
    update: XOR<TaskUpdateWithoutRunsInput, TaskUncheckedUpdateWithoutRunsInput>
    create: XOR<TaskCreateWithoutRunsInput, TaskUncheckedCreateWithoutRunsInput>
    where?: TaskWhereInput
  }

  export type TaskUpdateToOneWithWhereWithoutRunsInput = {
    where?: TaskWhereInput
    data: XOR<TaskUpdateWithoutRunsInput, TaskUncheckedUpdateWithoutRunsInput>
  }

  export type TaskUpdateWithoutRunsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutTasksNestedInput
    user?: UserUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutRunsInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganizationCreateWithoutActivityLogsInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserCreateNestedManyWithoutOrganizationInput
    messages?: MessageCreateNestedManyWithoutOrganizationInput
    tasks?: TaskCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionCreateNestedManyWithoutOrganizationInput
    needs?: NeedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutActivityLogsInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput
    tasks?: TaskUncheckedCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionUncheckedCreateNestedManyWithoutOrganizationInput
    needs?: NeedUncheckedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutActivityLogsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutActivityLogsInput, OrganizationUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserCreateWithoutActivityLogsInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type OrganizationUpsertWithoutActivityLogsInput = {
    update: XOR<OrganizationUpdateWithoutActivityLogsInput, OrganizationUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<OrganizationCreateWithoutActivityLogsInput, OrganizationUncheckedCreateWithoutActivityLogsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutActivityLogsInput, OrganizationUncheckedUpdateWithoutActivityLogsInput>
  }

  export type OrganizationUpdateWithoutActivityLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutActivityLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUncheckedUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUncheckedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRequisitionsRequestedInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRequisitionsRequestedInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRequisitionsRequestedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRequisitionsRequestedInput, UserUncheckedCreateWithoutRequisitionsRequestedInput>
  }

  export type OrganizationCreateWithoutRequisitionsInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserCreateNestedManyWithoutOrganizationInput
    messages?: MessageCreateNestedManyWithoutOrganizationInput
    tasks?: TaskCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogCreateNestedManyWithoutOrganizationInput
    needs?: NeedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutRequisitionsInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput
    tasks?: TaskUncheckedCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    needs?: NeedUncheckedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutRequisitionsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutRequisitionsInput, OrganizationUncheckedCreateWithoutRequisitionsInput>
  }

  export type WorkflowStepCreateWithoutRequisitionInput = {
    id?: string
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
    reviewer?: UserCreateNestedOneWithoutWorkflowStepsReviewedInput
  }

  export type WorkflowStepUncheckedCreateWithoutRequisitionInput = {
    id?: string
    reviewerId?: number | null
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type WorkflowStepCreateOrConnectWithoutRequisitionInput = {
    where: WorkflowStepWhereUniqueInput
    create: XOR<WorkflowStepCreateWithoutRequisitionInput, WorkflowStepUncheckedCreateWithoutRequisitionInput>
  }

  export type WorkflowStepCreateManyRequisitionInputEnvelope = {
    data: WorkflowStepCreateManyRequisitionInput | WorkflowStepCreateManyRequisitionInput[]
  }

  export type UserUpsertWithoutRequisitionsRequestedInput = {
    update: XOR<UserUpdateWithoutRequisitionsRequestedInput, UserUncheckedUpdateWithoutRequisitionsRequestedInput>
    create: XOR<UserCreateWithoutRequisitionsRequestedInput, UserUncheckedCreateWithoutRequisitionsRequestedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRequisitionsRequestedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRequisitionsRequestedInput, UserUncheckedUpdateWithoutRequisitionsRequestedInput>
  }

  export type UserUpdateWithoutRequisitionsRequestedInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRequisitionsRequestedInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutRequisitionsInput = {
    update: XOR<OrganizationUpdateWithoutRequisitionsInput, OrganizationUncheckedUpdateWithoutRequisitionsInput>
    create: XOR<OrganizationCreateWithoutRequisitionsInput, OrganizationUncheckedCreateWithoutRequisitionsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutRequisitionsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutRequisitionsInput, OrganizationUncheckedUpdateWithoutRequisitionsInput>
  }

  export type OrganizationUpdateWithoutRequisitionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutRequisitionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUncheckedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type WorkflowStepUpsertWithWhereUniqueWithoutRequisitionInput = {
    where: WorkflowStepWhereUniqueInput
    update: XOR<WorkflowStepUpdateWithoutRequisitionInput, WorkflowStepUncheckedUpdateWithoutRequisitionInput>
    create: XOR<WorkflowStepCreateWithoutRequisitionInput, WorkflowStepUncheckedCreateWithoutRequisitionInput>
  }

  export type WorkflowStepUpdateWithWhereUniqueWithoutRequisitionInput = {
    where: WorkflowStepWhereUniqueInput
    data: XOR<WorkflowStepUpdateWithoutRequisitionInput, WorkflowStepUncheckedUpdateWithoutRequisitionInput>
  }

  export type WorkflowStepUpdateManyWithWhereWithoutRequisitionInput = {
    where: WorkflowStepScalarWhereInput
    data: XOR<WorkflowStepUpdateManyMutationInput, WorkflowStepUncheckedUpdateManyWithoutRequisitionInput>
  }

  export type RequisitionCreateWithoutWorkflowInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    requester?: UserCreateNestedOneWithoutRequisitionsRequestedInput
    organization: OrganizationCreateNestedOneWithoutRequisitionsInput
  }

  export type RequisitionUncheckedCreateWithoutWorkflowInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    requesterId?: number | null
    organizationId: number
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type RequisitionCreateOrConnectWithoutWorkflowInput = {
    where: RequisitionWhereUniqueInput
    create: XOR<RequisitionCreateWithoutWorkflowInput, RequisitionUncheckedCreateWithoutWorkflowInput>
  }

  export type UserCreateWithoutWorkflowStepsReviewedInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkflowStepsReviewedInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkflowStepsReviewedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkflowStepsReviewedInput, UserUncheckedCreateWithoutWorkflowStepsReviewedInput>
  }

  export type RequisitionUpsertWithoutWorkflowInput = {
    update: XOR<RequisitionUpdateWithoutWorkflowInput, RequisitionUncheckedUpdateWithoutWorkflowInput>
    create: XOR<RequisitionCreateWithoutWorkflowInput, RequisitionUncheckedCreateWithoutWorkflowInput>
    where?: RequisitionWhereInput
  }

  export type RequisitionUpdateToOneWithWhereWithoutWorkflowInput = {
    where?: RequisitionWhereInput
    data: XOR<RequisitionUpdateWithoutWorkflowInput, RequisitionUncheckedUpdateWithoutWorkflowInput>
  }

  export type RequisitionUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    requester?: UserUpdateOneWithoutRequisitionsRequestedNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutRequisitionsNestedInput
  }

  export type RequisitionUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    organizationId?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUpsertWithoutWorkflowStepsReviewedInput = {
    update: XOR<UserUpdateWithoutWorkflowStepsReviewedInput, UserUncheckedUpdateWithoutWorkflowStepsReviewedInput>
    create: XOR<UserCreateWithoutWorkflowStepsReviewedInput, UserUncheckedCreateWithoutWorkflowStepsReviewedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkflowStepsReviewedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkflowStepsReviewedInput, UserUncheckedUpdateWithoutWorkflowStepsReviewedInput>
  }

  export type UserUpdateWithoutWorkflowStepsReviewedInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkflowStepsReviewedInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutMeetingsInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserCreateNestedManyWithoutOrganizationInput
    messages?: MessageCreateNestedManyWithoutOrganizationInput
    tasks?: TaskCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionCreateNestedManyWithoutOrganizationInput
    needs?: NeedCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutMeetingsInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput
    tasks?: TaskUncheckedCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionUncheckedCreateNestedManyWithoutOrganizationInput
    needs?: NeedUncheckedCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutMeetingsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutMeetingsInput, OrganizationUncheckedCreateWithoutMeetingsInput>
  }

  export type UserCreateWithoutMeetingsCreatedInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMeetingsCreatedInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMeetingsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMeetingsCreatedInput, UserUncheckedCreateWithoutMeetingsCreatedInput>
  }

  export type OrganizationUpsertWithoutMeetingsInput = {
    update: XOR<OrganizationUpdateWithoutMeetingsInput, OrganizationUncheckedUpdateWithoutMeetingsInput>
    create: XOR<OrganizationCreateWithoutMeetingsInput, OrganizationUncheckedCreateWithoutMeetingsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutMeetingsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutMeetingsInput, OrganizationUncheckedUpdateWithoutMeetingsInput>
  }

  export type OrganizationUpdateWithoutMeetingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutMeetingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUncheckedUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUncheckedUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutMeetingsCreatedInput = {
    update: XOR<UserUpdateWithoutMeetingsCreatedInput, UserUncheckedUpdateWithoutMeetingsCreatedInput>
    create: XOR<UserCreateWithoutMeetingsCreatedInput, UserUncheckedCreateWithoutMeetingsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMeetingsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMeetingsCreatedInput, UserUncheckedUpdateWithoutMeetingsCreatedInput>
  }

  export type UserUpdateWithoutMeetingsCreatedInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMeetingsCreatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationCreateWithoutEmailAccountsInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserCreateNestedManyWithoutOrganizationInput
    messages?: MessageCreateNestedManyWithoutOrganizationInput
    tasks?: TaskCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionCreateNestedManyWithoutOrganizationInput
    needs?: NeedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutEmailAccountsInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput
    tasks?: TaskUncheckedCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionUncheckedCreateNestedManyWithoutOrganizationInput
    needs?: NeedUncheckedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutEmailAccountsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutEmailAccountsInput, OrganizationUncheckedCreateWithoutEmailAccountsInput>
  }

  export type UserCreateWithoutEmailAccountsInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailAccountsInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailAccountsInput, UserUncheckedCreateWithoutEmailAccountsInput>
  }

  export type EmailActiveSelectionCreateWithoutAccountInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    organization: OrganizationCreateNestedOneWithoutEmailSelectionsInput
    user: UserCreateNestedOneWithoutEmailSelectionsInput
  }

  export type EmailActiveSelectionUncheckedCreateWithoutAccountInput = {
    id?: number
    organizationId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailActiveSelectionCreateOrConnectWithoutAccountInput = {
    where: EmailActiveSelectionWhereUniqueInput
    create: XOR<EmailActiveSelectionCreateWithoutAccountInput, EmailActiveSelectionUncheckedCreateWithoutAccountInput>
  }

  export type EmailActiveSelectionCreateManyAccountInputEnvelope = {
    data: EmailActiveSelectionCreateManyAccountInput | EmailActiveSelectionCreateManyAccountInput[]
  }

  export type OrganizationUpsertWithoutEmailAccountsInput = {
    update: XOR<OrganizationUpdateWithoutEmailAccountsInput, OrganizationUncheckedUpdateWithoutEmailAccountsInput>
    create: XOR<OrganizationCreateWithoutEmailAccountsInput, OrganizationUncheckedCreateWithoutEmailAccountsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutEmailAccountsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutEmailAccountsInput, OrganizationUncheckedUpdateWithoutEmailAccountsInput>
  }

  export type OrganizationUpdateWithoutEmailAccountsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutEmailAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUncheckedUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUncheckedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutEmailAccountsInput = {
    update: XOR<UserUpdateWithoutEmailAccountsInput, UserUncheckedUpdateWithoutEmailAccountsInput>
    create: XOR<UserCreateWithoutEmailAccountsInput, UserUncheckedCreateWithoutEmailAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailAccountsInput, UserUncheckedUpdateWithoutEmailAccountsInput>
  }

  export type UserUpdateWithoutEmailAccountsInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailAccountsInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EmailActiveSelectionUpsertWithWhereUniqueWithoutAccountInput = {
    where: EmailActiveSelectionWhereUniqueInput
    update: XOR<EmailActiveSelectionUpdateWithoutAccountInput, EmailActiveSelectionUncheckedUpdateWithoutAccountInput>
    create: XOR<EmailActiveSelectionCreateWithoutAccountInput, EmailActiveSelectionUncheckedCreateWithoutAccountInput>
  }

  export type EmailActiveSelectionUpdateWithWhereUniqueWithoutAccountInput = {
    where: EmailActiveSelectionWhereUniqueInput
    data: XOR<EmailActiveSelectionUpdateWithoutAccountInput, EmailActiveSelectionUncheckedUpdateWithoutAccountInput>
  }

  export type EmailActiveSelectionUpdateManyWithWhereWithoutAccountInput = {
    where: EmailActiveSelectionScalarWhereInput
    data: XOR<EmailActiveSelectionUpdateManyMutationInput, EmailActiveSelectionUncheckedUpdateManyWithoutAccountInput>
  }

  export type OrganizationCreateWithoutEmailSelectionsInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserCreateNestedManyWithoutOrganizationInput
    messages?: MessageCreateNestedManyWithoutOrganizationInput
    tasks?: TaskCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionCreateNestedManyWithoutOrganizationInput
    needs?: NeedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutEmailSelectionsInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput
    tasks?: TaskUncheckedCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionUncheckedCreateNestedManyWithoutOrganizationInput
    needs?: NeedUncheckedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutEmailSelectionsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutEmailSelectionsInput, OrganizationUncheckedCreateWithoutEmailSelectionsInput>
  }

  export type UserCreateWithoutEmailSelectionsInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutEmailSelectionsInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutEmailSelectionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailSelectionsInput, UserUncheckedCreateWithoutEmailSelectionsInput>
  }

  export type EmailAccountCreateWithoutSelectionsInput = {
    id?: string
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    organization: OrganizationCreateNestedOneWithoutEmailAccountsInput
    owner?: UserCreateNestedOneWithoutEmailAccountsInput
  }

  export type EmailAccountUncheckedCreateWithoutSelectionsInput = {
    id?: string
    organizationId: number
    userId?: number | null
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type EmailAccountCreateOrConnectWithoutSelectionsInput = {
    where: EmailAccountWhereUniqueInput
    create: XOR<EmailAccountCreateWithoutSelectionsInput, EmailAccountUncheckedCreateWithoutSelectionsInput>
  }

  export type OrganizationUpsertWithoutEmailSelectionsInput = {
    update: XOR<OrganizationUpdateWithoutEmailSelectionsInput, OrganizationUncheckedUpdateWithoutEmailSelectionsInput>
    create: XOR<OrganizationCreateWithoutEmailSelectionsInput, OrganizationUncheckedCreateWithoutEmailSelectionsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutEmailSelectionsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutEmailSelectionsInput, OrganizationUncheckedUpdateWithoutEmailSelectionsInput>
  }

  export type OrganizationUpdateWithoutEmailSelectionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutEmailSelectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUncheckedUpdateManyWithoutOrganizationNestedInput
    needs?: NeedUncheckedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type UserUpsertWithoutEmailSelectionsInput = {
    update: XOR<UserUpdateWithoutEmailSelectionsInput, UserUncheckedUpdateWithoutEmailSelectionsInput>
    create: XOR<UserCreateWithoutEmailSelectionsInput, UserUncheckedCreateWithoutEmailSelectionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailSelectionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailSelectionsInput, UserUncheckedUpdateWithoutEmailSelectionsInput>
  }

  export type UserUpdateWithoutEmailSelectionsInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailSelectionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type EmailAccountUpsertWithoutSelectionsInput = {
    update: XOR<EmailAccountUpdateWithoutSelectionsInput, EmailAccountUncheckedUpdateWithoutSelectionsInput>
    create: XOR<EmailAccountCreateWithoutSelectionsInput, EmailAccountUncheckedCreateWithoutSelectionsInput>
    where?: EmailAccountWhereInput
  }

  export type EmailAccountUpdateToOneWithWhereWithoutSelectionsInput = {
    where?: EmailAccountWhereInput
    data: XOR<EmailAccountUpdateWithoutSelectionsInput, EmailAccountUncheckedUpdateWithoutSelectionsInput>
  }

  export type EmailAccountUpdateWithoutSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutEmailAccountsNestedInput
    owner?: UserUpdateOneWithoutEmailAccountsNestedInput
  }

  export type EmailAccountUncheckedUpdateWithoutSelectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateWithoutNeedsRequestedInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needWorkflowStepsReviewed?: NeedWorkflowStepCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNeedsRequestedInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNeedsRequestedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNeedsRequestedInput, UserUncheckedCreateWithoutNeedsRequestedInput>
  }

  export type OrganizationCreateWithoutNeedsInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserCreateNestedManyWithoutOrganizationInput
    messages?: MessageCreateNestedManyWithoutOrganizationInput
    tasks?: TaskCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationUncheckedCreateWithoutNeedsInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    users?: UserUncheckedCreateNestedManyWithoutOrganizationInput
    messages?: MessageUncheckedCreateNestedManyWithoutOrganizationInput
    tasks?: TaskUncheckedCreateNestedManyWithoutOrganizationInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutOrganizationInput
    requisitions?: RequisitionUncheckedCreateNestedManyWithoutOrganizationInput
    meetings?: MeetingUncheckedCreateNestedManyWithoutOrganizationInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOrganizationInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutOrganizationInput
  }

  export type OrganizationCreateOrConnectWithoutNeedsInput = {
    where: OrganizationWhereUniqueInput
    create: XOR<OrganizationCreateWithoutNeedsInput, OrganizationUncheckedCreateWithoutNeedsInput>
  }

  export type NeedWorkflowStepCreateWithoutNeedInput = {
    id?: string
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
    reviewer?: UserCreateNestedOneWithoutNeedWorkflowStepsReviewedInput
  }

  export type NeedWorkflowStepUncheckedCreateWithoutNeedInput = {
    id?: string
    reviewerId?: number | null
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedWorkflowStepCreateOrConnectWithoutNeedInput = {
    where: NeedWorkflowStepWhereUniqueInput
    create: XOR<NeedWorkflowStepCreateWithoutNeedInput, NeedWorkflowStepUncheckedCreateWithoutNeedInput>
  }

  export type NeedWorkflowStepCreateManyNeedInputEnvelope = {
    data: NeedWorkflowStepCreateManyNeedInput | NeedWorkflowStepCreateManyNeedInput[]
  }

  export type NeedAttachmentCreateWithoutNeedInput = {
    id?: string
    fileName: string
    fileSize: number
    fileType: string
    uploadedBy: string
    url: string
    localPath?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedAttachmentUncheckedCreateWithoutNeedInput = {
    id?: string
    fileName: string
    fileSize: number
    fileType: string
    uploadedBy: string
    url: string
    localPath?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedAttachmentCreateOrConnectWithoutNeedInput = {
    where: NeedAttachmentWhereUniqueInput
    create: XOR<NeedAttachmentCreateWithoutNeedInput, NeedAttachmentUncheckedCreateWithoutNeedInput>
  }

  export type NeedAttachmentCreateManyNeedInputEnvelope = {
    data: NeedAttachmentCreateManyNeedInput | NeedAttachmentCreateManyNeedInput[]
  }

  export type UserUpsertWithoutNeedsRequestedInput = {
    update: XOR<UserUpdateWithoutNeedsRequestedInput, UserUncheckedUpdateWithoutNeedsRequestedInput>
    create: XOR<UserCreateWithoutNeedsRequestedInput, UserUncheckedCreateWithoutNeedsRequestedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNeedsRequestedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNeedsRequestedInput, UserUncheckedUpdateWithoutNeedsRequestedInput>
  }

  export type UserUpdateWithoutNeedsRequestedInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNeedsRequestedInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrganizationUpsertWithoutNeedsInput = {
    update: XOR<OrganizationUpdateWithoutNeedsInput, OrganizationUncheckedUpdateWithoutNeedsInput>
    create: XOR<OrganizationCreateWithoutNeedsInput, OrganizationUncheckedCreateWithoutNeedsInput>
    where?: OrganizationWhereInput
  }

  export type OrganizationUpdateToOneWithWhereWithoutNeedsInput = {
    where?: OrganizationWhereInput
    data: XOR<OrganizationUpdateWithoutNeedsInput, OrganizationUncheckedUpdateWithoutNeedsInput>
  }

  export type OrganizationUpdateWithoutNeedsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutOrganizationNestedInput
  }

  export type OrganizationUncheckedUpdateWithoutNeedsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: UserUncheckedUpdateManyWithoutOrganizationNestedInput
    messages?: MessageUncheckedUpdateManyWithoutOrganizationNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutOrganizationNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutOrganizationNestedInput
    requisitions?: RequisitionUncheckedUpdateManyWithoutOrganizationNestedInput
    meetings?: MeetingUncheckedUpdateManyWithoutOrganizationNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOrganizationNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationNestedInput
  }

  export type NeedWorkflowStepUpsertWithWhereUniqueWithoutNeedInput = {
    where: NeedWorkflowStepWhereUniqueInput
    update: XOR<NeedWorkflowStepUpdateWithoutNeedInput, NeedWorkflowStepUncheckedUpdateWithoutNeedInput>
    create: XOR<NeedWorkflowStepCreateWithoutNeedInput, NeedWorkflowStepUncheckedCreateWithoutNeedInput>
  }

  export type NeedWorkflowStepUpdateWithWhereUniqueWithoutNeedInput = {
    where: NeedWorkflowStepWhereUniqueInput
    data: XOR<NeedWorkflowStepUpdateWithoutNeedInput, NeedWorkflowStepUncheckedUpdateWithoutNeedInput>
  }

  export type NeedWorkflowStepUpdateManyWithWhereWithoutNeedInput = {
    where: NeedWorkflowStepScalarWhereInput
    data: XOR<NeedWorkflowStepUpdateManyMutationInput, NeedWorkflowStepUncheckedUpdateManyWithoutNeedInput>
  }

  export type NeedAttachmentUpsertWithWhereUniqueWithoutNeedInput = {
    where: NeedAttachmentWhereUniqueInput
    update: XOR<NeedAttachmentUpdateWithoutNeedInput, NeedAttachmentUncheckedUpdateWithoutNeedInput>
    create: XOR<NeedAttachmentCreateWithoutNeedInput, NeedAttachmentUncheckedCreateWithoutNeedInput>
  }

  export type NeedAttachmentUpdateWithWhereUniqueWithoutNeedInput = {
    where: NeedAttachmentWhereUniqueInput
    data: XOR<NeedAttachmentUpdateWithoutNeedInput, NeedAttachmentUncheckedUpdateWithoutNeedInput>
  }

  export type NeedAttachmentUpdateManyWithWhereWithoutNeedInput = {
    where: NeedAttachmentScalarWhereInput
    data: XOR<NeedAttachmentUpdateManyMutationInput, NeedAttachmentUncheckedUpdateManyWithoutNeedInput>
  }

  export type NeedAttachmentScalarWhereInput = {
    AND?: NeedAttachmentScalarWhereInput | NeedAttachmentScalarWhereInput[]
    OR?: NeedAttachmentScalarWhereInput[]
    NOT?: NeedAttachmentScalarWhereInput | NeedAttachmentScalarWhereInput[]
    id?: StringFilter<"NeedAttachment"> | string
    needId?: StringFilter<"NeedAttachment"> | string
    fileName?: StringFilter<"NeedAttachment"> | string
    fileSize?: IntFilter<"NeedAttachment"> | number
    fileType?: StringFilter<"NeedAttachment"> | string
    uploadedBy?: StringFilter<"NeedAttachment"> | string
    url?: StringFilter<"NeedAttachment"> | string
    localPath?: StringNullableFilter<"NeedAttachment"> | string | null
    createdAt?: DateTimeFilter<"NeedAttachment"> | Date | string
    syncId?: StringNullableFilter<"NeedAttachment"> | string | null
    needsSync?: BoolFilter<"NeedAttachment"> | boolean
  }

  export type NeedCreateWithoutWorkflowInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    requester?: UserCreateNestedOneWithoutNeedsRequestedInput
    organization: OrganizationCreateNestedOneWithoutNeedsInput
    attachments?: NeedAttachmentCreateNestedManyWithoutNeedInput
  }

  export type NeedUncheckedCreateWithoutWorkflowInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterId?: number | null
    requesterName?: string | null
    organizationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    attachments?: NeedAttachmentUncheckedCreateNestedManyWithoutNeedInput
  }

  export type NeedCreateOrConnectWithoutWorkflowInput = {
    where: NeedWhereUniqueInput
    create: XOR<NeedCreateWithoutWorkflowInput, NeedUncheckedCreateWithoutWorkflowInput>
  }

  export type UserCreateWithoutNeedWorkflowStepsReviewedInput = {
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    organization: OrganizationCreateNestedOneWithoutUsersInput
    messages?: MessageCreateNestedManyWithoutUserInput
    tasks?: TaskCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedCreateNestedManyWithoutRequesterInput
    meetingsCreated?: MeetingCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNeedWorkflowStepsReviewedInput = {
    id?: number
    organizationId: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    messages?: MessageUncheckedCreateNestedManyWithoutUserInput
    tasks?: TaskUncheckedCreateNestedManyWithoutUserInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
    requisitionsRequested?: RequisitionUncheckedCreateNestedManyWithoutRequesterInput
    workflowStepsReviewed?: WorkflowStepUncheckedCreateNestedManyWithoutReviewerInput
    needsRequested?: NeedUncheckedCreateNestedManyWithoutRequesterInput
    meetingsCreated?: MeetingUncheckedCreateNestedManyWithoutCreatorInput
    emailAccounts?: EmailAccountUncheckedCreateNestedManyWithoutOwnerInput
    emailSelections?: EmailActiveSelectionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNeedWorkflowStepsReviewedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNeedWorkflowStepsReviewedInput, UserUncheckedCreateWithoutNeedWorkflowStepsReviewedInput>
  }

  export type NeedUpsertWithoutWorkflowInput = {
    update: XOR<NeedUpdateWithoutWorkflowInput, NeedUncheckedUpdateWithoutWorkflowInput>
    create: XOR<NeedCreateWithoutWorkflowInput, NeedUncheckedCreateWithoutWorkflowInput>
    where?: NeedWhereInput
  }

  export type NeedUpdateToOneWithWhereWithoutWorkflowInput = {
    where?: NeedWhereInput
    data: XOR<NeedUpdateWithoutWorkflowInput, NeedUncheckedUpdateWithoutWorkflowInput>
  }

  export type NeedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    requester?: UserUpdateOneWithoutNeedsRequestedNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutNeedsNestedInput
    attachments?: NeedAttachmentUpdateManyWithoutNeedNestedInput
  }

  export type NeedUncheckedUpdateWithoutWorkflowInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    attachments?: NeedAttachmentUncheckedUpdateManyWithoutNeedNestedInput
  }

  export type UserUpsertWithoutNeedWorkflowStepsReviewedInput = {
    update: XOR<UserUpdateWithoutNeedWorkflowStepsReviewedInput, UserUncheckedUpdateWithoutNeedWorkflowStepsReviewedInput>
    create: XOR<UserCreateWithoutNeedWorkflowStepsReviewedInput, UserUncheckedCreateWithoutNeedWorkflowStepsReviewedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNeedWorkflowStepsReviewedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNeedWorkflowStepsReviewedInput, UserUncheckedUpdateWithoutNeedWorkflowStepsReviewedInput>
  }

  export type UserUpdateWithoutNeedWorkflowStepsReviewedInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    organization?: OrganizationUpdateOneRequiredWithoutUsersNestedInput
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNeedWorkflowStepsReviewedInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type NeedCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    requester?: UserCreateNestedOneWithoutNeedsRequestedInput
    organization: OrganizationCreateNestedOneWithoutNeedsInput
    workflow?: NeedWorkflowStepCreateNestedManyWithoutNeedInput
  }

  export type NeedUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterId?: number | null
    requesterName?: string | null
    organizationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    workflow?: NeedWorkflowStepUncheckedCreateNestedManyWithoutNeedInput
  }

  export type NeedCreateOrConnectWithoutAttachmentsInput = {
    where: NeedWhereUniqueInput
    create: XOR<NeedCreateWithoutAttachmentsInput, NeedUncheckedCreateWithoutAttachmentsInput>
  }

  export type NeedUpsertWithoutAttachmentsInput = {
    update: XOR<NeedUpdateWithoutAttachmentsInput, NeedUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<NeedCreateWithoutAttachmentsInput, NeedUncheckedCreateWithoutAttachmentsInput>
    where?: NeedWhereInput
  }

  export type NeedUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: NeedWhereInput
    data: XOR<NeedUpdateWithoutAttachmentsInput, NeedUncheckedUpdateWithoutAttachmentsInput>
  }

  export type NeedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    requester?: UserUpdateOneWithoutNeedsRequestedNestedInput
    organization?: OrganizationUpdateOneRequiredWithoutNeedsNestedInput
    workflow?: NeedWorkflowStepUpdateManyWithoutNeedNestedInput
  }

  export type NeedUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NeedWorkflowStepUncheckedUpdateManyWithoutNeedNestedInput
  }

  export type InvoiceCreateWithoutClientInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    sections?: InvoiceSectionCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutClientInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    sections?: InvoiceSectionUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceCreateManyClientInputEnvelope = {
    data: InvoiceCreateManyClientInput | InvoiceCreateManyClientInput[]
  }

  export type InvoiceUpsertWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutClientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutClientInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    invoiceNumber?: StringFilter<"Invoice"> | string
    template?: StringFilter<"Invoice"> | string
    company?: StringFilter<"Invoice"> | string
    clientId?: StringFilter<"Invoice"> | string
    clientSnapshot?: StringNullableFilter<"Invoice"> | string | null
    issueDate?: DateTimeFilter<"Invoice"> | Date | string
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    subtotal?: FloatFilter<"Invoice"> | number
    taxRate?: FloatFilter<"Invoice"> | number
    taxAmount?: FloatFilter<"Invoice"> | number
    total?: FloatFilter<"Invoice"> | number
    serviceType?: StringNullableFilter<"Invoice"> | string | null
    templateCode?: StringNullableFilter<"Invoice"> | string | null
    placementTVAEnabled?: BoolFilter<"Invoice"> | boolean
    chargesTTCMode?: BoolFilter<"Invoice"> | boolean
    placementDeduction?: FloatFilter<"Invoice"> | number
    enablePlacementDeduction?: BoolFilter<"Invoice"> | boolean
    transfertDeduction?: FloatFilter<"Invoice"> | number
    enableTransfertDeduction?: BoolFilter<"Invoice"> | boolean
    projectDescription?: StringNullableFilter<"Invoice"> | string | null
    projectName?: StringNullableFilter<"Invoice"> | string | null
    managementFeeRate?: FloatNullableFilter<"Invoice"> | number | null
    commissionRate?: FloatNullableFilter<"Invoice"> | number | null
    acomptes?: StringNullableFilter<"Invoice"> | string | null
    status?: StringFilter<"Invoice"> | string
    paymentTerms?: StringNullableFilter<"Invoice"> | string | null
    paymentMethod?: StringNullableFilter<"Invoice"> | string | null
    paidAt?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    paidAmount?: FloatFilter<"Invoice"> | number
    notes?: StringNullableFilter<"Invoice"> | string | null
    publicNotes?: StringNullableFilter<"Invoice"> | string | null
    createdBy?: StringFilter<"Invoice"> | string
    createdByInitials?: StringNullableFilter<"Invoice"> | string | null
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    syncId?: StringNullableFilter<"Invoice"> | string | null
    lastSynced?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    needsSync?: BoolFilter<"Invoice"> | boolean
  }

  export type InvoiceClientCreateWithoutInvoicesInput = {
    id?: string
    company: string
    companyName: string
    contactName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    taxNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type InvoiceClientUncheckedCreateWithoutInvoicesInput = {
    id?: string
    company: string
    companyName: string
    contactName: string
    email?: string | null
    phone?: string | null
    address?: string | null
    city?: string | null
    country?: string | null
    taxNumber?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type InvoiceClientCreateOrConnectWithoutInvoicesInput = {
    where: InvoiceClientWhereUniqueInput
    create: XOR<InvoiceClientCreateWithoutInvoicesInput, InvoiceClientUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceLineCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice?: number
    total?: number
    chargesTTC?: number | null
    squareMeters?: number | null
    days?: number | null
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceLineUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice?: number
    total?: number
    chargesTTC?: number | null
    squareMeters?: number | null
    days?: number | null
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceLineCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineCreateManyInvoiceInputEnvelope = {
    data: InvoiceLineCreateManyInvoiceInput | InvoiceLineCreateManyInvoiceInput[]
  }

  export type InvoiceSectionCreateWithoutInvoiceInput = {
    id?: string
    title: string
    subtotal?: number
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    lines?: InvoiceSectionLineCreateNestedManyWithoutSectionInput
  }

  export type InvoiceSectionUncheckedCreateWithoutInvoiceInput = {
    id?: string
    title: string
    subtotal?: number
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    lines?: InvoiceSectionLineUncheckedCreateNestedManyWithoutSectionInput
  }

  export type InvoiceSectionCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceSectionWhereUniqueInput
    create: XOR<InvoiceSectionCreateWithoutInvoiceInput, InvoiceSectionUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceSectionCreateManyInvoiceInputEnvelope = {
    data: InvoiceSectionCreateManyInvoiceInput | InvoiceSectionCreateManyInvoiceInput[]
  }

  export type InvoicePaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoicePaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoicePaymentCreateOrConnectWithoutInvoiceInput = {
    where: InvoicePaymentWhereUniqueInput
    create: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoicePaymentCreateManyInvoiceInputEnvelope = {
    data: InvoicePaymentCreateManyInvoiceInput | InvoicePaymentCreateManyInvoiceInput[]
  }

  export type InvoiceClientUpsertWithoutInvoicesInput = {
    update: XOR<InvoiceClientUpdateWithoutInvoicesInput, InvoiceClientUncheckedUpdateWithoutInvoicesInput>
    create: XOR<InvoiceClientCreateWithoutInvoicesInput, InvoiceClientUncheckedCreateWithoutInvoicesInput>
    where?: InvoiceClientWhereInput
  }

  export type InvoiceClientUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: InvoiceClientWhereInput
    data: XOR<InvoiceClientUpdateWithoutInvoicesInput, InvoiceClientUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceClientUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceClientUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    taxNumber?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceLineScalarWhereInput = {
    AND?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    OR?: InvoiceLineScalarWhereInput[]
    NOT?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    id?: StringFilter<"InvoiceLine"> | string
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    quantity?: FloatFilter<"InvoiceLine"> | number
    unitPrice?: FloatFilter<"InvoiceLine"> | number
    total?: FloatFilter<"InvoiceLine"> | number
    chargesTTC?: FloatNullableFilter<"InvoiceLine"> | number | null
    squareMeters?: FloatNullableFilter<"InvoiceLine"> | number | null
    days?: FloatNullableFilter<"InvoiceLine"> | number | null
    sortOrder?: IntFilter<"InvoiceLine"> | number
    createdAt?: DateTimeFilter<"InvoiceLine"> | Date | string
    syncId?: StringNullableFilter<"InvoiceLine"> | string | null
    needsSync?: BoolFilter<"InvoiceLine"> | boolean
  }

  export type InvoiceSectionUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceSectionWhereUniqueInput
    update: XOR<InvoiceSectionUpdateWithoutInvoiceInput, InvoiceSectionUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceSectionCreateWithoutInvoiceInput, InvoiceSectionUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceSectionUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceSectionWhereUniqueInput
    data: XOR<InvoiceSectionUpdateWithoutInvoiceInput, InvoiceSectionUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceSectionUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceSectionScalarWhereInput
    data: XOR<InvoiceSectionUpdateManyMutationInput, InvoiceSectionUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceSectionScalarWhereInput = {
    AND?: InvoiceSectionScalarWhereInput | InvoiceSectionScalarWhereInput[]
    OR?: InvoiceSectionScalarWhereInput[]
    NOT?: InvoiceSectionScalarWhereInput | InvoiceSectionScalarWhereInput[]
    id?: StringFilter<"InvoiceSection"> | string
    invoiceId?: StringFilter<"InvoiceSection"> | string
    title?: StringFilter<"InvoiceSection"> | string
    subtotal?: FloatFilter<"InvoiceSection"> | number
    sortOrder?: IntFilter<"InvoiceSection"> | number
    createdAt?: DateTimeFilter<"InvoiceSection"> | Date | string
    syncId?: StringNullableFilter<"InvoiceSection"> | string | null
    needsSync?: BoolFilter<"InvoiceSection"> | boolean
  }

  export type InvoicePaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoicePaymentWhereUniqueInput
    update: XOR<InvoicePaymentUpdateWithoutInvoiceInput, InvoicePaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoicePaymentCreateWithoutInvoiceInput, InvoicePaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoicePaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoicePaymentWhereUniqueInput
    data: XOR<InvoicePaymentUpdateWithoutInvoiceInput, InvoicePaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoicePaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoicePaymentScalarWhereInput
    data: XOR<InvoicePaymentUpdateManyMutationInput, InvoicePaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoicePaymentScalarWhereInput = {
    AND?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
    OR?: InvoicePaymentScalarWhereInput[]
    NOT?: InvoicePaymentScalarWhereInput | InvoicePaymentScalarWhereInput[]
    id?: StringFilter<"InvoicePayment"> | string
    invoiceId?: StringFilter<"InvoicePayment"> | string
    amount?: FloatFilter<"InvoicePayment"> | number
    paymentDate?: DateTimeFilter<"InvoicePayment"> | Date | string
    paymentMethod?: StringNullableFilter<"InvoicePayment"> | string | null
    reference?: StringNullableFilter<"InvoicePayment"> | string | null
    notes?: StringNullableFilter<"InvoicePayment"> | string | null
    createdAt?: DateTimeFilter<"InvoicePayment"> | Date | string
    syncId?: StringNullableFilter<"InvoicePayment"> | string | null
    needsSync?: BoolFilter<"InvoicePayment"> | boolean
  }

  export type InvoiceCreateWithoutLinesInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    client: InvoiceClientCreateNestedOneWithoutInvoicesInput
    sections?: InvoiceSectionCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLinesInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientId: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    sections?: InvoiceSectionUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLinesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
  }

  export type InvoiceUpsertWithoutLinesInput = {
    update: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLinesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    client?: InvoiceClientUpdateOneRequiredWithoutInvoicesNestedInput
    sections?: InvoiceSectionUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    sections?: InvoiceSectionUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutSectionsInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    client: InvoiceClientCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSectionsInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientId: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: InvoicePaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSectionsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSectionsInput, InvoiceUncheckedCreateWithoutSectionsInput>
  }

  export type InvoiceSectionLineCreateWithoutSectionInput = {
    id?: string
    description: string
    quantity?: number
    squareMeters?: number | null
    days?: number | null
    unitPrice?: number
    total?: number
    daysImpactPrice?: boolean
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceSectionLineUncheckedCreateWithoutSectionInput = {
    id?: string
    description: string
    quantity?: number
    squareMeters?: number | null
    days?: number | null
    unitPrice?: number
    total?: number
    daysImpactPrice?: boolean
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceSectionLineCreateOrConnectWithoutSectionInput = {
    where: InvoiceSectionLineWhereUniqueInput
    create: XOR<InvoiceSectionLineCreateWithoutSectionInput, InvoiceSectionLineUncheckedCreateWithoutSectionInput>
  }

  export type InvoiceSectionLineCreateManySectionInputEnvelope = {
    data: InvoiceSectionLineCreateManySectionInput | InvoiceSectionLineCreateManySectionInput[]
  }

  export type InvoiceUpsertWithoutSectionsInput = {
    update: XOR<InvoiceUpdateWithoutSectionsInput, InvoiceUncheckedUpdateWithoutSectionsInput>
    create: XOR<InvoiceCreateWithoutSectionsInput, InvoiceUncheckedCreateWithoutSectionsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutSectionsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutSectionsInput, InvoiceUncheckedUpdateWithoutSectionsInput>
  }

  export type InvoiceUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    client?: InvoiceClientUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceSectionLineUpsertWithWhereUniqueWithoutSectionInput = {
    where: InvoiceSectionLineWhereUniqueInput
    update: XOR<InvoiceSectionLineUpdateWithoutSectionInput, InvoiceSectionLineUncheckedUpdateWithoutSectionInput>
    create: XOR<InvoiceSectionLineCreateWithoutSectionInput, InvoiceSectionLineUncheckedCreateWithoutSectionInput>
  }

  export type InvoiceSectionLineUpdateWithWhereUniqueWithoutSectionInput = {
    where: InvoiceSectionLineWhereUniqueInput
    data: XOR<InvoiceSectionLineUpdateWithoutSectionInput, InvoiceSectionLineUncheckedUpdateWithoutSectionInput>
  }

  export type InvoiceSectionLineUpdateManyWithWhereWithoutSectionInput = {
    where: InvoiceSectionLineScalarWhereInput
    data: XOR<InvoiceSectionLineUpdateManyMutationInput, InvoiceSectionLineUncheckedUpdateManyWithoutSectionInput>
  }

  export type InvoiceSectionLineScalarWhereInput = {
    AND?: InvoiceSectionLineScalarWhereInput | InvoiceSectionLineScalarWhereInput[]
    OR?: InvoiceSectionLineScalarWhereInput[]
    NOT?: InvoiceSectionLineScalarWhereInput | InvoiceSectionLineScalarWhereInput[]
    id?: StringFilter<"InvoiceSectionLine"> | string
    sectionId?: StringFilter<"InvoiceSectionLine"> | string
    description?: StringFilter<"InvoiceSectionLine"> | string
    quantity?: FloatFilter<"InvoiceSectionLine"> | number
    squareMeters?: FloatNullableFilter<"InvoiceSectionLine"> | number | null
    days?: FloatNullableFilter<"InvoiceSectionLine"> | number | null
    unitPrice?: FloatFilter<"InvoiceSectionLine"> | number
    total?: FloatFilter<"InvoiceSectionLine"> | number
    daysImpactPrice?: BoolFilter<"InvoiceSectionLine"> | boolean
    sortOrder?: IntFilter<"InvoiceSectionLine"> | number
    createdAt?: DateTimeFilter<"InvoiceSectionLine"> | Date | string
    syncId?: StringNullableFilter<"InvoiceSectionLine"> | string | null
    needsSync?: BoolFilter<"InvoiceSectionLine"> | boolean
  }

  export type InvoiceSectionCreateWithoutLinesInput = {
    id?: string
    title: string
    subtotal?: number
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
    invoice: InvoiceCreateNestedOneWithoutSectionsInput
  }

  export type InvoiceSectionUncheckedCreateWithoutLinesInput = {
    id?: string
    invoiceId: string
    title: string
    subtotal?: number
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceSectionCreateOrConnectWithoutLinesInput = {
    where: InvoiceSectionWhereUniqueInput
    create: XOR<InvoiceSectionCreateWithoutLinesInput, InvoiceSectionUncheckedCreateWithoutLinesInput>
  }

  export type InvoiceSectionUpsertWithoutLinesInput = {
    update: XOR<InvoiceSectionUpdateWithoutLinesInput, InvoiceSectionUncheckedUpdateWithoutLinesInput>
    create: XOR<InvoiceSectionCreateWithoutLinesInput, InvoiceSectionUncheckedCreateWithoutLinesInput>
    where?: InvoiceSectionWhereInput
  }

  export type InvoiceSectionUpdateToOneWithWhereWithoutLinesInput = {
    where?: InvoiceSectionWhereInput
    data: XOR<InvoiceSectionUpdateWithoutLinesInput, InvoiceSectionUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceSectionUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    invoice?: InvoiceUpdateOneRequiredWithoutSectionsNestedInput
  }

  export type InvoiceSectionUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    client: InvoiceClientCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    sections?: InvoiceSectionCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientId: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    sections?: InvoiceSectionUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    client?: InvoiceClientUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    sections?: InvoiceSectionUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    sections?: InvoiceSectionUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type ExpenseCreateWithoutCategoryInput = {
    id?: string
    company: string
    description: string
    amount: number
    expenseDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    vendor?: string | null
    receiptUrl?: string | null
    localReceiptPath?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    isRecurring?: boolean
    recurringType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type ExpenseUncheckedCreateWithoutCategoryInput = {
    id?: string
    company: string
    description: string
    amount: number
    expenseDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    vendor?: string | null
    receiptUrl?: string | null
    localReceiptPath?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    isRecurring?: boolean
    recurringType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type ExpenseCreateOrConnectWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseCreateManyCategoryInputEnvelope = {
    data: ExpenseCreateManyCategoryInput | ExpenseCreateManyCategoryInput[]
  }

  export type ExpenseUpsertWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutCategoryInput, ExpenseUncheckedUpdateWithoutCategoryInput>
    create: XOR<ExpenseCreateWithoutCategoryInput, ExpenseUncheckedCreateWithoutCategoryInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutCategoryInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutCategoryInput, ExpenseUncheckedUpdateWithoutCategoryInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutCategoryInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: StringFilter<"Expense"> | string
    company?: StringFilter<"Expense"> | string
    categoryId?: StringNullableFilter<"Expense"> | string | null
    description?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    expenseDate?: DateTimeFilter<"Expense"> | Date | string
    paymentMethod?: StringNullableFilter<"Expense"> | string | null
    reference?: StringNullableFilter<"Expense"> | string | null
    vendor?: StringNullableFilter<"Expense"> | string | null
    receiptUrl?: StringNullableFilter<"Expense"> | string | null
    localReceiptPath?: StringNullableFilter<"Expense"> | string | null
    notes?: StringNullableFilter<"Expense"> | string | null
    createdBy?: StringNullableFilter<"Expense"> | string | null
    createdByName?: StringNullableFilter<"Expense"> | string | null
    isRecurring?: BoolFilter<"Expense"> | boolean
    recurringType?: StringNullableFilter<"Expense"> | string | null
    createdAt?: DateTimeFilter<"Expense"> | Date | string
    updatedAt?: DateTimeFilter<"Expense"> | Date | string
    syncId?: StringNullableFilter<"Expense"> | string | null
    lastSynced?: DateTimeNullableFilter<"Expense"> | Date | string | null
    needsSync?: BoolFilter<"Expense"> | boolean
  }

  export type ExpenseCategoryCreateWithoutExpensesInput = {
    id?: string
    company: string
    name: string
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type ExpenseCategoryUncheckedCreateWithoutExpensesInput = {
    id?: string
    company: string
    name: string
    color?: string | null
    icon?: string | null
    isActive?: boolean
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type ExpenseCategoryCreateOrConnectWithoutExpensesInput = {
    where: ExpenseCategoryWhereUniqueInput
    create: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
  }

  export type ExpenseCategoryUpsertWithoutExpensesInput = {
    update: XOR<ExpenseCategoryUpdateWithoutExpensesInput, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
    create: XOR<ExpenseCategoryCreateWithoutExpensesInput, ExpenseCategoryUncheckedCreateWithoutExpensesInput>
    where?: ExpenseCategoryWhereInput
  }

  export type ExpenseCategoryUpdateToOneWithWhereWithoutExpensesInput = {
    where?: ExpenseCategoryWhereInput
    data: XOR<ExpenseCategoryUpdateWithoutExpensesInput, ExpenseCategoryUncheckedUpdateWithoutExpensesInput>
  }

  export type ExpenseCategoryUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExpenseCategoryUncheckedUpdateWithoutExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserCreateManyOrganizationInput = {
    id?: number
    externalId?: string | null
    email?: string | null
    displayName?: string | null
    name?: string | null
    pinHash?: string | null
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
  }

  export type MessageCreateManyOrganizationInput = {
    id?: number
    userId?: number | null
    kind?: string
    channel?: string | null
    content: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type TaskCreateManyOrganizationInput = {
    id?: number
    userId?: number | null
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type ActivityLogCreateManyOrganizationInput = {
    id?: number
    userId?: number | null
    subjectType: string
    subjectId?: number | null
    action: string
    detail?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type RequisitionCreateManyOrganizationInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    requesterId?: number | null
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type NeedCreateManyOrganizationInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterId?: number | null
    requesterName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type MeetingCreateManyOrganizationInput = {
    id?: string
    creatorId?: number | null
    title: string
    notes?: string
    participants?: string | null
    status?: string
    extractedActions?: string | null
    tasksCreated?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type EmailAccountCreateManyOrganizationInput = {
    id?: string
    userId?: number | null
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type EmailActiveSelectionCreateManyOrganizationInput = {
    id?: number
    userId: number
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutOrganizationInput = {
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUpdateManyWithoutUserNestedInput
    tasks?: TaskUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: MessageUncheckedUpdateManyWithoutUserNestedInput
    tasks?: TaskUncheckedUpdateManyWithoutUserNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
    requisitionsRequested?: RequisitionUncheckedUpdateManyWithoutRequesterNestedInput
    workflowStepsReviewed?: WorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    needsRequested?: NeedUncheckedUpdateManyWithoutRequesterNestedInput
    needWorkflowStepsReviewed?: NeedWorkflowStepUncheckedUpdateManyWithoutReviewerNestedInput
    meetingsCreated?: MeetingUncheckedUpdateManyWithoutCreatorNestedInput
    emailAccounts?: EmailAccountUncheckedUpdateManyWithoutOwnerNestedInput
    emailSelections?: EmailActiveSelectionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    pinHash?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpdateWithoutOrganizationInput = {
    kind?: StringFieldUpdateOperationsInput | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    kind?: StringFieldUpdateOperationsInput | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskUpdateWithoutOrganizationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutTasksNestedInput
    runs?: TaskRunUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    runs?: TaskRunUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityLogUpdateWithoutOrganizationInput = {
    subjectType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    subjectType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityLogUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    subjectType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequisitionUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    requester?: UserUpdateOneWithoutRequisitionsRequestedNestedInput
    workflow?: WorkflowStepUpdateManyWithoutRequisitionNestedInput
  }

  export type RequisitionUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    workflow?: WorkflowStepUncheckedUpdateManyWithoutRequisitionNestedInput
  }

  export type RequisitionUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    requester?: UserUpdateOneWithoutNeedsRequestedNestedInput
    workflow?: NeedWorkflowStepUpdateManyWithoutNeedNestedInput
    attachments?: NeedAttachmentUpdateManyWithoutNeedNestedInput
  }

  export type NeedUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NeedWorkflowStepUncheckedUpdateManyWithoutNeedNestedInput
    attachments?: NeedAttachmentUncheckedUpdateManyWithoutNeedNestedInput
  }

  export type NeedUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterId?: NullableIntFieldUpdateOperationsInput | number | null
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MeetingUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    participants?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    extractedActions?: NullableStringFieldUpdateOperationsInput | string | null
    tasksCreated?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    creator?: UserUpdateOneWithoutMeetingsCreatedNestedInput
  }

  export type MeetingUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    participants?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    extractedActions?: NullableStringFieldUpdateOperationsInput | string | null
    tasksCreated?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MeetingUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    creatorId?: NullableIntFieldUpdateOperationsInput | number | null
    title?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    participants?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    extractedActions?: NullableStringFieldUpdateOperationsInput | string | null
    tasksCreated?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailAccountUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    owner?: UserUpdateOneWithoutEmailAccountsNestedInput
    selections?: EmailActiveSelectionUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    selections?: EmailActiveSelectionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateManyWithoutOrganizationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailActiveSelectionUpdateWithoutOrganizationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailSelectionsNestedInput
    account?: EmailAccountUpdateOneRequiredWithoutSelectionsNestedInput
  }

  export type EmailActiveSelectionUncheckedUpdateWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailActiveSelectionUncheckedUpdateManyWithoutOrganizationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyUserInput = {
    id?: number
    organizationId: number
    kind?: string
    channel?: string | null
    content: string
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type TaskCreateManyUserInput = {
    id?: number
    organizationId: number
    title: string
    description?: string | null
    status?: string
    dueAt?: Date | string | null
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type ActivityLogCreateManyUserInput = {
    id?: number
    organizationId: number
    subjectType: string
    subjectId?: number | null
    action: string
    detail?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type RequisitionCreateManyRequesterInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget: number
    justification: string
    status?: string
    organizationId: number
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type WorkflowStepCreateManyReviewerInput = {
    id?: string
    requisitionId: string
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedCreateManyRequesterInput = {
    id?: string
    title: string
    description: string
    category: string
    priority: string
    budget?: number
    justification?: string | null
    status?: string
    requesterName?: string | null
    organizationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type NeedWorkflowStepCreateManyReviewerInput = {
    id?: string
    needId: string
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type MeetingCreateManyCreatorInput = {
    id?: string
    organizationId: number
    title: string
    notes?: string
    participants?: string | null
    status?: string
    extractedActions?: string | null
    tasksCreated?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type EmailAccountCreateManyOwnerInput = {
    id?: string
    organizationId: number
    email: string
    providerId: string
    providerName?: string | null
    provider?: string | null
    credentials?: string | null
    isConnected?: boolean
    unreadCount?: number
    connectedAt?: Date | string | null
    lastSync?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type EmailActiveSelectionCreateManyUserInput = {
    id?: number
    organizationId: number
    accountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateWithoutUserInput = {
    kind?: StringFieldUpdateOperationsInput | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    kind?: StringFieldUpdateOperationsInput | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    kind?: StringFieldUpdateOperationsInput | string
    channel?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutTasksNestedInput
    runs?: TaskRunUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    runs?: TaskRunUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type TaskUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    dueAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityLogUpdateWithoutUserInput = {
    subjectType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    subjectType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    subjectType?: StringFieldUpdateOperationsInput | string
    subjectId?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type RequisitionUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutRequisitionsNestedInput
    workflow?: WorkflowStepUpdateManyWithoutRequisitionNestedInput
  }

  export type RequisitionUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    workflow?: WorkflowStepUncheckedUpdateManyWithoutRequisitionNestedInput
  }

  export type RequisitionUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    requisition?: RequisitionUpdateOneRequiredWithoutWorkflowNestedInput
  }

  export type WorkflowStepUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    requisitionId?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    requisitionId?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutNeedsNestedInput
    workflow?: NeedWorkflowStepUpdateManyWithoutNeedNestedInput
    attachments?: NeedAttachmentUpdateManyWithoutNeedNestedInput
  }

  export type NeedUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    workflow?: NeedWorkflowStepUncheckedUpdateManyWithoutNeedNestedInput
    attachments?: NeedAttachmentUncheckedUpdateManyWithoutNeedNestedInput
  }

  export type NeedUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    budget?: FloatFieldUpdateOperationsInput | number
    justification?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    requesterName?: NullableStringFieldUpdateOperationsInput | string | null
    organizationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedWorkflowStepUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    need?: NeedUpdateOneRequiredWithoutWorkflowNestedInput
  }

  export type NeedWorkflowStepUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    needId?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedWorkflowStepUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    needId?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MeetingUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    participants?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    extractedActions?: NullableStringFieldUpdateOperationsInput | string | null
    tasksCreated?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutMeetingsNestedInput
  }

  export type MeetingUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    participants?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    extractedActions?: NullableStringFieldUpdateOperationsInput | string | null
    tasksCreated?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MeetingUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    notes?: StringFieldUpdateOperationsInput | string
    participants?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    extractedActions?: NullableStringFieldUpdateOperationsInput | string | null
    tasksCreated?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailAccountUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    organization?: OrganizationUpdateOneRequiredWithoutEmailAccountsNestedInput
    selections?: EmailActiveSelectionUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    selections?: EmailActiveSelectionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type EmailAccountUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    organizationId?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    providerId?: StringFieldUpdateOperationsInput | string
    providerName?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    credentials?: NullableStringFieldUpdateOperationsInput | string | null
    isConnected?: BoolFieldUpdateOperationsInput | boolean
    unreadCount?: IntFieldUpdateOperationsInput | number
    connectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailActiveSelectionUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutEmailSelectionsNestedInput
    account?: EmailAccountUpdateOneRequiredWithoutSelectionsNestedInput
  }

  export type EmailActiveSelectionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailActiveSelectionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    accountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskRunCreateManyTaskInput = {
    id?: number
    runType?: string
    result?: string
    message?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type TaskRunUpdateWithoutTaskInput = {
    runType?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskRunUncheckedUpdateWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    runType?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TaskRunUncheckedUpdateManyWithoutTaskInput = {
    id?: IntFieldUpdateOperationsInput | number
    runType?: StringFieldUpdateOperationsInput | string
    result?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepCreateManyRequisitionInput = {
    id?: string
    reviewerId?: number | null
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type WorkflowStepUpdateWithoutRequisitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    reviewer?: UserUpdateOneWithoutWorkflowStepsReviewedNestedInput
  }

  export type WorkflowStepUncheckedUpdateWithoutRequisitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkflowStepUncheckedUpdateManyWithoutRequisitionInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type EmailActiveSelectionCreateManyAccountInput = {
    id?: number
    organizationId: number
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailActiveSelectionUpdateWithoutAccountInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    organization?: OrganizationUpdateOneRequiredWithoutEmailSelectionsNestedInput
    user?: UserUpdateOneRequiredWithoutEmailSelectionsNestedInput
  }

  export type EmailActiveSelectionUncheckedUpdateWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailActiveSelectionUncheckedUpdateManyWithoutAccountInput = {
    id?: IntFieldUpdateOperationsInput | number
    organizationId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NeedWorkflowStepCreateManyNeedInput = {
    id?: string
    reviewerId?: number | null
    reviewerName: string
    reviewerLevel: number
    action?: string
    isRequired?: boolean
    isCompleted?: boolean
    comment?: string | null
    createdAt?: Date | string
    completedAt?: Date | string | null
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedAttachmentCreateManyNeedInput = {
    id?: string
    fileName: string
    fileSize: number
    fileType: string
    uploadedBy: string
    url: string
    localPath?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type NeedWorkflowStepUpdateWithoutNeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    reviewer?: UserUpdateOneWithoutNeedWorkflowStepsReviewedNestedInput
  }

  export type NeedWorkflowStepUncheckedUpdateWithoutNeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedWorkflowStepUncheckedUpdateManyWithoutNeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewerId?: NullableIntFieldUpdateOperationsInput | number | null
    reviewerName?: StringFieldUpdateOperationsInput | string
    reviewerLevel?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    isRequired?: BoolFieldUpdateOperationsInput | boolean
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedAttachmentUpdateWithoutNeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    localPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedAttachmentUncheckedUpdateWithoutNeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    localPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NeedAttachmentUncheckedUpdateManyWithoutNeedInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: IntFieldUpdateOperationsInput | number
    fileType?: StringFieldUpdateOperationsInput | string
    uploadedBy?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    localPath?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceCreateManyClientInput = {
    id?: string
    invoiceNumber: string
    template: string
    company: string
    clientSnapshot?: string | null
    issueDate: Date | string
    dueDate: Date | string
    subtotal?: number
    taxRate?: number
    taxAmount?: number
    total?: number
    serviceType?: string | null
    templateCode?: string | null
    placementTVAEnabled?: boolean
    chargesTTCMode?: boolean
    placementDeduction?: number
    enablePlacementDeduction?: boolean
    transfertDeduction?: number
    enableTransfertDeduction?: boolean
    projectDescription?: string | null
    projectName?: string | null
    managementFeeRate?: number | null
    commissionRate?: number | null
    acomptes?: string | null
    status?: string
    paymentTerms?: string | null
    paymentMethod?: string | null
    paidAt?: Date | string | null
    paidAmount?: number
    notes?: string | null
    publicNotes?: string | null
    createdBy: string
    createdByInitials?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type InvoiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    sections?: InvoiceSectionUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    sections?: InvoiceSectionUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: InvoicePaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceNumber?: StringFieldUpdateOperationsInput | string
    template?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    clientSnapshot?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    serviceType?: NullableStringFieldUpdateOperationsInput | string | null
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    placementTVAEnabled?: BoolFieldUpdateOperationsInput | boolean
    chargesTTCMode?: BoolFieldUpdateOperationsInput | boolean
    placementDeduction?: FloatFieldUpdateOperationsInput | number
    enablePlacementDeduction?: BoolFieldUpdateOperationsInput | boolean
    transfertDeduction?: FloatFieldUpdateOperationsInput | number
    enableTransfertDeduction?: BoolFieldUpdateOperationsInput | boolean
    projectDescription?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    managementFeeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acomptes?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    paymentTerms?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paidAmount?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    publicNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: StringFieldUpdateOperationsInput | string
    createdByInitials?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineCreateManyInvoiceInput = {
    id?: string
    description: string
    quantity?: number
    unitPrice?: number
    total?: number
    chargesTTC?: number | null
    squareMeters?: number | null
    days?: number | null
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceSectionCreateManyInvoiceInput = {
    id?: string
    title: string
    subtotal?: number
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoicePaymentCreateManyInvoiceInput = {
    id?: string
    amount: number
    paymentDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    notes?: string | null
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceLineUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    chargesTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    chargesTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    chargesTTC?: NullableFloatFieldUpdateOperationsInput | number | null
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceSectionUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceSectionLineUpdateManyWithoutSectionNestedInput
  }

  export type InvoiceSectionUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
    lines?: InvoiceSectionLineUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type InvoiceSectionUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtotal?: FloatFieldUpdateOperationsInput | number
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoicePaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoicePaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoicePaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceSectionLineCreateManySectionInput = {
    id?: string
    description: string
    quantity?: number
    squareMeters?: number | null
    days?: number | null
    unitPrice?: number
    total?: number
    daysImpactPrice?: boolean
    sortOrder?: number
    createdAt?: Date | string
    syncId?: string | null
    needsSync?: boolean
  }

  export type InvoiceSectionLineUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    daysImpactPrice?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceSectionLineUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    daysImpactPrice?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceSectionLineUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    squareMeters?: NullableFloatFieldUpdateOperationsInput | number | null
    days?: NullableFloatFieldUpdateOperationsInput | number | null
    unitPrice?: FloatFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    daysImpactPrice?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExpenseCreateManyCategoryInput = {
    id?: string
    company: string
    description: string
    amount: number
    expenseDate: Date | string
    paymentMethod?: string | null
    reference?: string | null
    vendor?: string | null
    receiptUrl?: string | null
    localReceiptPath?: string | null
    notes?: string | null
    createdBy?: string | null
    createdByName?: string | null
    isRecurring?: boolean
    recurringType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    syncId?: string | null
    lastSynced?: Date | string | null
    needsSync?: boolean
  }

  export type ExpenseUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localReceiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExpenseUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localReceiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExpenseUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    company?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    vendor?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    localReceiptPath?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdByName?: NullableStringFieldUpdateOperationsInput | string | null
    isRecurring?: BoolFieldUpdateOperationsInput | boolean
    recurringType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    syncId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    needsSync?: BoolFieldUpdateOperationsInput | boolean
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}